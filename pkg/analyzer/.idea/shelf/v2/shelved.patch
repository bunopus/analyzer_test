Index: lib/src/task/dart.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:collection';\n\nimport 'package:analyzer/dart/ast/ast.dart';\nimport 'package:analyzer/dart/ast/standard_resolution_map.dart';\nimport 'package:analyzer/dart/ast/token.dart';\nimport 'package:analyzer/dart/ast/visitor.dart';\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/type.dart';\nimport 'package:analyzer/error/error.dart';\nimport 'package:analyzer/error/listener.dart';\nimport 'package:analyzer/exception/exception.dart';\nimport 'package:analyzer/source/line_info.dart';\nimport 'package:analyzer/src/context/cache.dart';\nimport 'package:analyzer/src/dart/ast/ast.dart'\n    show NamespaceDirectiveImpl, UriBasedDirectiveImpl, UriValidationCode;\nimport 'package:analyzer/src/dart/ast/utilities.dart';\nimport 'package:analyzer/src/dart/element/builder.dart';\nimport 'package:analyzer/src/dart/element/element.dart';\nimport 'package:analyzer/src/dart/resolver/inheritance_manager.dart';\nimport 'package:analyzer/src/dart/scanner/reader.dart';\nimport 'package:analyzer/src/dart/scanner/scanner.dart';\nimport 'package:analyzer/src/dart/sdk/patch.dart';\nimport 'package:analyzer/src/dart/sdk/sdk.dart';\nimport 'package:analyzer/src/error/codes.dart';\nimport 'package:analyzer/src/error/pending_error.dart';\nimport 'package:analyzer/src/generated/constant.dart';\nimport 'package:analyzer/src/generated/declaration_resolver.dart';\nimport 'package:analyzer/src/generated/engine.dart';\nimport 'package:analyzer/src/generated/error_verifier.dart';\nimport 'package:analyzer/src/generated/incremental_resolver.dart';\nimport 'package:analyzer/src/generated/parser.dart';\nimport 'package:analyzer/src/generated/resolver.dart';\nimport 'package:analyzer/src/generated/sdk.dart';\nimport 'package:analyzer/src/generated/source.dart';\nimport 'package:analyzer/src/generated/utilities_dart.dart';\nimport 'package:analyzer/src/plugin/engine_plugin.dart';\nimport 'package:analyzer/src/services/lint.dart';\nimport 'package:analyzer/src/task/api/dart.dart';\nimport 'package:analyzer/src/task/api/general.dart';\nimport 'package:analyzer/src/task/api/model.dart';\nimport 'package:analyzer/src/task/driver.dart';\nimport 'package:analyzer/src/task/general.dart';\nimport 'package:analyzer/src/task/html.dart';\nimport 'package:analyzer/src/task/inputs.dart';\nimport 'package:analyzer/src/task/model.dart';\nimport 'package:analyzer/src/task/strong/checker.dart';\nimport 'package:analyzer/src/task/strong_mode.dart';\n\n/**\n * The [ResultCachingPolicy] for ASTs.\n */\nconst ResultCachingPolicy AST_CACHING_POLICY =\n    const SimpleResultCachingPolicy(1024 * 64, 32);\n\n/**\n * The [ResultCachingPolicy] for lists of [ConstantEvaluationTarget]s.\n */\nconst ResultCachingPolicy CONSTANT_EVALUATION_TARGET_LIST_POLICY =\n    const SimpleResultCachingPolicy(-1, -1);\n\n/**\n * The [ResultCachingPolicy] for [ConstantEvaluationTarget]s.\n */\nconst ResultCachingPolicy CONSTANT_EVALUATION_TARGET_POLICY =\n    const SimpleResultCachingPolicy(-1, -1);\n\n/**\n * The [ResultCachingPolicy] for [Element]s.\n */\nconst ResultCachingPolicy ELEMENT_CACHING_POLICY =\n    const SimpleResultCachingPolicy(-1, -1);\n\n/**\n * The [ResultCachingPolicy] for [TOKEN_STREAM].\n */\nconst ResultCachingPolicy TOKEN_STREAM_CACHING_POLICY =\n    const SimpleResultCachingPolicy(1, 1);\n\n/**\n * The [ResultCachingPolicy] for [UsedImportedElements]s.\n */\nconst ResultCachingPolicy USED_IMPORTED_ELEMENTS_POLICY =\n    const SimpleResultCachingPolicy(-1, -1);\n\n/**\n * The [ResultCachingPolicy] for [UsedLocalElements]s.\n */\nconst ResultCachingPolicy USED_LOCAL_ELEMENTS_POLICY =\n    const SimpleResultCachingPolicy(-1, -1);\n\n/**\n * The errors produced while building a library's directives.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<AnalysisError> BUILD_DIRECTIVES_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'BUILD_DIRECTIVES_ERRORS', AnalysisError.NO_ERRORS);\n/**\n * The errors produced while building a library element.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<AnalysisError> BUILD_LIBRARY_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'BUILD_LIBRARY_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * A list of the [ConstantEvaluationTarget]s defined in a unit.  This includes\n * constants defined at top level, statically inside classes, and local to\n * functions, as well as constant constructors, annotations, and default values\n * of parameters.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<ConstantEvaluationTarget>\n    COMPILATION_UNIT_CONSTANTS =\n    new ListResultDescriptor<ConstantEvaluationTarget>(\n        'COMPILATION_UNIT_CONSTANTS', null,\n        cachingPolicy: CONSTANT_EVALUATION_TARGET_LIST_POLICY);\n\n/**\n * The element model associated with a single compilation unit.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnitElement> COMPILATION_UNIT_ELEMENT =\n    new ResultDescriptor<CompilationUnitElement>(\n        'COMPILATION_UNIT_ELEMENT', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The list of [ConstantEvaluationTarget]s on which the target constant element\n * depends.\n *\n * The result is only available for targets representing a\n * [ConstantEvaluationTarget] (i.e. a constant variable declaration, a constant\n * constructor, or a parameter element with a default value).\n */\nfinal ListResultDescriptor<ConstantEvaluationTarget> CONSTANT_DEPENDENCIES =\n    new ListResultDescriptor<ConstantEvaluationTarget>(\n        'CONSTANT_DEPENDENCIES', const <ConstantEvaluationTarget>[]);\n\n/**\n * The flag specifying that the target constant element expression AST is\n * resolved, i.e. identifiers have all required elements set.\n *\n * The result is only available for targets representing a\n * [ConstantEvaluationTarget] (i.e. a constant variable declaration, a constant\n * constructor, or a parameter element with a default value).\n */\nfinal ResultDescriptor<bool> CONSTANT_EXPRESSION_RESOLVED =\n    new ResultDescriptor<bool>('CONSTANT_EXPRESSION_RESOLVED', false);\n\n/**\n * The list of [ConstantEvaluationTarget]s on which constant expressions of a\n * unit depend.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<ConstantEvaluationTarget>\n    CONSTANT_EXPRESSIONS_DEPENDENCIES =\n    new ListResultDescriptor<ConstantEvaluationTarget>(\n        'CONSTANT_EXPRESSIONS_DEPENDENCIES',\n        const <ConstantEvaluationTarget>[]);\n\n/**\n * A [ConstantEvaluationTarget] that has been successfully constant-evaluated.\n *\n * TODO(paulberry): is ELEMENT_CACHING_POLICY the correct caching policy?\n *\n * The result is only available for [ConstantEvaluationTarget]s.\n *\n */\nfinal ResultDescriptor<ConstantEvaluationTarget> CONSTANT_VALUE =\n    new ResultDescriptor<ConstantEvaluationTarget>('CONSTANT_VALUE', null,\n        cachingPolicy: CONSTANT_EVALUATION_TARGET_POLICY);\n\n/**\n * The sources representing the libraries that include a given source as a part.\n *\n * The result is only available for [Source]s representing a compilation unit.\n */\nfinal ListResultDescriptor<Source> CONTAINING_LIBRARIES =\n    new ListResultDescriptor<Source>('CONTAINING_LIBRARIES', Source.EMPTY_LIST);\n\n/**\n * The flag specifying that [RESOLVED_UNIT] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT1] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT1 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT1', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT10] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT10 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT10', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT11] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT11 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT11', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT12] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT12 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT12', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT2] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT2 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT2', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT3] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT3 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT3', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT4] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT4 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT4', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT5] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT5 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT5', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT6] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT6 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT6', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT7] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT7 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT7', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT8] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT8 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT8', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT9] has been been computed for this\n * compilation unit (without requiring that the AST for it still be in cache).\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<bool> CREATED_RESOLVED_UNIT9 =\n    new ResultDescriptor<bool>('CREATED_RESOLVED_UNIT9', false);\n\n/**\n * All [AnalysisError]s results for [Source]s.\n */\nfinal List<ListResultDescriptor<AnalysisError>> ERROR_SOURCE_RESULTS =\n    <ListResultDescriptor<AnalysisError>>[\n  BUILD_DIRECTIVES_ERRORS,\n  BUILD_LIBRARY_ERRORS,\n  PARSE_ERRORS,\n  SCAN_ERRORS,\n];\n\n/**\n * All [AnalysisError]s results in for [LibrarySpecificUnit]s.\n */\nfinal List<ListResultDescriptor<AnalysisError>> ERROR_UNIT_RESULTS =\n    <ListResultDescriptor<AnalysisError>>[\n  HINTS,\n  LIBRARY_UNIT_ERRORS,\n  LINTS,\n  RESOLVE_DIRECTIVES_ERRORS,\n  RESOLVE_TYPE_BOUNDS_ERRORS,\n  RESOLVE_TYPE_NAMES_ERRORS,\n  RESOLVE_UNIT_ERRORS,\n  STRONG_MODE_ERRORS,\n  VARIABLE_REFERENCE_ERRORS,\n  VERIFY_ERRORS\n];\n\n/**\n * The sources representing the export closure of a library.\n * The [Source]s include only library sources, not their units.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<Source> EXPORT_SOURCE_CLOSURE =\n    new ListResultDescriptor<Source>('EXPORT_SOURCE_CLOSURE', null);\n\n/**\n * The errors produced while generating hints a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> HINTS =\n    new ListResultDescriptor<AnalysisError>(\n        'HINT_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The ignore information for a [Source].\n */\nfinal ResultDescriptor<IgnoreInfo> IGNORE_INFO =\n    new ResultDescriptor<IgnoreInfo>('IGNORE_INFO', null);\n\n/**\n * A list of the [VariableElement]s whose type should be inferred that another\n * inferable static variable (the target) depends on.\n *\n * The result is only available for [VariableElement]s, and only when strong\n * mode is enabled.\n */\nfinal ListResultDescriptor<VariableElement>\n    INFERABLE_STATIC_VARIABLE_DEPENDENCIES =\n    new ListResultDescriptor<VariableElement>(\n        'INFERABLE_STATIC_VARIABLE_DEPENDENCIES', null);\n\n/**\n * A list of the [VariableElement]s defined in a unit whose type should be\n * inferred. This includes variables defined at the library level as well as\n * static members inside classes.\n *\n * The result is only available for [LibrarySpecificUnit]s, and only when strong\n * mode is enabled.\n */\nfinal ListResultDescriptor<VariableElement> INFERABLE_STATIC_VARIABLES_IN_UNIT =\n    new ListResultDescriptor<VariableElement>(\n        'INFERABLE_STATIC_VARIABLES_IN_UNIT', null);\n\n/**\n * An inferable static variable ([VariableElement]) whose type has been\n * inferred.\n *\n * The result is only available for [VariableElement]s, and only when strong\n * mode is enabled.\n */\nfinal ResultDescriptor<VariableElement> INFERRED_STATIC_VARIABLE =\n    new ResultDescriptor<VariableElement>('INFERRED_STATIC_VARIABLE', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * A list of the [LibraryElement]s that make up the strongly connected\n * component in the import/export graph in which the target resides.\n *\n * Only non-empty in strongMode.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<LibraryElement> LIBRARY_CYCLE =\n    new ListResultDescriptor<LibraryElement>('LIBRARY_CYCLE', null);\n\n/**\n * A list of the [LibrarySpecificUnit]s that comprise all of the parts and\n * libraries in the direct import/export dependencies of the library cycle\n * of the target, with the intra-component dependencies excluded.\n *\n * Only non-empty in strongMode.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<LibrarySpecificUnit> LIBRARY_CYCLE_DEPENDENCIES =\n    new ListResultDescriptor<LibrarySpecificUnit>(\n        'LIBRARY_CYCLE_DEPENDENCIES', null);\n\n/**\n * A list of the [LibrarySpecificUnit]s (including all parts) that make up\n * the strongly connected component in the import/export graph in which the\n * target resides.\n *\n * Only non-empty in strongMode.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<LibrarySpecificUnit> LIBRARY_CYCLE_UNITS =\n    new ListResultDescriptor<LibrarySpecificUnit>('LIBRARY_CYCLE_UNITS', null);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * The [LibraryElement] and its [CompilationUnitElement]s are attached to each\n * other. Directives 'library', 'part' and 'part of' are resolved.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT1 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT1', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * In addition to [LIBRARY_ELEMENT1] also [LibraryElement.imports] and\n * [LibraryElement.exports] are set.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT2 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT2', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * In addition to [LIBRARY_ELEMENT2] the [LibraryElement.publicNamespace] is set.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT3 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT3', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * In addition to [LIBRARY_ELEMENT3] the [LibraryElement.entryPoint] is set,\n * if the library does not declare one already and one of the exported\n * libraries exports one.\n *\n * Also [LibraryElement.exportNamespace] is set.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT4 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT4', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * [LIBRARY_ELEMENT5] plus resolved types type parameter bounds.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT5 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT5', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * [LIBRARY_ELEMENT5] plus resolved types for every element.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT6 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT6', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * [LIBRARY_ELEMENT6] plus [RESOLVED_UNIT7] for all library units.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT7 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT7', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * [LIBRARY_ELEMENT7] for the library and its import/export closure.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT8 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT8', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * The partial [LibraryElement] associated with a library.\n *\n * The same as a [LIBRARY_ELEMENT8].\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<LibraryElement> LIBRARY_ELEMENT9 =\n    new ResultDescriptor<LibraryElement>('LIBRARY_ELEMENT9', null,\n        cachingPolicy: ELEMENT_CACHING_POLICY);\n\n/**\n * List of all `LIBRARY_ELEMENT` results.\n */\nfinal List<ResultDescriptor<LibraryElement>> LIBRARY_ELEMENT_RESULTS =\n    <ResultDescriptor<LibraryElement>>[\n  LIBRARY_ELEMENT1,\n  LIBRARY_ELEMENT2,\n  LIBRARY_ELEMENT3,\n  LIBRARY_ELEMENT4,\n  LIBRARY_ELEMENT5,\n  LIBRARY_ELEMENT6,\n  LIBRARY_ELEMENT7,\n  LIBRARY_ELEMENT8,\n  LIBRARY_ELEMENT9,\n  LIBRARY_ELEMENT\n];\n\n/**\n * The flag specifying whether all analysis errors are computed in a specific\n * library.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<bool> LIBRARY_ERRORS_READY =\n    new ResultDescriptor<bool>('LIBRARY_ERRORS_READY', false);\n\n/**\n * The [LibrarySpecificUnit]s that a library consists of.\n *\n * The list will include the defining unit and units for [INCLUDED_PARTS].\n * So, it is never empty or `null`.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<LibrarySpecificUnit> LIBRARY_SPECIFIC_UNITS =\n    new ListResultDescriptor<LibrarySpecificUnit>(\n        'LIBRARY_SPECIFIC_UNITS', LibrarySpecificUnit.EMPTY_LIST);\n\n/**\n * The analysis errors associated with a compilation unit in a specific library.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> LIBRARY_UNIT_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'LIBRARY_UNIT_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while generating lints for a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> LINTS =\n    new ListResultDescriptor<AnalysisError>(\n        'LINT_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while parsing a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [Source]s representing a compilation unit.\n */\nfinal ListResultDescriptor<AnalysisError> PARSE_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'PARSE_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The list of [PendingError]s for a compilation unit.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<PendingError> PENDING_ERRORS =\n    new ListResultDescriptor<PendingError>(\n        'PENDING_ERRORS', const <PendingError>[]);\n\n/**\n * The flag specifying that [LIBRARY_ELEMENT2] is ready for a library and its\n * import/export closure.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<bool> READY_LIBRARY_ELEMENT2 =\n    new ResultDescriptor<bool>('READY_LIBRARY_ELEMENT2', false);\n\n/**\n * The flag specifying that [LIBRARY_ELEMENT6] is ready for a library and its\n * import/export closure.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<bool> READY_LIBRARY_ELEMENT6 =\n    new ResultDescriptor<bool>('READY_LIBRARY_ELEMENT6', false);\n\n/**\n * The flag specifying that [LIBRARY_ELEMENT7] is ready for a library and its\n * import/export closure.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<bool> READY_LIBRARY_ELEMENT7 =\n    new ResultDescriptor<bool>('READY_LIBRARY_ELEMENT7', false);\n\n/**\n * The flag specifying that [RESOLVED_UNIT] is ready for all of the units of a\n * library.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ResultDescriptor<bool> READY_RESOLVED_UNIT =\n    new ResultDescriptor<bool>('READY_RESOLVED_UNIT', false);\n\n/**\n * The sources of the Dart files that a library references.\n *\n * The list is the union of [IMPORTED_LIBRARIES], [EXPORTED_LIBRARIES] and\n * [UNITS] of the defining unit and [INCLUDED_PARTS]. Never empty or `null`.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<Source> REFERENCED_SOURCES =\n    new ListResultDescriptor<Source>('REFERENCED_SOURCES', Source.EMPTY_LIST);\n\n/**\n * The list of [ConstantEvaluationTarget]s on which error verification depends.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<ConstantEvaluationTarget> REQUIRED_CONSTANTS =\n    new ListResultDescriptor<ConstantEvaluationTarget>(\n        'REQUIRED_CONSTANTS', const <ConstantEvaluationTarget>[]);\n\n/**\n * The errors produced while resolving a library's directives.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [Source]s representing a library.\n */\nfinal ListResultDescriptor<AnalysisError> RESOLVE_DIRECTIVES_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'RESOLVE_DIRECTIVES_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while resolving bounds of type parameters of classes,\n * class and function aliases.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> RESOLVE_TYPE_BOUNDS_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'RESOLVE_TYPE_BOUNDS_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while resolving type names.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> RESOLVE_TYPE_NAMES_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'RESOLVE_TYPE_NAMES_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while resolving a full compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> RESOLVE_UNIT_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'RESOLVE_UNIT_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * Tasks that use this value as an input can assume that the [SimpleIdentifier]s\n * at all declaration sites have been bound to the element defined by the\n * declaration, except for the constants defined in an 'enum' declaration.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT1 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT1', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The resolved [CompilationUnit] associated with a compilation unit in which\n * the types of class members have been inferred in addition to everything that\n * is true of a [RESOLVED_UNIT9].\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT10 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT10', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The resolved [CompilationUnit] associated with a compilation unit, with\n * constants not yet resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT11 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT11', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The resolved [CompilationUnit] associated with a compilation unit, with\n * constants resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT12 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT12', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT1], tasks that use this value\n * as an input can assume that its directives have been resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT2 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT2', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * Tasks that use this value as an input can assume that the [SimpleIdentifier]s\n * at all declaration sites have been bound to the element defined by the\n * declaration, including the constants defined in an 'enum' declaration.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT3 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT3', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT3], tasks that use this value\n * as an input can assume that the types associated with type bounds have been\n * resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT4 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT4', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT4], tasks that use this value\n * as an input can assume that the types associated with declarations have been\n * resolved. This includes the types of superclasses, mixins, interfaces,\n * fields, return types, parameters, and local variables.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT5 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT5', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT5], tasks that use this value\n * as an input can assume that references to local variables and formal\n * parameters have been resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT6 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT6', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT6], tasks that use this value\n * as an input can assume that elements and types associated with expressions\n * outside of method bodies (essentially initializers) have been initially\n * resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT7 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT7', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT7], tasks that use this value\n * as an input can assume that the types of static variables have been inferred.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT8 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT8', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * The partially resolved [CompilationUnit] associated with a compilation unit.\n *\n * In addition to what is true of a [RESOLVED_UNIT8], tasks that use this value\n * as an input can assume that the initializers of instance variables have been\n * re-resolved.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ResultDescriptor<CompilationUnit> RESOLVED_UNIT9 =\n    new ResultDescriptor<CompilationUnit>('RESOLVED_UNIT9', null,\n        cachingPolicy: AST_CACHING_POLICY);\n\n/**\n * List of all `RESOLVED_UNITx` results.\n */\nfinal List<ResultDescriptor<CompilationUnit>> RESOLVED_UNIT_RESULTS =\n    <ResultDescriptor<CompilationUnit>>[\n  RESOLVED_UNIT1,\n  RESOLVED_UNIT2,\n  RESOLVED_UNIT3,\n  RESOLVED_UNIT4,\n  RESOLVED_UNIT5,\n  RESOLVED_UNIT6,\n  RESOLVED_UNIT7,\n  RESOLVED_UNIT8,\n  RESOLVED_UNIT9,\n  RESOLVED_UNIT10,\n  RESOLVED_UNIT11,\n  RESOLVED_UNIT12,\n  RESOLVED_UNIT\n];\n\n/**\n * The errors produced while scanning a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [Source]s representing a compilation unit.\n */\nfinal ListResultDescriptor<AnalysisError> SCAN_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'SCAN_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while resolving a static [VariableElement] initializer.\n *\n * The result is only available for [VariableElement]s, and only when strong\n * mode is enabled.\n */\nfinal ListResultDescriptor<AnalysisError> STATIC_VARIABLE_RESOLUTION_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'STATIC_VARIABLE_RESOLUTION_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * A list of the [AnalysisError]s reported while resolving static\n * [INFERABLE_STATIC_VARIABLES_IN_UNIT] defined in a unit.\n *\n * The result is only available for [LibrarySpecificUnit]s, and only when strong\n * mode is enabled.\n */\nfinal ListResultDescriptor<AnalysisError>\n    STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT =\n    new ListResultDescriptor<AnalysisError>(\n        'STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT', AnalysisError.NO_ERRORS);\n\n/**\n * The additional strong mode errors produced while verifying a\n * compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnits]s representing a\n * compilation unit.\n *\n */\nfinal ListResultDescriptor<AnalysisError> STRONG_MODE_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'STRONG_MODE_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The [TypeProvider] of the [AnalysisContext].\n */\nfinal ResultDescriptor<TypeProvider> TYPE_PROVIDER =\n    new ResultDescriptor<TypeProvider>('TYPE_PROVIDER', null);\n\n/**\n * The [UsedImportedElements] of a [LibrarySpecificUnit].\n */\nfinal ResultDescriptor<UsedImportedElements> USED_IMPORTED_ELEMENTS =\n    new ResultDescriptor<UsedImportedElements>('USED_IMPORTED_ELEMENTS', null,\n        cachingPolicy: USED_IMPORTED_ELEMENTS_POLICY);\n\n/**\n * The [UsedLocalElements] of a [LibrarySpecificUnit].\n */\nfinal ResultDescriptor<UsedLocalElements> USED_LOCAL_ELEMENTS =\n    new ResultDescriptor<UsedLocalElements>('USED_LOCAL_ELEMENTS', null,\n        cachingPolicy: USED_LOCAL_ELEMENTS_POLICY);\n\n/**\n * The errors produced while resolving variable references in a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> VARIABLE_REFERENCE_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'VARIABLE_REFERENCE_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * The errors produced while verifying a compilation unit.\n *\n * The list will be empty if there were no errors, but will not be `null`.\n *\n * The result is only available for [LibrarySpecificUnit]s.\n */\nfinal ListResultDescriptor<AnalysisError> VERIFY_ERRORS =\n    new ListResultDescriptor<AnalysisError>(\n        'VERIFY_ERRORS', AnalysisError.NO_ERRORS);\n\n/**\n * Return a list of unique errors for the [Source] of the given [target].\n */\nList<AnalysisError> getTargetSourceErrors(\n    RecordingErrorListener listener, AnalysisTarget target) {\n  Source source = target.source;\n  List<AnalysisError> errors = listener.getErrorsForSource(source);\n  return getUniqueErrors(errors);\n}\n\n/**\n * Return a list of errors containing the errors from the given [errors] list\n * but with duplications removed.\n */\nList<AnalysisError> getUniqueErrors(List<AnalysisError> errors) {\n  if (errors.isEmpty) {\n    return errors;\n  }\n  return errors.toSet().toList();\n}\n\n/**\n * A task that builds a compilation unit element for a single compilation unit.\n */\nclass BuildCompilationUnitElementTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the AST for the compilation unit.\n   */\n  static const String PARSED_UNIT_INPUT_NAME = 'PARSED_UNIT_INPUT_NAME';\n\n  /**\n   * The name of the input whose value is the source line info.\n   */\n  static const String LINE_INFO_INPUT_NAME = 'LINE_INFO_INPUT_NAME';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildCompilationUnitElementTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    COMPILATION_UNIT_CONSTANTS,\n    COMPILATION_UNIT_ELEMENT,\n    CREATED_RESOLVED_UNIT1,\n    RESOLVED_UNIT1\n  ]);\n\n  /**\n   * Initialize a newly created task to build a compilation unit element for\n   * the given [target] in the given [context].\n   */\n  BuildCompilationUnitElementTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibrarySpecificUnit librarySpecificUnit = target;\n    Source source = getRequiredSource();\n    CompilationUnit unit = getRequiredInput(PARSED_UNIT_INPUT_NAME);\n    LineInfo lineInfo = getRequiredInput(LINE_INFO_INPUT_NAME);\n    //\n    // Try to get the existing CompilationUnitElement.\n    //\n    CompilationUnitElement element;\n    {\n      InternalAnalysisContext internalContext =\n          context as InternalAnalysisContext;\n      AnalysisCache analysisCache = internalContext.analysisCache;\n      CacheEntry cacheEntry = internalContext.getCacheEntry(target);\n      element = analysisCache.getValue(target, COMPILATION_UNIT_ELEMENT);\n      if (element == null &&\n          internalContext.aboutToComputeResult(\n              cacheEntry, COMPILATION_UNIT_ELEMENT)) {\n        element = analysisCache.getValue(target, COMPILATION_UNIT_ELEMENT);\n      }\n    }\n    //\n    // Build or reuse CompilationUnitElement.\n    //\n    if (element == null) {\n      CompilationUnitBuilder builder = new CompilationUnitBuilder();\n      element = builder.buildCompilationUnit(\n          source, unit, librarySpecificUnit.library);\n      (element as CompilationUnitElementImpl).lineInfo = lineInfo;\n    } else {\n      new DeclarationResolver().resolve(unit, element);\n    }\n    //\n    // Prepare constants.\n    //\n    ConstantFinder constantFinder = new ConstantFinder();\n    unit.accept(constantFinder);\n    List<ConstantEvaluationTarget> constants =\n        constantFinder.constantsToCompute;\n    //\n    // Record outputs.\n    //\n    outputs[COMPILATION_UNIT_CONSTANTS] = constants;\n    outputs[COMPILATION_UNIT_ELEMENT] = element;\n    outputs[RESOLVED_UNIT1] = unit;\n    outputs[CREATED_RESOLVED_UNIT1] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      PARSED_UNIT_INPUT_NAME: PARSED_UNIT.of(unit.unit, flushOnAccess: true),\n      LINE_INFO_INPUT_NAME: LINE_INFO.of(unit.unit)\n    };\n  }\n\n  /**\n   * Create a [BuildCompilationUnitElementTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildCompilationUnitElementTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildCompilationUnitElementTask(context, target);\n  }\n}\n\n/**\n * A task that builds imports and export directive elements for a library.\n */\nclass BuildDirectiveElementsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [LIBRARY_ELEMENT1].\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the input for [RESOLVED_UNIT1] of a library unit.\n   */\n  static const String UNIT_INPUT_NAME = 'UNIT_INPUT_NAME';\n\n  /**\n   * The input with a map from referenced sources to their modification times.\n   */\n  static const String SOURCES_MODIFICATION_TIME_INPUT_NAME =\n      'SOURCES_MODIFICATION_TIME_INPUT_NAME';\n\n  /**\n   * The input with a list of [LIBRARY_ELEMENT3]s of imported libraries.\n   */\n  static const String IMPORTS_LIBRARY_ELEMENT_INPUT_NAME =\n      'IMPORTS_LIBRARY_ELEMENT1_INPUT_NAME';\n\n  /**\n   * The input with a list of [LIBRARY_ELEMENT3]s of exported libraries.\n   */\n  static const String EXPORTS_LIBRARY_ELEMENT_INPUT_NAME =\n      'EXPORTS_LIBRARY_ELEMENT_INPUT_NAME';\n\n  /**\n   * The input with a list of [SOURCE_KIND]s of imported libraries.\n   */\n  static const String IMPORTS_SOURCE_KIND_INPUT_NAME =\n      'IMPORTS_SOURCE_KIND_INPUT_NAME';\n\n  /**\n   * The input with a list of [SOURCE_KIND]s of exported libraries.\n   */\n  static const String EXPORTS_SOURCE_KIND_INPUT_NAME =\n      'EXPORTS_SOURCE_KIND_INPUT_NAME';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildDirectiveElementsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT2, BUILD_DIRECTIVES_ERRORS]);\n\n  BuildDirectiveElementsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElementImpl libraryElement = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit libraryUnit = getRequiredInput(UNIT_INPUT_NAME);\n    Map<Source, int> sourceModificationTimeMap =\n        getRequiredInput(SOURCES_MODIFICATION_TIME_INPUT_NAME);\n    Map<Source, LibraryElement> importLibraryMap =\n        getRequiredInput(IMPORTS_LIBRARY_ELEMENT_INPUT_NAME);\n    Map<Source, LibraryElement> exportLibraryMap =\n        getRequiredInput(EXPORTS_LIBRARY_ELEMENT_INPUT_NAME);\n    Map<Source, SourceKind> importSourceKindMap =\n        getRequiredInput(IMPORTS_SOURCE_KIND_INPUT_NAME);\n    Map<Source, SourceKind> exportSourceKindMap =\n        getRequiredInput(EXPORTS_SOURCE_KIND_INPUT_NAME);\n    //\n    // Try to get the existing LibraryElement.\n    //\n    LibraryElement element;\n    {\n      InternalAnalysisContext internalContext =\n          context as InternalAnalysisContext;\n      AnalysisCache analysisCache = internalContext.analysisCache;\n      CacheEntry cacheEntry = internalContext.getCacheEntry(target);\n      element = analysisCache.getValue(target, LIBRARY_ELEMENT2);\n      if (element == null &&\n          internalContext.aboutToComputeResult(cacheEntry, LIBRARY_ELEMENT2)) {\n        element = analysisCache.getValue(target, LIBRARY_ELEMENT2);\n      }\n    }\n    //\n    // Build or reuse the directive elements.\n    //\n    List<AnalysisError> errors;\n    if (element == null) {\n      DirectiveElementBuilder builder = new DirectiveElementBuilder(\n          context,\n          libraryElement,\n          sourceModificationTimeMap,\n          importLibraryMap,\n          importSourceKindMap,\n          exportLibraryMap,\n          exportSourceKindMap);\n      libraryUnit.accept(builder);\n      // See the commentary in the computation of the LIBRARY_CYCLE result\n      // for details on library cycle invalidation.\n      libraryElement.invalidateLibraryCycles();\n      errors = builder.errors;\n    } else {\n      DirectiveResolver resolver = new DirectiveResolver(\n          sourceModificationTimeMap, importSourceKindMap, exportSourceKindMap);\n      libraryUnit.accept(resolver);\n      errors = resolver.errors;\n    }\n    //\n    // Record outputs.\n    //\n    outputs[LIBRARY_ELEMENT2] = libraryElement;\n    outputs[BUILD_DIRECTIVES_ERRORS] = errors;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given library [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT1.of(source),\n      UNIT_INPUT_NAME:\n          RESOLVED_UNIT1.of(new LibrarySpecificUnit(source, source)),\n      SOURCES_MODIFICATION_TIME_INPUT_NAME:\n          REFERENCED_SOURCES.of(source).toMapOf(MODIFICATION_TIME),\n      IMPORTS_LIBRARY_ELEMENT_INPUT_NAME:\n          IMPORTED_LIBRARIES.of(source).toMapOf(LIBRARY_ELEMENT1),\n      EXPORTS_LIBRARY_ELEMENT_INPUT_NAME:\n          EXPORTED_LIBRARIES.of(source).toMapOf(LIBRARY_ELEMENT1),\n      IMPORTS_SOURCE_KIND_INPUT_NAME:\n          IMPORTED_LIBRARIES.of(source).toMapOf(SOURCE_KIND),\n      EXPORTS_SOURCE_KIND_INPUT_NAME:\n          EXPORTED_LIBRARIES.of(source).toMapOf(SOURCE_KIND)\n    };\n  }\n\n  /**\n   * Create a [BuildDirectiveElementsTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildDirectiveElementsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildDirectiveElementsTask(context, target);\n  }\n}\n\n/**\n * A task that builds the elements representing the members of enum\n * declarations.\n */\nclass BuildEnumMemberElementsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT1] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildEnumMemberElementsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CREATED_RESOLVED_UNIT3, RESOLVED_UNIT3]);\n\n  BuildEnumMemberElementsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    //\n    // Build the enum members if they have not already been created.\n    //\n    EnumDeclaration findFirstEnum() {\n      NodeList<CompilationUnitMember> members = unit.declarations;\n      int length = members.length;\n      for (int i = 0; i < length; i++) {\n        CompilationUnitMember member = members[i];\n        if (member is EnumDeclaration) {\n          return member;\n        }\n      }\n      return null;\n    }\n\n    EnumDeclaration firstEnum = findFirstEnum();\n    if (firstEnum != null &&\n        resolutionMap\n            .elementDeclaredByEnumDeclaration(firstEnum)\n            .accessors\n            .isEmpty) {\n      EnumMemberBuilder builder = new EnumMemberBuilder(typeProvider);\n      unit.accept(builder);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[CREATED_RESOLVED_UNIT3] = true;\n    outputs[RESOLVED_UNIT3] = unit;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      UNIT_INPUT: RESOLVED_UNIT2.of(unit)\n    };\n  }\n\n  /**\n   * Create a [BuildEnumMemberElementsTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildEnumMemberElementsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildEnumMemberElementsTask(context, target);\n  }\n}\n\n/**\n * A task that builds [EXPORT_NAMESPACE] and [LIBRARY_ELEMENT4] for a library.\n */\nclass BuildExportNamespaceTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input for [LIBRARY_ELEMENT3] of a library.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildExportNamespaceTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT4]);\n\n  BuildExportNamespaceTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElementImpl library = getRequiredInput(LIBRARY_INPUT);\n    //\n    // Compute export namespace.\n    //\n    library.exportNamespace = null;\n    NamespaceBuilder builder = new NamespaceBuilder();\n    Namespace namespace = builder.createExportNamespaceForLibrary(library);\n    library.exportNamespace = namespace;\n    //\n    // Update entry point.\n    //\n    if (library.entryPoint == null) {\n      Iterable<Element> exportedElements = namespace.definedNames.values;\n      library.entryPoint = exportedElements.firstWhere(\n          (element) => element is FunctionElement && element.isEntryPoint,\n          orElse: () => null);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[LIBRARY_ELEMENT4] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given library [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT3.of(source),\n      'exportsLibraryPublicNamespace':\n          EXPORT_SOURCE_CLOSURE.of(source).toMapOf(LIBRARY_ELEMENT3)\n    };\n  }\n\n  /**\n   * Create a [BuildExportNamespaceTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildExportNamespaceTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildExportNamespaceTask(context, target);\n  }\n}\n\n/**\n * A task that builds a library element for a Dart library.\n */\nclass BuildLibraryElementTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [RESOLVED_UNIT1].\n   */\n  static const String DEFINING_UNIT_INPUT = 'DEFINING_UNIT_INPUT';\n\n  /**\n   * The name of the input whose value is a list of built [RESOLVED_UNIT1]s\n   * of the parts sourced by a library.\n   */\n  static const String PARTS_UNIT_INPUT = 'PARTS_UNIT_INPUT';\n\n  /**\n   * The name of the input whose value is the modification time of the source.\n   */\n  static const String MODIFICATION_TIME_INPUT = 'MODIFICATION_TIME_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildLibraryElementTask', createTask, buildInputs, <ResultDescriptor>[\n    BUILD_LIBRARY_ERRORS,\n    LIBRARY_ELEMENT1,\n    IS_LAUNCHABLE\n  ]);\n\n  /**\n   * The constant used as an unknown common library name in parts.\n   */\n  static const String _UNKNOWN_LIBRARY_NAME = 'unknown-library-name';\n\n  /**\n   * Initialize a newly created task to build a library element for the given\n   * [target] in the given [context].\n   */\n  BuildLibraryElementTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    List<AnalysisError> errors = <AnalysisError>[];\n    //\n    // Prepare inputs.\n    //\n    Source librarySource = getRequiredSource();\n    CompilationUnit definingCompilationUnit =\n        getRequiredInput(DEFINING_UNIT_INPUT);\n    List<CompilationUnit> partUnits = getRequiredInput(PARTS_UNIT_INPUT);\n    int modificationTime = getRequiredInput(MODIFICATION_TIME_INPUT);\n    //\n    // Process inputs.\n    //\n    CompilationUnitElementImpl definingCompilationUnitElement =\n        definingCompilationUnit.element;\n    Map<Source, CompilationUnit> partUnitMap =\n        new HashMap<Source, CompilationUnit>();\n    int partLength = partUnits.length;\n    for (int i = 0; i < partLength; i++) {\n      CompilationUnit partUnit = partUnits[i];\n      Source partSource =\n          resolutionMap.elementDeclaredByCompilationUnit(partUnit).source;\n      partUnitMap[partSource] = partUnit;\n    }\n    //\n    // Update \"part\" directives.\n    //\n    LibraryIdentifier libraryNameNode = null;\n    String partsLibraryName = _UNKNOWN_LIBRARY_NAME;\n    Set<Source> seenPartSources = new Set<Source>();\n    FunctionElement entryPoint =\n        _findEntryPoint(definingCompilationUnitElement);\n    List<Directive> directivesToResolve = <Directive>[];\n    List<CompilationUnitElementImpl> sourcedCompilationUnits =\n        <CompilationUnitElementImpl>[];\n    NodeList<Directive> directives = definingCompilationUnit.directives;\n    int directiveLength = directives.length;\n    for (int i = 0; i < directiveLength; i++) {\n      Directive directive = directives[i];\n      if (directive is LibraryDirective) {\n        libraryNameNode = directive.name;\n        directivesToResolve.add(directive);\n      } else if (directive is PartDirective) {\n        StringLiteral partUri = directive.uri;\n        Source partSource = directive.uriSource;\n        CompilationUnit partUnit = partUnitMap[partSource];\n        if (partUnit != null) {\n          CompilationUnitElementImpl partElement = partUnit.element;\n          partElement.uriOffset = partUri.offset;\n          partElement.uriEnd = partUri.end;\n          partElement.uri = directive.uriContent;\n          //\n          // Validate that the part source is unique in the library.\n          //\n          if (!seenPartSources.add(partSource)) {\n            errors.add(new AnalysisError(\n                librarySource,\n                partUri.offset,\n                partUri.length,\n                CompileTimeErrorCode.DUPLICATE_PART,\n                [partSource.uri]));\n          }\n          //\n          // Validate that the part contains a part-of directive with the same\n          // name as the library.\n          //\n          if (context.exists(partSource)) {\n            _NameOrSource nameOrSource = _getPartLibraryNameOrUri(\n                context, partSource, partUnit, directivesToResolve);\n            if (nameOrSource == null) {\n              errors.add(new AnalysisError(\n                  librarySource,\n                  partUri.offset,\n                  partUri.length,\n                  CompileTimeErrorCode.PART_OF_NON_PART,\n                  [partUri.toSource()]));\n            } else {\n              String name = nameOrSource.name;\n              if (name != null) {\n                if (libraryNameNode == null) {\n                  if (partsLibraryName == _UNKNOWN_LIBRARY_NAME) {\n                    partsLibraryName = name;\n                  } else if (partsLibraryName != name) {\n                    partsLibraryName = null;\n                  }\n                } else if (libraryNameNode.name != name) {\n                  errors.add(new AnalysisError(\n                      librarySource,\n                      partUri.offset,\n                      partUri.length,\n                      StaticWarningCode.PART_OF_DIFFERENT_LIBRARY,\n                      [libraryNameNode.name, name]));\n                }\n              } else {\n                Source source = nameOrSource.source;\n                if (source != librarySource) {\n                  errors.add(new AnalysisError(\n                      librarySource,\n                      partUri.offset,\n                      partUri.length,\n                      StaticWarningCode.PART_OF_DIFFERENT_LIBRARY,\n                      [librarySource.uri.toString(), source.uri.toString()]));\n                }\n              }\n            }\n          }\n          if (entryPoint == null) {\n            entryPoint = _findEntryPoint(partElement);\n          }\n          directive.element = partElement;\n          sourcedCompilationUnits.add(partElement);\n        }\n      }\n    }\n    // TODO(brianwilkerson) Report the error\n    // ResolverErrorCode.MISSING_LIBRARY_DIRECTIVE_WITH_PART\n    //\n    // Create and populate the library element.\n    //\n    AnalysisContext owningContext = context;\n    if (context is InternalAnalysisContext) {\n      InternalAnalysisContext internalContext = context;\n      owningContext = internalContext.getContextFor(librarySource);\n    }\n    //\n    // Try to get the existing LibraryElement.\n    //\n    LibraryElementImpl libraryElement;\n    {\n      InternalAnalysisContext internalContext =\n          context as InternalAnalysisContext;\n      AnalysisCache analysisCache = internalContext.analysisCache;\n      CacheEntry cacheEntry = internalContext.getCacheEntry(target);\n      libraryElement = analysisCache.getValue(target, LIBRARY_ELEMENT1)\n          as LibraryElementImpl;\n      if (libraryElement == null &&\n          internalContext.aboutToComputeResult(cacheEntry, LIBRARY_ELEMENT1)) {\n        libraryElement = analysisCache.getValue(target, LIBRARY_ELEMENT1)\n            as LibraryElementImpl;\n      }\n    }\n    //\n    // Create a new LibraryElement.\n    //\n    if (libraryElement == null) {\n      libraryElement =\n          new LibraryElementImpl.forNode(owningContext, libraryNameNode);\n      libraryElement.isSynthetic = modificationTime < 0;\n      libraryElement.definingCompilationUnit = definingCompilationUnitElement;\n      libraryElement.entryPoint = entryPoint;\n      libraryElement.parts = sourcedCompilationUnits;\n      libraryElement.hasExtUri = _hasExtUri(definingCompilationUnit);\n      BuildLibraryElementUtils.patchTopLevelAccessors(libraryElement);\n      // set the library documentation to the docs associated with the first\n      // directive in the compilation unit.\n      if (definingCompilationUnit.directives.isNotEmpty) {\n        setElementDocumentationComment(\n            libraryElement, definingCompilationUnit.directives.first);\n      }\n    }\n    //\n    // Resolve the relevant directives to the library element.\n    //\n    // TODO(brianwilkerson) This updates the state of the AST structures but\n    // does not associate a new result with it.\n    //\n    int length = directivesToResolve.length;\n    for (int i = 0; i < length; i++) {\n      Directive directive = directivesToResolve[i];\n      directive.element = libraryElement;\n    }\n    //\n    // Record outputs.\n    //\n    outputs[BUILD_LIBRARY_ERRORS] = errors;\n    outputs[LIBRARY_ELEMENT1] = libraryElement;\n    outputs[IS_LAUNCHABLE] = entryPoint != null;\n  }\n\n  /**\n   * Return the top-level [FunctionElement] entry point, or `null` if the given\n   * [element] does not define an entry point.\n   */\n  FunctionElement _findEntryPoint(CompilationUnitElementImpl element) {\n    List<FunctionElement> functions = element.functions;\n    int length = functions.length;\n    for (int i = 0; i < length; i++) {\n      FunctionElement function = functions[i];\n      if (function.isEntryPoint) {\n        return function;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the name of the library that the given part is declared to be a\n   * part of, or `null` if the part does not contain a part-of directive.\n   */\n  _NameOrSource _getPartLibraryNameOrUri(\n      AnalysisContext context,\n      Source partSource,\n      CompilationUnit partUnit,\n      List<Directive> directivesToResolve) {\n    NodeList<Directive> directives = partUnit.directives;\n    int length = directives.length;\n    for (int i = 0; i < length; i++) {\n      Directive directive = directives[i];\n      if (directive is PartOfDirective) {\n        directivesToResolve.add(directive);\n        LibraryIdentifier libraryName = directive.libraryName;\n        if (libraryName != null) {\n          return new _NameOrSource(libraryName.name, null);\n        }\n        String uri = directive.uri?.stringValue;\n        if (uri != null) {\n          Source librarySource =\n              context.sourceFactory.resolveUri(partSource, uri);\n          if (librarySource != null) {\n            return new _NameOrSource(null, librarySource);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return `true` if the given compilation [unit] contains at least one\n   * import directive with a `dart-ext:` URI.\n   */\n  bool _hasExtUri(CompilationUnit unit) {\n    NodeList<Directive> directives = unit.directives;\n    int length = directives.length;\n    for (int i = 0; i < length; i++) {\n      Directive directive = directives[i];\n      if (directive is ImportDirective) {\n        if (DartUriResolver.isDartExtUri(directive.uriContent)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      DEFINING_UNIT_INPUT:\n          RESOLVED_UNIT1.of(new LibrarySpecificUnit(source, source)),\n      PARTS_UNIT_INPUT: INCLUDED_PARTS.of(source).toList((Source unit) {\n        return RESOLVED_UNIT1.of(new LibrarySpecificUnit(source, unit));\n      }),\n      MODIFICATION_TIME_INPUT: MODIFICATION_TIME.of(source)\n    };\n  }\n\n  /**\n   * Create a [BuildLibraryElementTask] based on the given [target] in the\n   * given [context].\n   */\n  static BuildLibraryElementTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildLibraryElementTask(context, target);\n  }\n}\n\n/**\n * A task that builds [PUBLIC_NAMESPACE] for a library.\n */\nclass BuildPublicNamespaceTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input for [LIBRARY_ELEMENT2] of a library.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildPublicNamespaceTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT3]);\n\n  BuildPublicNamespaceTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElementImpl library = getRequiredInput(LIBRARY_INPUT);\n    NamespaceBuilder builder = new NamespaceBuilder();\n    library.publicNamespace = builder.createPublicNamespaceForLibrary(library);\n    outputs[LIBRARY_ELEMENT3] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given library [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{LIBRARY_INPUT: LIBRARY_ELEMENT2.of(source)};\n  }\n\n  /**\n   * Create a [BuildPublicNamespaceTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildPublicNamespaceTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildPublicNamespaceTask(context, target);\n  }\n}\n\n/**\n * A task that builds [EXPORT_SOURCE_CLOSURE] of a library.\n */\nclass BuildSourceExportClosureTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the export closure.\n   */\n  static const String EXPORT_INPUT = 'EXPORT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildSourceExportClosureTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[EXPORT_SOURCE_CLOSURE]);\n\n  BuildSourceExportClosureTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    List<Source> exportClosure = getRequiredInput(EXPORT_INPUT);\n    //\n    // Record output.\n    //\n    outputs[EXPORT_SOURCE_CLOSURE] = exportClosure;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given library [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      EXPORT_INPUT: new _ExportSourceClosureTaskInput(source, LIBRARY_ELEMENT2)\n    };\n  }\n\n  /**\n   * Create a [BuildSourceExportClosureTask] based on the given [target] in\n   * the given [context].\n   */\n  static BuildSourceExportClosureTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildSourceExportClosureTask(context, target);\n  }\n}\n\n/**\n * A task that builds [TYPE_PROVIDER] for a context.\n */\nclass BuildTypeProviderTask extends SourceBasedAnalysisTask {\n  /**\n   * The [PUBLIC_NAMESPACE] input of the `dart:core` library.\n   */\n  static const String CORE_INPUT = 'CORE_INPUT';\n\n  /**\n   * The [PUBLIC_NAMESPACE] input of the `dart:async` library.\n   */\n  static const String ASYNC_INPUT = 'ASYNC_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'BuildTypeProviderTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[TYPE_PROVIDER]);\n\n  BuildTypeProviderTask(\n      InternalAnalysisContext context, AnalysisContextTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElement coreLibrary = getRequiredInput(CORE_INPUT);\n    LibraryElement asyncLibrary = getOptionalInput(ASYNC_INPUT);\n    Namespace coreNamespace = coreLibrary.publicNamespace;\n    Namespace asyncNamespace = asyncLibrary.publicNamespace;\n    //\n    // Record outputs.\n    //\n    TypeProvider typeProvider =\n        new TypeProviderImpl.forNamespaces(coreNamespace, asyncNamespace);\n    (context as InternalAnalysisContext).typeProvider = typeProvider;\n    outputs[TYPE_PROVIDER] = typeProvider;\n  }\n\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    AnalysisContextTarget contextTarget = target;\n    SourceFactory sourceFactory = contextTarget.context.sourceFactory;\n    Source coreSource = sourceFactory.forUri(DartSdk.DART_CORE);\n    Source asyncSource = sourceFactory.forUri(DartSdk.DART_ASYNC);\n    if (asyncSource == null) {\n      return <String, TaskInput>{CORE_INPUT: LIBRARY_ELEMENT3.of(coreSource)};\n    }\n    return <String, TaskInput>{\n      CORE_INPUT: LIBRARY_ELEMENT3.of(coreSource),\n      ASYNC_INPUT: LIBRARY_ELEMENT3.of(asyncSource)\n    };\n  }\n\n  /**\n   * Create a [BuildTypeProviderTask] based on the given [context].\n   */\n  static BuildTypeProviderTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new BuildTypeProviderTask(context, target);\n  }\n}\n\n/**\n * A task that computes [CONSTANT_DEPENDENCIES] for a constant.\n */\nclass ComputeConstantDependenciesTask extends ConstantEvaluationAnalysisTask {\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ComputeConstantDependenciesTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CONSTANT_DEPENDENCIES]);\n\n  ComputeConstantDependenciesTask(\n      InternalAnalysisContext context, ConstantEvaluationTarget constant)\n      : super(context, constant);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    ConstantEvaluationTarget constant = target;\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Compute dependencies.\n    //\n    List<ConstantEvaluationTarget> dependencies = <ConstantEvaluationTarget>[];\n    new ConstantEvaluationEngine(typeProvider, context.declaredVariables,\n            typeSystem: context.typeSystem)\n        .computeDependencies(constant, dependencies.add);\n    //\n    // Record outputs.\n    //\n    outputs[CONSTANT_DEPENDENCIES] = dependencies;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    return <String, TaskInput>{\n      'constantExpressionResolved': CONSTANT_EXPRESSION_RESOLVED.of(target),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [ComputeConstantDependenciesTask] based on the given [target] in\n   * the given [context].\n   */\n  static ComputeConstantDependenciesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ComputeConstantDependenciesTask(context, target);\n  }\n}\n\n/**\n * A task that computes the value of a constant ([CONSTANT_VALUE]) and\n * stores it in the element model.\n */\nclass ComputeConstantValueTask extends ConstantEvaluationAnalysisTask {\n  /**\n   * The name of the input which ensures that dependent constants are evaluated\n   * before the target.\n   */\n  static const String DEPENDENCIES_INPUT = 'DEPENDENCIES_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ComputeConstantValueTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CONSTANT_VALUE]);\n\n  ComputeConstantValueTask(\n      InternalAnalysisContext context, ConstantEvaluationTarget constant)\n      : super(context, constant);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    // Note: DEPENDENCIES_INPUT is not needed.  It is merely a bookkeeping\n    // dependency to ensure that the constants that this constant depends on\n    // are computed first.\n    ConstantEvaluationTarget constant = target;\n    AnalysisContext context = constant.context;\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Compute the value of the constant, or report an error if there was a\n    // cycle.\n    //\n    ConstantEvaluationEngine constantEvaluationEngine =\n        new ConstantEvaluationEngine(typeProvider, context.declaredVariables,\n            typeSystem: context.typeSystem);\n    if (dependencyCycle == null) {\n      constantEvaluationEngine.computeConstantValue(constant);\n    } else {\n      List<ConstantEvaluationTarget> constantsInCycle =\n          <ConstantEvaluationTarget>[];\n      int length = dependencyCycle.length;\n      for (int i = 0; i < length; i++) {\n        WorkItem workItem = dependencyCycle[i];\n        if (workItem.descriptor == DESCRIPTOR) {\n          AnalysisTarget target = workItem.target;\n          constantsInCycle.add(target);\n          if (target is ConstructorElementImpl) {\n            target.isCycleFree = false;\n          }\n        }\n      }\n      assert(constantsInCycle.isNotEmpty);\n      constantEvaluationEngine.generateCycleError(constantsInCycle, constant);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[CONSTANT_VALUE] = constant;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    ConstantEvaluationTarget evaluationTarget = target;\n    return <String, TaskInput>{\n      DEPENDENCIES_INPUT:\n          CONSTANT_DEPENDENCIES.of(evaluationTarget).toListOf(CONSTANT_VALUE),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [ComputeConstantValueTask] based on the given [target] in the\n   * given [context].\n   */\n  static ComputeConstantValueTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ComputeConstantValueTask(context, target);\n  }\n}\n\n/**\n * A task that computes the [INFERABLE_STATIC_VARIABLE_DEPENDENCIES] for a\n * static variable whose type should be inferred.\n */\nclass ComputeInferableStaticVariableDependenciesTask\n    extends InferStaticVariableTask {\n  /**\n   * The name of the [RESOLVED_UNIT7] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ComputeInferableStaticVariableDependenciesTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[INFERABLE_STATIC_VARIABLE_DEPENDENCIES]);\n\n  ComputeInferableStaticVariableDependenciesTask(\n      InternalAnalysisContext context, VariableElement variable)\n      : super(context, variable);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    //\n    // Compute dependencies.\n    //\n    VariableDeclaration declaration = getDeclaration(unit);\n    VariableGatherer gatherer = new VariableGatherer(_isInferableStatic);\n    declaration.initializer.accept(gatherer);\n    //\n    // Record outputs.\n    //\n    outputs[INFERABLE_STATIC_VARIABLE_DEPENDENCIES] = gatherer.results.toList();\n  }\n\n  /**\n   * Return `true` if the given [variable] is a static variable whose type\n   * should be inferred.\n   */\n  bool _isInferableStatic(VariableElement variable) =>\n      variable.isStatic &&\n      variable.hasImplicitType &&\n      variable.initializer != null;\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    if (target is VariableElement) {\n      CompilationUnitElementImpl unit = target\n          .getAncestor((Element element) => element is CompilationUnitElement);\n      return <String, TaskInput>{\n        UNIT_INPUT: RESOLVED_UNIT7\n            .of(new LibrarySpecificUnit(unit.librarySource, unit.source))\n      };\n    }\n    throw new AnalysisException(\n        'Cannot build inputs for a ${target.runtimeType}');\n  }\n\n  /**\n   * Create a [ComputeInferableStaticVariableDependenciesTask] based on the\n   * given [target] in the given [context].\n   */\n  static ComputeInferableStaticVariableDependenciesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ComputeInferableStaticVariableDependenciesTask(context, target);\n  }\n}\n\n/**\n * A task that computes the [LIBRARY_CYCLE] for a\n * library element.  Also computes the [LIBRARY_CYCLE_UNITS] and the\n * [LIBRARY_CYCLE_DEPENDENCIES].\n */\nclass ComputeLibraryCycleTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT2] input.\n   */\n  static const String LIBRARY_ELEMENT_INPUT = 'LIBRARY_ELEMENT_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ComputeLibraryCycleForUnitTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    LIBRARY_CYCLE,\n    LIBRARY_CYCLE_UNITS,\n    LIBRARY_CYCLE_DEPENDENCIES\n  ]);\n\n  ComputeLibraryCycleTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    // The computation of library cycles is necessarily non-local, since we\n    // in general have to look at all of the reachable libraries\n    // in order to find the strongly connected components.  Repeating this\n    // computation for every node would be quadratic.  The libraryCycle getter\n    // will avoid this by computing the library cycles for every reachable\n    // library and recording it in the element model.  This means that this\n    // task implicitly produces the output for many other targets.  This\n    // can't be expressed in the task model right now: instead, we just\n    // run tasks for those other targets, and they pick up the recorded\n    // version off of the element model.  Unfortunately, this means that\n    // the task model will not handle the invalidation of the recorded\n    // results for us.  Instead, we must explicitly invalidate the recorded\n    // library cycle information when we add or subtract edges from the\n    // import/export graph.  Any update that changes the\n    // import/export graph will induce a recomputation of the LIBRARY_ELEMENT2\n    // result for the changed node. This recomputation is responsible for\n    // conservatively invalidating the library cycle information recorded\n    // in the element model.  The LIBRARY_CYCLE results that have been cached\n    // by the task model are conservatively invalidated by the\n    // IMPORT_EXPORT_SOURCE_CLOSURE dependency below.  If anything reachable\n    // from a node is changed, its LIBRARY_CYCLE results will be re-computed\n    // here (possibly re-using the result from the element model if invalidation\n    // did not cause it to be erased).  In summary, task model dependencies\n    // on the import/export source closure ensure that this method will be\n    // re-run if anything reachable from this target has been invalidated,\n    // and the invalidation code (invalidateLibraryCycles) will ensure that\n    // element model results will be re-used here only if they are still valid.\n    LibraryElement library = getRequiredInput(LIBRARY_ELEMENT_INPUT);\n    if (context.analysisOptions.strongMode &&\n        !LibraryElementImpl.hasResolutionCapability(\n            library, LibraryResolutionCapability.resolvedTypeNames)) {\n      List<LibraryElement> component = library.libraryCycle;\n      Set<LibraryElement> filter = component.toSet();\n      Set<CompilationUnitElement> deps = new Set<CompilationUnitElement>();\n      void addLibrary(LibraryElement l) {\n        if (!filter.contains(l)) {\n          deps.addAll(l.units);\n        }\n      }\n\n      int length = component.length;\n      for (int i = 0; i < length; i++) {\n        LibraryElement library = component[i];\n        library.importedLibraries.forEach(addLibrary);\n        library.exportedLibraries.forEach(addLibrary);\n      }\n      //\n      // Record outputs.\n      //\n      LibrarySpecificUnit unitToLSU(CompilationUnitElement unit) =>\n          new LibrarySpecificUnit(unit.librarySource, unit.source);\n      outputs[LIBRARY_CYCLE] = component;\n      outputs[LIBRARY_CYCLE_UNITS] =\n          component.expand((l) => l.units).map(unitToLSU).toList();\n      outputs[LIBRARY_CYCLE_DEPENDENCIES] = deps.map(unitToLSU).toList();\n    } else {\n      outputs[LIBRARY_CYCLE] = <LibraryElement>[];\n      outputs[LIBRARY_CYCLE_UNITS] = <LibrarySpecificUnit>[];\n      outputs[LIBRARY_CYCLE_DEPENDENCIES] = <LibrarySpecificUnit>[];\n    }\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source librarySource = target;\n    return <String, TaskInput>{\n      LIBRARY_ELEMENT_INPUT: LIBRARY_ELEMENT2.of(librarySource),\n      'resolveReachableLibraries': READY_LIBRARY_ELEMENT2.of(librarySource),\n    };\n  }\n\n  /**\n   * Create a [ComputeLibraryCycleTask] based on the\n   * given [target] in the given [context].\n   */\n  static ComputeLibraryCycleTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ComputeLibraryCycleTask(context, target);\n  }\n}\n\n/**\n * A task that builds [REQUIRED_CONSTANTS] for a unit.\n */\nclass ComputeRequiredConstantsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ComputeRequiredConstantsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[PENDING_ERRORS, REQUIRED_CONSTANTS]);\n\n  ComputeRequiredConstantsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    Source source = getRequiredSource();\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    //\n    // Use the ErrorVerifier to compute errors.\n    //\n    RequiredConstantsComputer computer = new RequiredConstantsComputer(source);\n    unit.accept(computer);\n    List<PendingError> pendingErrors = computer.pendingErrors;\n    List<ConstantEvaluationTarget> requiredConstants =\n        computer.requiredConstants;\n    //\n    // Record outputs.\n    //\n    outputs[PENDING_ERRORS] = pendingErrors;\n    outputs[REQUIRED_CONSTANTS] = requiredConstants;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{UNIT_INPUT: RESOLVED_UNIT.of(unit)};\n  }\n\n  /**\n   * Create a [ComputeRequiredConstantsTask] based on the given [target] in\n   * the given [context].\n   */\n  static ComputeRequiredConstantsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ComputeRequiredConstantsTask(context, target);\n  }\n}\n\n/**\n * A base class for analysis tasks whose target is expected to be a\n * [ConstantEvaluationTarget].\n */\nabstract class ConstantEvaluationAnalysisTask extends AnalysisTask {\n  /**\n   * Initialize a newly created task to perform analysis within the given\n   * [context] in order to produce results for the given [constant].\n   */\n  ConstantEvaluationAnalysisTask(\n      AnalysisContext context, ConstantEvaluationTarget constant)\n      : super(context, constant);\n\n  @override\n  String get description {\n    Source source = target.source;\n    String sourceName = source == null ? '<unknown source>' : source.fullName;\n    return '${descriptor.name} for element $target in source $sourceName';\n  }\n}\n\n/**\n * Interface for [AnalysisTarget]s for which constant evaluation can be\n * performed.\n */\nabstract class ConstantEvaluationTarget extends AnalysisTarget {\n  /**\n   * Return the [AnalysisContext] which should be used to evaluate this\n   * constant.\n   */\n  AnalysisContext get context;\n}\n\n/**\n * A task that computes a list of the libraries containing the target source.\n */\nclass ContainingLibrariesTask extends SourceBasedAnalysisTask {\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ContainingLibrariesTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CONTAINING_LIBRARIES]);\n\n  ContainingLibrariesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    // TODO(brianwilkerson) This value can change as new libraries are analyzed\n    // so we need some way of making sure that this result is removed from the\n    // cache appropriately.\n    Source source = getRequiredSource();\n    outputs[CONTAINING_LIBRARIES] = context.getLibrariesContaining(source);\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    return <String, TaskInput>{};\n  }\n\n  /**\n   * Create a [ContainingLibrariesTask] based on the given [target] in the given\n   * [context].\n   */\n  static ContainingLibrariesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ContainingLibrariesTask(context, target);\n  }\n}\n\n/**\n * A task that merges all of the errors for a single source into a single list\n * of errors.\n */\nclass DartErrorsTask extends SourceBasedAnalysisTask {\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor('DartErrorsTask',\n      createTask, buildInputs, <ResultDescriptor>[DART_ERRORS]);\n\n  /**\n   * The name of the [IGNORE_INFO_INPUT] input.\n   */\n  static const String IGNORE_INFO_INPUT = 'IGNORE_INFO_INPUT';\n\n  /**\n   * The name of the [LINE_INFO_INPUT] input.\n   */\n  static const String LINE_INFO_INPUT = 'LINE_INFO_INPUT';\n\n  DartErrorsTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    List<List<AnalysisError>> errorLists = <List<AnalysisError>>[];\n    //\n    // Prepare inputs.\n    //\n    EnginePlugin enginePlugin = AnalysisEngine.instance.enginePlugin;\n    List<ResultDescriptor> errorsForSource = enginePlugin.dartErrorsForSource;\n    int sourceLength = errorsForSource.length;\n    for (int i = 0; i < sourceLength; i++) {\n      ResultDescriptor result = errorsForSource[i];\n      String inputName = result.name + '_input';\n      errorLists.add(getRequiredInput(inputName));\n    }\n    List<ResultDescriptor> errorsForUnit = enginePlugin.dartErrorsForUnit;\n    int unitLength = errorsForUnit.length;\n    for (int i = 0; i < unitLength; i++) {\n      ResultDescriptor result = errorsForUnit[i];\n      String inputName = result.name + '_input';\n      Map<Source, List<AnalysisError>> errorMap = getRequiredInput(inputName);\n      for (List<AnalysisError> errors in errorMap.values) {\n        errorLists.add(errors);\n      }\n    }\n\n    //\n    // Filter ignored errors.\n    //\n    List<AnalysisError> errors =\n        _filterIgnores(AnalysisError.mergeLists(errorLists));\n\n    //\n    // Record outputs.\n    //\n    outputs[DART_ERRORS] = errors;\n  }\n\n  List<AnalysisError> _filterIgnores(List<AnalysisError> errors) {\n    if (errors.isEmpty) {\n      return errors;\n    }\n\n    IgnoreInfo ignoreInfo = getRequiredInput(IGNORE_INFO_INPUT);\n    if (!ignoreInfo.hasIgnores) {\n      return errors;\n    }\n\n    LineInfo lineInfo = getRequiredInput(LINE_INFO_INPUT);\n\n    return filterIgnored(errors, ignoreInfo, lineInfo);\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    Map<String, TaskInput> inputs = <String, TaskInput>{};\n    inputs[LINE_INFO_INPUT] = LINE_INFO.of(source);\n    inputs[IGNORE_INFO_INPUT] = IGNORE_INFO.of(source);\n    EnginePlugin enginePlugin = AnalysisEngine.instance.enginePlugin;\n    // for Source\n    List<ListResultDescriptor<AnalysisError>> errorsForSource =\n        enginePlugin.dartErrorsForSource;\n    int sourceLength = errorsForSource.length;\n    for (int i = 0; i < sourceLength; i++) {\n      ListResultDescriptor<AnalysisError> result = errorsForSource[i];\n      String inputName = result.name + '_input';\n      inputs[inputName] = result.of(source);\n    }\n    // for LibrarySpecificUnit\n    List<ListResultDescriptor<AnalysisError>> errorsForUnit =\n        enginePlugin.dartErrorsForUnit;\n    int unitLength = errorsForUnit.length;\n    for (int i = 0; i < unitLength; i++) {\n      ListResultDescriptor<AnalysisError> result = errorsForUnit[i];\n      String inputName = result.name + '_input';\n      inputs[inputName] =\n          CONTAINING_LIBRARIES.of(source).toMap((Source library) {\n        LibrarySpecificUnit unit = new LibrarySpecificUnit(library, source);\n        return result.of(unit);\n      });\n    }\n    return inputs;\n  }\n\n  /**\n   * Create a [DartErrorsTask] based on the given [target] in the given\n   * [context].\n   */\n  static DartErrorsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new DartErrorsTask(context, target);\n  }\n\n  /**\n   * Return a new list with items from [errors] which are not filtered out by\n   * the [ignoreInfo].\n   */\n  static List<AnalysisError> filterIgnored(\n      List<AnalysisError> errors, IgnoreInfo ignoreInfo, LineInfo lineInfo) {\n    if (errors.isEmpty || !ignoreInfo.hasIgnores) {\n      return errors;\n    }\n\n    bool isIgnored(AnalysisError error) {\n      int errorLine = lineInfo.getLocation(error.offset).lineNumber;\n      String errorCode = error.errorCode.name.toLowerCase();\n      return ignoreInfo.ignoredAt(errorCode, errorLine);\n    }\n\n    return errors.where((AnalysisError e) => !isIgnored(e)).toList();\n  }\n}\n\n/**\n * A task that builds [RESOLVED_UNIT12] for a unit.\n */\nclass EvaluateUnitConstantsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT11] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [CONSTANT_VALUE] input.\n   */\n  static const String CONSTANT_VALUES = 'CONSTANT_VALUES';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'EvaluateUnitConstantsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CREATED_RESOLVED_UNIT12, RESOLVED_UNIT12]);\n\n  EvaluateUnitConstantsTask(AnalysisContext context, LibrarySpecificUnit target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    // No actual work needs to be performed; the task manager will ensure that\n    // all constants are evaluated before this method is called.\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    outputs[RESOLVED_UNIT12] = unit;\n    outputs[CREATED_RESOLVED_UNIT12] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      'libraryElement': LIBRARY_ELEMENT9.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT11.of(unit),\n      CONSTANT_VALUES:\n          COMPILATION_UNIT_CONSTANTS.of(unit).toListOf(CONSTANT_VALUE),\n      'constantExpressionsDependencies':\n          CONSTANT_EXPRESSIONS_DEPENDENCIES.of(unit).toListOf(CONSTANT_VALUE)\n    };\n  }\n\n  /**\n   * Create an [EvaluateUnitConstantsTask] based on the given [target] in\n   * the given [context].\n   */\n  static EvaluateUnitConstantsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new EvaluateUnitConstantsTask(context, target);\n  }\n}\n\n/**\n * A task that builds [USED_IMPORTED_ELEMENTS] for a unit.\n */\nclass GatherUsedImportedElementsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT11] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'GatherUsedImportedElementsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[USED_IMPORTED_ELEMENTS]);\n\n  GatherUsedImportedElementsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    LibraryElement libraryElement = unitElement.library;\n    //\n    // Prepare used imported elements.\n    //\n    GatherUsedImportedElementsVisitor visitor =\n        new GatherUsedImportedElementsVisitor(libraryElement);\n    unit.accept(visitor);\n    //\n    // Record outputs.\n    //\n    outputs[USED_IMPORTED_ELEMENTS] = visitor.usedElements;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{UNIT_INPUT: RESOLVED_UNIT11.of(unit)};\n  }\n\n  /**\n   * Create a [GatherUsedImportedElementsTask] based on the given [target] in\n   * the given [context].\n   */\n  static GatherUsedImportedElementsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new GatherUsedImportedElementsTask(context, target);\n  }\n}\n\n/**\n * A task that builds [USED_LOCAL_ELEMENTS] for a unit.\n */\nclass GatherUsedLocalElementsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT11] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'GatherUsedLocalElementsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[USED_LOCAL_ELEMENTS]);\n\n  GatherUsedLocalElementsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    LibraryElement libraryElement = unitElement.library;\n    //\n    // Prepare used local elements.\n    //\n    GatherUsedLocalElementsVisitor visitor =\n        new GatherUsedLocalElementsVisitor(libraryElement);\n    unit.accept(visitor);\n    //\n    // Record outputs.\n    //\n    outputs[USED_LOCAL_ELEMENTS] = visitor.usedElements;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{UNIT_INPUT: RESOLVED_UNIT11.of(unit)};\n  }\n\n  /**\n   * Create a [GatherUsedLocalElementsTask] based on the given [target] in\n   * the given [context].\n   */\n  static GatherUsedLocalElementsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new GatherUsedLocalElementsTask(context, target);\n  }\n}\n\n/**\n * A task that generates [HINTS] for a unit.\n */\nclass GenerateHintsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT11] input.\n   */\n  static const String RESOLVED_UNIT_INPUT = 'RESOLVED_UNIT';\n\n  /**\n   * The name of a list of [USED_LOCAL_ELEMENTS] for each library unit input.\n   */\n  static const String USED_LOCAL_ELEMENTS_INPUT = 'USED_LOCAL_ELEMENTS';\n\n  /**\n   * The name of a list of [USED_IMPORTED_ELEMENTS] for each library unit input.\n   */\n  static const String USED_IMPORTED_ELEMENTS_INPUT = 'USED_IMPORTED_ELEMENTS';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'GenerateHintsTask', createTask, buildInputs, <ResultDescriptor>[HINTS]);\n\n  GenerateHintsTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    AnalysisOptions analysisOptions = context.analysisOptions;\n    if (!analysisOptions.hint) {\n      outputs[HINTS] = AnalysisError.NO_ERRORS;\n      return;\n    }\n    //\n    // Prepare collectors.\n    //\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    Source source = getRequiredSource();\n    ErrorReporter errorReporter = new ErrorReporter(errorListener, source);\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(RESOLVED_UNIT_INPUT);\n    List<UsedImportedElements> usedImportedElementsList =\n        getRequiredInput(USED_IMPORTED_ELEMENTS_INPUT);\n    List<UsedLocalElements> usedLocalElementsList =\n        getRequiredInput(USED_LOCAL_ELEMENTS_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    LibraryElement libraryElement = unitElement.library;\n    TypeSystem typeSystem = context.typeSystem;\n\n    //\n    // Generate errors.\n    //\n    unit.accept(new DeadCodeVerifier(errorReporter, typeSystem: typeSystem));\n    // Verify imports.\n    {\n      ImportsVerifier verifier = new ImportsVerifier();\n      verifier.addImports(unit);\n      usedImportedElementsList.forEach(verifier.removeUsedElements);\n      verifier.generateDuplicateImportHints(errorReporter);\n      verifier.generateDuplicateShownHiddenNameHints(errorReporter);\n      verifier.generateUnusedImportHints(errorReporter);\n      verifier.generateUnusedShownNameHints(errorReporter);\n    }\n    // Unused local elements.\n    {\n      UsedLocalElements usedElements =\n          new UsedLocalElements.merge(usedLocalElementsList);\n      UnusedLocalElementsVerifier visitor =\n          new UnusedLocalElementsVerifier(errorListener, usedElements);\n      unit.accept(visitor);\n    }\n    // Dart2js analysis.\n    if (analysisOptions.dart2jsHint) {\n      unit.accept(new Dart2JSVerifier(errorReporter));\n    }\n    // Dart best practices.\n    InheritanceManager inheritanceManager = new InheritanceManager(\n        libraryElement,\n        includeAbstractFromSuperclasses: true);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n\n    unit.accept(new BestPracticesVerifier(\n        errorReporter, typeProvider, libraryElement, inheritanceManager,\n        typeSystem: typeSystem));\n    unit.accept(new OverrideVerifier(errorReporter, inheritanceManager));\n    // Find to-do comments.\n    new ToDoFinder(errorReporter).findIn(unit);\n    //\n    // Record outputs.\n    //\n    outputs[HINTS] = errorListener.errors;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    Source libSource = unit.library;\n    return <String, TaskInput>{\n      RESOLVED_UNIT_INPUT: RESOLVED_UNIT.of(unit),\n      USED_LOCAL_ELEMENTS_INPUT:\n          LIBRARY_SPECIFIC_UNITS.of(libSource).toListOf(USED_LOCAL_ELEMENTS),\n      USED_IMPORTED_ELEMENTS_INPUT:\n          LIBRARY_SPECIFIC_UNITS.of(libSource).toListOf(USED_IMPORTED_ELEMENTS),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [GenerateHintsTask] based on the given [target] in\n   * the given [context].\n   */\n  static GenerateHintsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new GenerateHintsTask(context, target);\n  }\n}\n\n/**\n * A task that generates [LINTS] for a unit.\n */\nclass GenerateLintsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT] input.\n   */\n  static const String RESOLVED_UNIT_INPUT = 'RESOLVED_UNIT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'GenerateLintsTask', createTask, buildInputs, <ResultDescriptor>[LINTS]);\n\n  GenerateLintsTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    AnalysisOptions analysisOptions = context.analysisOptions;\n    if (!analysisOptions.lint) {\n      outputs[LINTS] = AnalysisError.NO_ERRORS;\n      return;\n    }\n    //\n    // Prepare collectors.\n    //\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    Source source = getRequiredSource();\n    ErrorReporter errorReporter = new ErrorReporter(errorListener, source);\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(RESOLVED_UNIT_INPUT);\n    //\n    // Generate lints.\n    //\n    List<AstVisitor> visitors = <AstVisitor>[];\n    bool timeVisits = analysisOptions.enableTiming;\n    List<Linter> linters = getLints(context);\n    int length = linters.length;\n    for (int i = 0; i < length; i++) {\n      Linter linter = linters[i];\n      AstVisitor visitor = linter.getVisitor();\n      if (visitor != null) {\n        linter.reporter = errorReporter;\n        if (timeVisits) {\n          visitor = new TimedAstVisitor(visitor, lintRegistry.getTimer(linter));\n        }\n        visitors.add(visitor);\n      }\n    }\n    AstVisitor visitor = new ExceptionHandlingDelegatingAstVisitor(\n        visitors, ExceptionHandlingDelegatingAstVisitor.logException);\n    unit.accept(visitor);\n    //\n    // Record outputs.\n    //\n    outputs[LINTS] = errorListener.errors;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) =>\n      <String, TaskInput>{RESOLVED_UNIT_INPUT: RESOLVED_UNIT.of(target)};\n\n  /**\n   * Create a [GenerateLintsTask] based on the given [target] in\n   * the given [context].\n   */\n  static GenerateLintsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new GenerateLintsTask(context, target);\n  }\n}\n\n/**\n * Information about analysis `//ignore:` and `//ignore_for_file` comments\n * within a source file.\n */\nclass IgnoreInfo {\n  /**\n   *  Instance shared by all cases without matches.\n   */\n  static final IgnoreInfo _EMPTY_INFO = new IgnoreInfo();\n\n  /**\n   * A regular expression for matching 'ignore' comments.  Produces matches\n   * containing 2 groups.  For example:\n   *\n   *     * ['//ignore: error_code', 'error_code']\n   *\n   * Resulting codes may be in a list ('error_code_1,error_code2').\n   */\n  static final RegExp _IGNORE_MATCHER =\n      new RegExp(r'//+[ ]*ignore:(.*)$', multiLine: true);\n\n  /**\n   * A regular expression for matching 'ignore_for_file' comments.  Produces\n   * matches containing 2 groups.  For example:\n   *\n   *     * ['//ignore_for_file: error_code', 'error_code']\n   *\n   * Resulting codes may be in a list ('error_code_1,error_code2').\n   */\n  static final RegExp _IGNORE_FOR_FILE_MATCHER =\n      new RegExp(r'//[ ]*ignore_for_file:(.*)$', multiLine: true);\n\n  final Map<int, List<String>> _ignoreMap = new HashMap<int, List<String>>();\n\n  final Set<String> _ignoreForFileSet = new HashSet<String>();\n\n  /**\n   * Whether this info object defines any ignores.\n   */\n  bool get hasIgnores => ignores.isNotEmpty || _ignoreForFileSet.isNotEmpty;\n\n  /**\n   * Iterable of error codes ignored for the whole file.\n   */\n  Iterable<String> get ignoreForFiles => _ignoreForFileSet;\n\n  /**\n   * Map of line numbers to associated ignored error codes.\n   */\n  Map<int, Iterable<String>> get ignores => _ignoreMap;\n\n  /**\n   * Ignore this [errorCode] at [line].\n   */\n  void add(int line, String errorCode) {\n    _ignoreMap.putIfAbsent(line, () => new List<String>()).add(errorCode);\n  }\n\n  /**\n   * Ignore these [errorCodes] at [line].\n   */\n  void addAll(int line, Iterable<String> errorCodes) {\n    _ignoreMap.putIfAbsent(line, () => new List<String>()).addAll(errorCodes);\n  }\n\n  /**\n   * Ignore these [errorCodes] in the whole file.\n   */\n  void addAllForFile(Iterable<String> errorCodes) {\n    _ignoreForFileSet.addAll(errorCodes);\n  }\n\n  /**\n   * Test whether this [errorCode] is ignored at the given [line].\n   */\n  bool ignoredAt(String errorCode, int line) =>\n      _ignoreForFileSet.contains(errorCode) ||\n      _ignoreMap[line]?.contains(errorCode) == true;\n\n  /**\n   * Calculate ignores for the given [content] with line [info].\n   */\n  static IgnoreInfo calculateIgnores(String content, LineInfo info) {\n    Iterable<Match> matches = _IGNORE_MATCHER.allMatches(content);\n    Iterable<Match> fileMatches = _IGNORE_FOR_FILE_MATCHER.allMatches(content);\n    if (matches.isEmpty && fileMatches.isEmpty) {\n      return _EMPTY_INFO;\n    }\n\n    IgnoreInfo ignoreInfo = new IgnoreInfo();\n    for (Match match in matches) {\n      // See _IGNORE_MATCHER for format --- note the possibility of error lists.\n      Iterable<String> codes = match\n          .group(1)\n          .split(',')\n          .map((String code) => code.trim().toLowerCase());\n      CharacterLocation location = info.getLocation(match.start);\n      int lineNumber = location.lineNumber;\n      String beforeMatch = content.substring(\n          info.getOffsetOfLine(lineNumber - 1),\n          info.getOffsetOfLine(lineNumber - 1) + location.columnNumber - 1);\n\n      if (beforeMatch.trim().isEmpty) {\n        // The comment is on its own line, so it refers to the next line.\n        ignoreInfo.addAll(lineNumber + 1, codes);\n      } else {\n        // The comment sits next to code, so it refers to its own line.\n        ignoreInfo.addAll(lineNumber, codes);\n      }\n    }\n    for (Match match in fileMatches) {\n      Iterable<String> codes = match\n          .group(1)\n          .split(',')\n          .map((String code) => code.trim().toLowerCase());\n      ignoreInfo.addAllForFile(codes);\n    }\n    return ignoreInfo;\n  }\n}\n\n/**\n * A task that ensures that all of the inferable instance members in a\n * compilation unit have had their type inferred.\n */\nclass InferInstanceMembersInUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the input whose value is the [RESOLVED_UNIT8] for the\n   * compilation unit.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'InferInstanceMembersInUnitTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CREATED_RESOLVED_UNIT10, RESOLVED_UNIT10]);\n\n  /**\n   * Initialize a newly created task to build a library element for the given\n   * [unit] in the given [context].\n   */\n  InferInstanceMembersInUnitTask(\n      InternalAnalysisContext context, LibrarySpecificUnit unit)\n      : super(context, unit);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n\n    //\n    // Infer instance members.\n    //\n    if (context.analysisOptions.strongMode) {\n      var inheritanceManager = new InheritanceManager(\n          resolutionMap.elementDeclaredByCompilationUnit(unit).library);\n      InstanceMemberInferrer inferrer = new InstanceMemberInferrer(\n          typeProvider, (_) => inheritanceManager,\n          typeSystem: context.typeSystem);\n      inferrer.inferCompilationUnit(unit.element);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[RESOLVED_UNIT10] = unit;\n    outputs[CREATED_RESOLVED_UNIT10] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      UNIT_INPUT: RESOLVED_UNIT9.of(unit),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      // In strong mode, add additional dependencies to enforce inference\n      // ordering.\n\n      // Require that field re-resolution be complete for all units in the\n      // current library cycle.\n      'orderLibraryCycleTasks':\n          LIBRARY_CYCLE_UNITS.of(unit.library).toListOf(CREATED_RESOLVED_UNIT9),\n      // Require that full inference be complete for all dependencies of the\n      // current library cycle.\n      'orderLibraryCycles': LIBRARY_CYCLE_DEPENDENCIES\n          .of(unit.library)\n          .toListOf(CREATED_RESOLVED_UNIT10)\n    };\n  }\n\n  /**\n   * Create a [InferInstanceMembersInUnitTask] based on the given [target] in\n   * the given [context].\n   */\n  static InferInstanceMembersInUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new InferInstanceMembersInUnitTask(context, target);\n  }\n}\n\n/**\n * An abstract class that defines utility methods that are useful for tasks\n * operating on static variables.\n */\nabstract class InferStaticVariableTask extends ConstantEvaluationAnalysisTask {\n  InferStaticVariableTask(\n      InternalAnalysisContext context, VariableElement variable)\n      : super(context, variable);\n\n  /**\n   * Return the declaration of the target within the given compilation [unit].\n   * Throw an exception if the declaration cannot be found.\n   */\n  VariableDeclaration getDeclaration(CompilationUnit unit) {\n    VariableElement variable = target;\n    int offset = variable.nameOffset;\n    AstNode node = new NodeLocator2(offset).searchWithin(unit);\n    if (node == null) {\n      Source variableSource = variable.source;\n      Source unitSource =\n          resolutionMap.elementDeclaredByCompilationUnit(unit).source;\n      if (variableSource != unitSource) {\n        throw new AnalysisException(\n            \"Failed to find the AST node for the variable \"\n            \"${variable.displayName} at $offset in $variableSource \"\n            \"because we were looking in $unitSource\");\n      }\n      throw new AnalysisException(\n          \"Failed to find the AST node for the variable \"\n          \"${variable.displayName} at $offset in $variableSource\");\n    }\n    VariableDeclaration declaration =\n        node.getAncestor((AstNode ancestor) => ancestor is VariableDeclaration);\n    if (declaration == null || declaration.name != node) {\n      Source variableSource = variable.source;\n      Source unitSource =\n          resolutionMap.elementDeclaredByCompilationUnit(unit).source;\n      if (variableSource != unitSource) {\n        if (declaration == null) {\n          throw new AnalysisException(\n              \"Failed to find the declaration of the variable \"\n              \"${variable.displayName} at $offset in $variableSource \"\n              \"because the node was not in a variable declaration \"\n              \"possibly because we were looking in $unitSource\");\n        }\n        throw new AnalysisException(\n            \"Failed to find the declaration of the variable \"\n            \"${variable.displayName} at $offset in $variableSource \"\n            \"because we were looking in $unitSource\");\n      }\n      if (declaration == null) {\n        throw new AnalysisException(\n            \"Failed to find the declaration of the variable \"\n            \"${variable.displayName} at $offset in $variableSource \"\n            \"because the node was not in a variable declaration\");\n      }\n      throw new AnalysisException(\n          \"Failed to find the declaration of the variable \"\n          \"${variable.displayName} at $offset in $variableSource \"\n          \"because the node was not the name in a variable declaration\");\n    }\n    return declaration;\n  }\n}\n\n/**\n * A task that ensures that all of the inferable static variables in a\n * compilation unit have had their type inferred.\n */\nclass InferStaticVariableTypesInUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the [RESOLVED_UNIT8] for the\n   * compilation unit.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [STATIC_VARIABLE_RESOLUTION_ERRORS] for all static\n   * variables in the compilation unit.\n   */\n  static const String ERRORS_LIST_INPUT = 'INFERRED_VARIABLES_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'InferStaticVariableTypesInUnitTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    CREATED_RESOLVED_UNIT8,\n    RESOLVED_UNIT8,\n    STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT\n  ]);\n\n  /**\n   * Initialize a newly created task to build a library element for the given\n   * [unit] in the given [context].\n   */\n  InferStaticVariableTypesInUnitTask(\n      InternalAnalysisContext context, LibrarySpecificUnit unit)\n      : super(context, unit);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    List<List<AnalysisError>> errorLists = getRequiredInput(ERRORS_LIST_INPUT);\n    //\n    // Record outputs. There is no additional work to be done at this time\n    // because the work has implicitly been done by virtue of the task model\n    // preparing all of the inputs.\n    //\n    outputs[RESOLVED_UNIT8] = unit;\n    outputs[CREATED_RESOLVED_UNIT8] = true;\n    outputs[STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT] =\n        AnalysisError.mergeLists(errorLists);\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      'inferredTypes': INFERABLE_STATIC_VARIABLES_IN_UNIT\n          .of(unit)\n          .toListOf(INFERRED_STATIC_VARIABLE),\n      ERRORS_LIST_INPUT: INFERABLE_STATIC_VARIABLES_IN_UNIT\n          .of(unit)\n          .toListOf(STATIC_VARIABLE_RESOLUTION_ERRORS),\n      UNIT_INPUT: RESOLVED_UNIT7.of(unit)\n    };\n  }\n\n  /**\n   * Create a [InferStaticVariableTypesInUnitTask] based on the given [target]\n   * in the given [context].\n   */\n  static InferStaticVariableTypesInUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new InferStaticVariableTypesInUnitTask(context, target);\n  }\n}\n\n/**\n * A task that computes the type of an inferable static variable and\n * stores it in the element model.\n */\nclass InferStaticVariableTypeTask extends InferStaticVariableTask {\n  /**\n   * The name of the input which ensures that dependent values have their type\n   * inferred before the target.\n   */\n  static const String DEPENDENCIES_INPUT = 'DEPENDENCIES_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT8] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'InferStaticVariableTypeTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    INFERRED_STATIC_VARIABLE,\n    STATIC_VARIABLE_RESOLUTION_ERRORS\n  ]);\n\n  InferStaticVariableTypeTask(\n      InternalAnalysisContext context, VariableElement variable)\n      : super(context, variable);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    // Note: DEPENDENCIES_INPUT is not needed.  It is merely a bookkeeping\n    // dependency to ensure that the variables that this variable references\n    // have types inferred before inferring the type of this variable.\n    //\n    VariableElementImpl variable = target;\n\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n\n    // If we're not in a dependency cycle, and we have no type annotation,\n    // re-resolve the right hand side and do inference.\n    List<AnalysisError> errors = AnalysisError.NO_ERRORS;\n    if (dependencyCycle == null && variable.hasImplicitType) {\n      VariableDeclaration declaration = getDeclaration(unit);\n      //\n      // Re-resolve the variable's initializer so that the inferred types\n      // of other variables will be propagated.\n      //\n      RecordingErrorListener errorListener = new RecordingErrorListener();\n      Expression initializer = declaration.initializer;\n\n      ResolutionContext resolutionContext =\n          ResolutionContextBuilder.contextFor(initializer);\n      ResolverVisitor visitor = new ResolverVisitor(\n          variable.library, variable.source, typeProvider, errorListener,\n          nameScope: resolutionContext.scope);\n      if (resolutionContext.enclosingClassDeclaration != null) {\n        visitor.prepareToResolveMembersInClass(\n            resolutionContext.enclosingClassDeclaration);\n      }\n      visitor.initForIncrementalResolution();\n      initializer.accept(visitor);\n      DartType newType = initializer.staticType;\n      if (newType == null || newType.isBottom || newType.isDartCoreNull) {\n        newType = typeProvider.dynamicType;\n      }\n\n      //\n      // Record the type of the variable.\n      //\n      setFieldType(variable, newType);\n      errors = getUniqueErrors(errorListener.errors);\n    } else {\n      // TODO(brianwilkerson) For now we simply don't infer any type for\n      // variables or fields involved in a cycle. We could try to be smarter\n      // by re-resolving the initializer in a context in which the types of all\n      // of the variables in the cycle are assumed to be `null`, but it isn't\n      // clear to me that this would produce better results often enough to\n      // warrant the extra effort.\n    }\n    //\n    // Record outputs.\n    //\n    outputs[INFERRED_STATIC_VARIABLE] = variable;\n    outputs[STATIC_VARIABLE_RESOLUTION_ERRORS] = errors;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    VariableElement variable = target;\n    LibrarySpecificUnit unit =\n        new LibrarySpecificUnit(variable.library.source, variable.source);\n    return <String, TaskInput>{\n      DEPENDENCIES_INPUT: INFERABLE_STATIC_VARIABLE_DEPENDENCIES\n          .of(variable)\n          .toListOf(INFERRED_STATIC_VARIABLE),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      UNIT_INPUT: RESOLVED_UNIT7.of(unit),\n      // In strong mode, add additional dependencies to enforce inference\n      // ordering.\n\n      // Require that full inference be complete for all dependencies of the\n      // current library cycle.\n      'orderLibraryCycles': LIBRARY_CYCLE_DEPENDENCIES\n          .of(unit.library)\n          .toListOf(CREATED_RESOLVED_UNIT10)\n    };\n  }\n\n  /**\n   * Create a [InferStaticVariableTypeTask] based on the given [target] in the\n   * given [context].\n   */\n  static InferStaticVariableTypeTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new InferStaticVariableTypeTask(context, target);\n  }\n}\n\n/**\n * A task computes all of the errors of all of the units for a single\n * library source and sets the [LIBRARY_ERRORS_READY] flag.\n */\nclass LibraryErrorsReadyTask extends SourceBasedAnalysisTask {\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'LibraryErrorsReadyTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ERRORS_READY]);\n\n  LibraryErrorsReadyTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    outputs[LIBRARY_ERRORS_READY] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'allErrors': UNITS.of(source).toListOf(DART_ERRORS),\n      'libraryElement': LIBRARY_ELEMENT.of(source)\n    };\n  }\n\n  /**\n   * Create a [LibraryErrorsReadyTask] based on the given [target] in the given\n   * [context].\n   */\n  static LibraryErrorsReadyTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new LibraryErrorsReadyTask(context, target);\n  }\n}\n\n/**\n * A task that merges all of the errors for a single source into a single list\n * of errors.\n */\nclass LibraryUnitErrorsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [BUILD_DIRECTIVES_ERRORS] input.\n   */\n  static const String BUILD_DIRECTIVES_ERRORS_INPUT = 'BUILD_DIRECTIVES_ERRORS';\n\n  /**\n   * The name of the [BUILD_LIBRARY_ERRORS] input.\n   */\n  static const String BUILD_LIBRARY_ERRORS_INPUT = 'BUILD_LIBRARY_ERRORS';\n\n  /**\n   * The name of the [HINTS] input.\n   */\n  static const String HINTS_INPUT = 'HINTS';\n\n  /**\n   * The name of the [LINTS] input.\n   */\n  static const String LINTS_INPUT = 'LINTS';\n\n  /**\n   * The name of the [STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT] input.\n   */\n  static const String STATIC_VARIABLE_RESOLUTION_ERRORS_INPUT =\n      'STATIC_VARIABLE_RESOLUTION_ERRORS_INPUT';\n\n  /**\n   * The name of the [RESOLVE_DIRECTIVES_ERRORS] input.\n   */\n  static const String RESOLVE_DIRECTIVES_ERRORS_INPUT =\n      'RESOLVE_DIRECTIVES_ERRORS';\n\n  /**\n   * The name of the [STRONG_MODE_ERRORS] input.\n   */\n  static const String STRONG_MODE_ERRORS_INPUT = 'STRONG_MODE_ERRORS';\n\n  /**\n   * The name of the [RESOLVE_TYPE_NAMES_ERRORS] input.\n   */\n  static const String RESOLVE_TYPE_NAMES_ERRORS_INPUT =\n      'RESOLVE_TYPE_NAMES_ERRORS';\n\n  /**\n   * The name of the [RESOLVE_TYPE_BOUNDS_ERRORS] input.\n   */\n  static const String RESOLVE_TYPE_NAMES_ERRORS2_INPUT =\n      'RESOLVE_TYPE_NAMES_ERRORS2';\n\n  /**\n   * The name of the [RESOLVE_UNIT_ERRORS] input.\n   */\n  static const String RESOLVE_UNIT_ERRORS_INPUT = 'RESOLVE_UNIT_ERRORS';\n\n  /**\n   * The name of the [VARIABLE_REFERENCE_ERRORS] input.\n   */\n  static const String VARIABLE_REFERENCE_ERRORS_INPUT =\n      'VARIABLE_REFERENCE_ERRORS';\n\n  /**\n   * The name of the [VERIFY_ERRORS] input.\n   */\n  static const String VERIFY_ERRORS_INPUT = 'VERIFY_ERRORS';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'LibraryUnitErrorsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_UNIT_ERRORS]);\n\n  LibraryUnitErrorsTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    List<List<AnalysisError>> errorLists = <List<AnalysisError>>[];\n    errorLists.add(getRequiredInput(BUILD_DIRECTIVES_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(BUILD_LIBRARY_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(HINTS_INPUT));\n    errorLists.add(getRequiredInput(LINTS_INPUT));\n    errorLists.add(getRequiredInput(RESOLVE_DIRECTIVES_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(RESOLVE_TYPE_NAMES_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(RESOLVE_TYPE_NAMES_ERRORS2_INPUT));\n    errorLists.add(getRequiredInput(RESOLVE_UNIT_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(STATIC_VARIABLE_RESOLUTION_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(STRONG_MODE_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(VARIABLE_REFERENCE_ERRORS_INPUT));\n    errorLists.add(getRequiredInput(VERIFY_ERRORS_INPUT));\n    //\n    // Record outputs.\n    //\n    outputs[LIBRARY_UNIT_ERRORS] = AnalysisError.mergeLists(errorLists);\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [unit].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    Map<String, TaskInput> inputs = <String, TaskInput>{\n      HINTS_INPUT: HINTS.of(unit),\n      LINTS_INPUT: LINTS.of(unit),\n      RESOLVE_DIRECTIVES_ERRORS_INPUT: RESOLVE_DIRECTIVES_ERRORS.of(unit),\n      RESOLVE_TYPE_NAMES_ERRORS_INPUT: RESOLVE_TYPE_NAMES_ERRORS.of(unit),\n      RESOLVE_TYPE_NAMES_ERRORS2_INPUT: RESOLVE_TYPE_BOUNDS_ERRORS.of(unit),\n      RESOLVE_UNIT_ERRORS_INPUT: RESOLVE_UNIT_ERRORS.of(unit),\n      STATIC_VARIABLE_RESOLUTION_ERRORS_INPUT:\n          STATIC_VARIABLE_RESOLUTION_ERRORS_IN_UNIT.of(unit),\n      STRONG_MODE_ERRORS_INPUT: STRONG_MODE_ERRORS.of(unit),\n      VARIABLE_REFERENCE_ERRORS_INPUT: VARIABLE_REFERENCE_ERRORS.of(unit),\n      VERIFY_ERRORS_INPUT: VERIFY_ERRORS.of(unit)\n    };\n    Source source = unit.source;\n    if (unit.library == source) {\n      inputs[BUILD_DIRECTIVES_ERRORS_INPUT] =\n          BUILD_DIRECTIVES_ERRORS.of(source);\n      inputs[BUILD_LIBRARY_ERRORS_INPUT] = BUILD_LIBRARY_ERRORS.of(source);\n    } else {\n      inputs[BUILD_DIRECTIVES_ERRORS_INPUT] =\n          new ConstantTaskInput(AnalysisError.NO_ERRORS);\n      inputs[BUILD_LIBRARY_ERRORS_INPUT] =\n          new ConstantTaskInput(AnalysisError.NO_ERRORS);\n    }\n    return inputs;\n  }\n\n  /**\n   * Create a [LibraryUnitErrorsTask] based on the given [target] in the given\n   * [context].\n   */\n  static LibraryUnitErrorsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new LibraryUnitErrorsTask(context, target);\n  }\n}\n\n/**\n * A task that parses the content of a Dart file, producing an AST structure,\n * any lexical errors found in the process, the kind of the file (library or\n * part), and several lists based on the AST.\n */\nclass ParseDartTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the line information produced for the\n   * file.\n   */\n  static const String LINE_INFO_INPUT_NAME = 'LINE_INFO_INPUT_NAME';\n\n  /**\n   * The name of the input whose value is the modification time of the file.\n   */\n  static const String MODIFICATION_TIME_INPUT_NAME =\n      'MODIFICATION_TIME_INPUT_NAME';\n\n  /**\n   * The name of the input whose value is the token stream produced for the file.\n   */\n  static const String TOKEN_STREAM_INPUT_NAME = 'TOKEN_STREAM_INPUT_NAME';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ParseDartTask', createTask, buildInputs, <ResultDescriptor>[\n    EXPLICITLY_IMPORTED_LIBRARIES,\n    EXPORTED_LIBRARIES,\n    IMPORTED_LIBRARIES,\n    INCLUDED_PARTS,\n    LIBRARY_SPECIFIC_UNITS,\n    PARSE_ERRORS,\n    PARSED_UNIT,\n    REFERENCED_SOURCES,\n    SOURCE_KIND,\n    UNITS,\n  ]);\n\n  /**\n   * The source that is being parsed.\n   */\n  Source _source;\n\n  /**\n   * The [ErrorReporter] to report errors to.\n   */\n  ErrorReporter _errorReporter;\n\n  /**\n   * Initialize a newly created task to parse the content of the Dart file\n   * associated with the given [target] in the given [context].\n   */\n  ParseDartTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    _source = getRequiredSource();\n    LineInfo lineInfo = getRequiredInput(LINE_INFO_INPUT_NAME);\n    int modificationTime = getRequiredInput(MODIFICATION_TIME_INPUT_NAME);\n    Token tokenStream = getRequiredInput(TOKEN_STREAM_INPUT_NAME);\n\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    _errorReporter = new ErrorReporter(errorListener, _source);\n\n    AnalysisOptions options = context.analysisOptions;\n    Parser parser =\n        new Parser(_source, errorListener, useFasta: options.useFastaParser);\n    parser.parseFunctionBodies =\n        options.analyzeFunctionBodiesPredicate(_source);\n    parser.parseGenericMethodComments = options.strongMode;\n    parser.enableOptionalNewAndConst = options.previewDart2;\n    CompilationUnit unit = parser.parseCompilationUnit(tokenStream);\n    unit.lineInfo = lineInfo;\n\n    if (options.patchPaths.isNotEmpty && _source.uri.scheme == 'dart') {\n      var resourceProvider =\n          (context.sourceFactory.dartSdk as FolderBasedDartSdk)\n              .resourceProvider;\n      new SdkPatcher().patch(\n          resourceProvider,\n          context.analysisOptions.strongMode,\n          context.analysisOptions.patchPaths,\n          errorListener,\n          _source,\n          unit);\n    }\n\n    bool hasNonPartOfDirective = false;\n    bool hasPartOfDirective = false;\n    HashSet<Source> explicitlyImportedSourceSet = new HashSet<Source>();\n    HashSet<Source> exportedSourceSet = new HashSet<Source>();\n    HashSet<Source> includedSourceSet = new HashSet<Source>();\n    NodeList<Directive> directives = unit.directives;\n    int length = directives.length;\n    for (int i = 0; i < length; i++) {\n      Directive directive = directives[i];\n      if (directive is PartOfDirective) {\n        hasPartOfDirective = true;\n      } else {\n        hasNonPartOfDirective = true;\n        if (directive is UriBasedDirective) {\n          Source referencedSource = _resolveDirective(directive);\n          if (referencedSource != null) {\n            if (directive is ExportDirective) {\n              exportedSourceSet.add(referencedSource);\n            } else if (directive is ImportDirective) {\n              explicitlyImportedSourceSet.add(referencedSource);\n            } else if (directive is PartDirective) {\n              includedSourceSet.add(referencedSource);\n            } else {\n              throw new AnalysisException(\n                  '$runtimeType failed to handle a ${directive.runtimeType}');\n            }\n          }\n        }\n      }\n    }\n    //\n    // Always include \"dart:core\" source.\n    //\n    HashSet<Source> importedSourceSet =\n        new HashSet.from(explicitlyImportedSourceSet);\n    Source coreLibrarySource = context.sourceFactory.forUri(DartSdk.DART_CORE);\n    if (coreLibrarySource == null) {\n      String message;\n      DartSdk sdk = context.sourceFactory.dartSdk;\n      if (sdk == null) {\n        message = 'Could not resolve \"dart:core\": SDK not defined';\n      } else {\n        message = 'Could not resolve \"dart:core\": SDK incorrectly configured';\n      }\n      throw new AnalysisException(message);\n    }\n    importedSourceSet.add(coreLibrarySource);\n    //\n    // Compute kind.\n    //\n    SourceKind sourceKind = SourceKind.LIBRARY;\n    if (modificationTime == -1) {\n      sourceKind = SourceKind.UNKNOWN;\n    } else if (hasPartOfDirective && !hasNonPartOfDirective) {\n      sourceKind = SourceKind.PART;\n    }\n    //\n    // Compute source lists.\n    //\n    List<Source> explicitlyImportedSources =\n        explicitlyImportedSourceSet.toList();\n    List<Source> exportedSources = exportedSourceSet.toList();\n    List<Source> importedSources = importedSourceSet.toList();\n    List<Source> includedSources = includedSourceSet.toList();\n    List<Source> unitSources = <Source>[_source]..addAll(includedSourceSet);\n    List<LibrarySpecificUnit> librarySpecificUnits =\n        unitSources.map((s) => new LibrarySpecificUnit(_source, s)).toList();\n    //\n    // Compute referenced sources.\n    //\n    Set<Source> referencedSources = new Set<Source>();\n    referencedSources.add(coreLibrarySource);\n    referencedSources.addAll(unitSources);\n    for (Directive directive in unit.directives) {\n      if (directive is NamespaceDirective) {\n        referencedSources.add(directive.uriSource);\n        for (Configuration configuration in directive.configurations) {\n          referencedSources.add(configuration.uriSource);\n        }\n      }\n    }\n    referencedSources.removeWhere((source) => source == null);\n    //\n    // Record outputs.\n    //\n    List<AnalysisError> parseErrors = getUniqueErrors(errorListener.errors);\n    outputs[EXPLICITLY_IMPORTED_LIBRARIES] = explicitlyImportedSources;\n    outputs[EXPORTED_LIBRARIES] = exportedSources;\n    outputs[IMPORTED_LIBRARIES] = importedSources;\n    outputs[INCLUDED_PARTS] = includedSources;\n    outputs[LIBRARY_SPECIFIC_UNITS] = librarySpecificUnits;\n    outputs[PARSE_ERRORS] = parseErrors;\n    outputs[PARSED_UNIT] = unit;\n    outputs[REFERENCED_SOURCES] = referencedSources.toList();\n    outputs[SOURCE_KIND] = sourceKind;\n    outputs[UNITS] = unitSources;\n  }\n\n  /**\n   * Return the result of resolving the URI of the given URI-based [directive]\n   * against the URI of the given library, or `null` if the URI is not valid.\n   */\n  Source _resolveDirective(UriBasedDirective directive) {\n    bool isImport = directive is ImportDirective;\n\n    // Resolve the default URI.\n    Source defaultSource;\n    {\n      StringLiteral uriLiteral = directive.uri;\n      String uriContent = uriLiteral.stringValue;\n      if (uriContent != null) {\n        uriContent = uriContent.trim();\n        directive.uriContent = uriContent;\n      }\n      defaultSource = _resolveUri(isImport, uriLiteral, uriContent);\n      directive.uriSource = defaultSource;\n    }\n\n    // Resolve all configurations and try to choose one.\n    if (directive is NamespaceDirectiveImpl) {\n      String configuredUriContent;\n      Source configuredSource;\n      for (Configuration configuration in directive.configurations) {\n        String uriContent = configuration.uri.stringValue;\n        Source source = _resolveUri(isImport, configuration.uri, uriContent);\n        configuration.uriSource = source;\n        if (configuredSource == null) {\n          String variableName =\n              configuration.name.components.map((i) => i.name).join('.');\n          String variableValue = context.declaredVariables.get(variableName);\n          if (configuration.value != null &&\n                  variableValue == configuration.value.stringValue ||\n              variableValue == 'true') {\n            configuredUriContent = configuration.uri.stringValue;\n            configuredSource = source;\n          }\n        }\n      }\n      String selectedContentUri = configuredUriContent ?? directive.uriContent;\n      Source selectedSource = configuredSource ?? defaultSource;\n      directive.selectedUriContent = selectedContentUri;\n      directive.selectedSource = selectedSource;\n      return selectedSource;\n    }\n    return defaultSource;\n  }\n\n  /**\n   * Return the result of resolve the given [uriContent], reporting errors\n   * against the [uriLiteral].\n   */\n  Source _resolveUri(\n      bool isImport, StringLiteral uriLiteral, String uriContent) {\n    UriValidationCode code =\n        UriBasedDirectiveImpl.validateUri(isImport, uriLiteral, uriContent);\n    if (code == null) {\n      try {\n        Uri.parse(uriContent);\n      } on FormatException {\n        return null;\n      }\n      return context.sourceFactory.resolveUri(_source, uriContent);\n    } else if (code == UriValidationCode.URI_WITH_DART_EXT_SCHEME) {\n      return null;\n    } else if (code == UriValidationCode.URI_WITH_INTERPOLATION) {\n      _errorReporter.reportErrorForNode(\n          CompileTimeErrorCode.URI_WITH_INTERPOLATION, uriLiteral);\n      return null;\n    } else if (code == UriValidationCode.INVALID_URI) {\n      _errorReporter.reportErrorForNode(\n          CompileTimeErrorCode.INVALID_URI, uriLiteral, [uriContent]);\n      return null;\n    }\n    throw new AnalysisException('Failed to handle validation code: $code');\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    return <String, TaskInput>{\n      LINE_INFO_INPUT_NAME: LINE_INFO.of(target),\n      MODIFICATION_TIME_INPUT_NAME: MODIFICATION_TIME.of(target),\n      TOKEN_STREAM_INPUT_NAME: TOKEN_STREAM.of(target, flushOnAccess: true)\n    };\n  }\n\n  /**\n   * Create a [ParseDartTask] based on the given [target] in the given\n   * [context].\n   */\n  static ParseDartTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ParseDartTask(context, target);\n  }\n}\n\n/**\n * A task that builds [RESOLVED_UNIT7] for a unit.\n */\nclass PartiallyResolveUnitReferencesTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT6] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT6] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'PartiallyResolveUnitReferencesTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    INFERABLE_STATIC_VARIABLES_IN_UNIT,\n    CREATED_RESOLVED_UNIT7,\n    RESOLVED_UNIT7\n  ]);\n\n  PartiallyResolveUnitReferencesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement libraryElement = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Resolve references and record outputs.\n    //\n    PartialResolverVisitor visitor = new PartialResolverVisitor(libraryElement,\n        unitElement.source, typeProvider, AnalysisErrorListener.NULL_LISTENER);\n    unit.accept(visitor);\n    //\n    // Record outputs.\n    //\n    if (context.analysisOptions.strongMode) {\n      outputs[INFERABLE_STATIC_VARIABLES_IN_UNIT] = visitor.staticVariables;\n    } else {\n      outputs[INFERABLE_STATIC_VARIABLES_IN_UNIT] = VariableElement.EMPTY_LIST;\n    }\n    outputs[RESOLVED_UNIT7] = unit;\n    outputs[CREATED_RESOLVED_UNIT7] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      'fullyBuiltLibraryElements': READY_LIBRARY_ELEMENT6.of(unit.library),\n      LIBRARY_INPUT: LIBRARY_ELEMENT6.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT6.of(unit),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      // In strong mode, add additional dependencies to enforce inference\n      // ordering.\n\n      // Require that full inference be complete for all dependencies of the\n      // current library cycle.\n      'orderLibraryCycles': LIBRARY_CYCLE_DEPENDENCIES\n          .of(unit.library)\n          .toListOf(CREATED_RESOLVED_UNIT10)\n    };\n  }\n\n  /**\n   * Create a [PartiallyResolveUnitReferencesTask] based on the given [target]\n   * in the given [context].\n   */\n  static PartiallyResolveUnitReferencesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new PartiallyResolveUnitReferencesTask(context, target);\n  }\n}\n\n/**\n * A task that ensures that [LIBRARY_ELEMENT2] is ready for the target library\n * source and its import/export closure.\n */\nclass ReadyLibraryElement2Task extends SourceBasedAnalysisTask {\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ReadyLibraryElement2Task',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[READY_LIBRARY_ELEMENT2]);\n\n  ReadyLibraryElement2Task(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    outputs[READY_LIBRARY_ELEMENT2] = true;\n  }\n\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'thisLibraryElementReady': LIBRARY_ELEMENT2.of(source),\n      'directlyImportedLibrariesReady':\n          IMPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT2),\n      'directlyExportedLibrariesReady':\n          EXPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT2),\n    };\n  }\n\n  static ReadyLibraryElement2Task createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ReadyLibraryElement2Task(context, target);\n  }\n}\n\n/**\n * A task that ensures that [LIBRARY_ELEMENT6] is ready for the target library\n * source and its import/export closure.\n */\nclass ReadyLibraryElement5Task extends SourceBasedAnalysisTask {\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ReadyLibraryElement5Task',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[READY_LIBRARY_ELEMENT6]);\n\n  ReadyLibraryElement5Task(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    outputs[READY_LIBRARY_ELEMENT6] = true;\n  }\n\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'thisLibraryElementReady': LIBRARY_ELEMENT6.of(source),\n      'directlyImportedLibrariesReady':\n          IMPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT6),\n      'directlyExportedLibrariesReady':\n          EXPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT6),\n    };\n  }\n\n  static ReadyLibraryElement5Task createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ReadyLibraryElement5Task(context, target);\n  }\n}\n\n/**\n * A task that ensures that [LIBRARY_ELEMENT7] is ready for the target library\n * source and its import/export closure.\n */\nclass ReadyLibraryElement7Task extends SourceBasedAnalysisTask {\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ReadyLibraryElement7Task',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[READY_LIBRARY_ELEMENT7]);\n\n  ReadyLibraryElement7Task(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    outputs[READY_LIBRARY_ELEMENT7] = true;\n  }\n\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'thisLibraryElementReady': LIBRARY_ELEMENT7.of(source),\n      'directlyImportedLibrariesReady':\n          IMPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT7),\n      'directlyExportedLibrariesReady':\n          EXPORTED_LIBRARIES.of(source).toListOf(READY_LIBRARY_ELEMENT7),\n    };\n  }\n\n  static ReadyLibraryElement7Task createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ReadyLibraryElement7Task(context, target);\n  }\n}\n\n/**\n * A task that ensures that [RESOLVED_UNIT] is ready for every unit of the\n * target library source and its import/export closure.\n */\nclass ReadyResolvedUnitTask extends SourceBasedAnalysisTask {\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ReadyResolvedUnitTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[READY_RESOLVED_UNIT]);\n\n  ReadyResolvedUnitTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    outputs[READY_RESOLVED_UNIT] = true;\n  }\n\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'thisLibraryUnitsReady':\n          LIBRARY_SPECIFIC_UNITS.of(source).toListOf(RESOLVED_UNIT),\n    };\n  }\n\n  static ReadyResolvedUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ReadyResolvedUnitTask(context, target);\n  }\n}\n\n/**\n * A task that ensures that the expression AST for a constant is resolved and\n * sets the [CONSTANT_EXPRESSION_RESOLVED] result.\n */\nclass ResolveConstantExpressionTask extends ConstantEvaluationAnalysisTask {\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveConstantExpressionTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CONSTANT_EXPRESSION_RESOLVED]);\n\n  ResolveConstantExpressionTask(\n      InternalAnalysisContext context, ConstantEvaluationTarget constant)\n      : super(context, constant);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Record outputs.\n    //\n    outputs[CONSTANT_EXPRESSION_RESOLVED] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source librarySource;\n    if (target is Element) {\n      CompilationUnitElementImpl unit = target\n          .getAncestor((Element element) => element is CompilationUnitElement);\n      librarySource = unit.librarySource;\n    } else if (target is ElementAnnotationImpl) {\n      librarySource = target.librarySource;\n    } else {\n      throw new AnalysisException(\n          'Cannot build inputs for a ${target.runtimeType}');\n    }\n    return <String, TaskInput>{\n      'createdResolvedUnit': CREATED_RESOLVED_UNIT11\n          .of(new LibrarySpecificUnit(librarySource, target.source))\n    };\n  }\n\n  /**\n   * Create a [ResolveConstantExpressionTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveConstantExpressionTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveConstantExpressionTask(context, target);\n  }\n}\n\n/**\n * A task that resolves imports and export directives to already built elements.\n */\nclass ResolveDirectiveElementsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [LIBRARY_ELEMENT2].\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the input for [RESOLVED_UNIT1] of a unit.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  static const String SOURCES_MODIFICATION_TIME_INPUT =\n      'SOURCES_MODIFICATION_TIME_INPUT';\n  static const String IMPORTS_SOURCE_KIND_INPUT = 'IMPORTS_SOURCE_KIND_INPUT';\n  static const String EXPORTS_SOURCE_KIND_INPUT = 'EXPORTS_SOURCE_KIND_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveDirectiveElementsTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    CREATED_RESOLVED_UNIT2,\n    RESOLVED_UNIT2,\n    RESOLVE_DIRECTIVES_ERRORS\n  ]);\n\n  ResolveDirectiveElementsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibrarySpecificUnit targetUnit = target;\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    Map<Source, int> sourceModificationTimeMap =\n        getRequiredInput(SOURCES_MODIFICATION_TIME_INPUT);\n    Map<Source, SourceKind> importSourceKindMap =\n        getRequiredInput(IMPORTS_SOURCE_KIND_INPUT);\n    Map<Source, SourceKind> exportSourceKindMap =\n        getRequiredInput(EXPORTS_SOURCE_KIND_INPUT);\n    //\n    // Resolve directive AST nodes to elements.\n    //\n    List<AnalysisError> errors = const <AnalysisError>[];\n    if (targetUnit.unit == targetUnit.library) {\n      DirectiveResolver resolver = new DirectiveResolver(\n          sourceModificationTimeMap, importSourceKindMap, exportSourceKindMap);\n      unit.accept(resolver);\n      errors = resolver.errors;\n    }\n    //\n    // Record outputs.\n    //\n    outputs[CREATED_RESOLVED_UNIT2] = true;\n    outputs[RESOLVED_UNIT2] = unit;\n    outputs[RESOLVE_DIRECTIVES_ERRORS] = errors;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT2.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT1.of(unit),\n      SOURCES_MODIFICATION_TIME_INPUT:\n          REFERENCED_SOURCES.of(unit.library).toMapOf(MODIFICATION_TIME),\n      IMPORTS_SOURCE_KIND_INPUT:\n          IMPORTED_LIBRARIES.of(unit.library).toMapOf(SOURCE_KIND),\n      EXPORTS_SOURCE_KIND_INPUT:\n          EXPORTED_LIBRARIES.of(unit.library).toMapOf(SOURCE_KIND)\n    };\n  }\n\n  /**\n   * Create a [ResolveDirectiveElementsTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveDirectiveElementsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveDirectiveElementsTask(context, target);\n  }\n}\n\n/**\n * An artificial task that does nothing except to force [LIBRARY_ELEMENT7] for\n * the target library and its import/export closure.\n */\nclass ResolvedUnit7InLibraryClosureTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT7] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolvedUnit7InLibraryClosureTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT8]);\n\n  ResolvedUnit7InLibraryClosureTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    outputs[LIBRARY_ELEMENT8] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'readyForClosure': READY_LIBRARY_ELEMENT7.of(source),\n      LIBRARY_INPUT: LIBRARY_ELEMENT7.of(source),\n    };\n  }\n\n  /**\n   * Create a [ResolvedUnit7InLibraryClosureTask] based on the given\n   * [target] in the given [context].\n   */\n  static ResolvedUnit7InLibraryClosureTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolvedUnit7InLibraryClosureTask(context, target);\n  }\n}\n\n/**\n * An artificial task that does nothing except to force [LIBRARY_ELEMENT6] and\n * [RESOLVED_UNIT7] in the defining and part units of a library.\n */\nclass ResolvedUnit7InLibraryTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT6] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolvedUnit7InLibraryTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT7]);\n\n  ResolvedUnit7InLibraryTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    outputs[LIBRARY_ELEMENT7] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'resolvedUnits':\n          LIBRARY_SPECIFIC_UNITS.of(source).toListOf(RESOLVED_UNIT7),\n      LIBRARY_INPUT: LIBRARY_ELEMENT6.of(source),\n    };\n  }\n\n  /**\n   * Create a [ResolvedUnit7InLibraryTask] based on the given [target]\n   * in the given [context].\n   */\n  static ResolvedUnit7InLibraryTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolvedUnit7InLibraryTask(context, target);\n  }\n}\n\n/**\n * A task that ensures that all of the inferable instance members in a\n * compilation unit have had their right hand sides re-resolved\n */\nclass ResolveInstanceFieldsInUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT6] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the input whose value is the [RESOLVED_UNIT8] for the\n   * compilation unit.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveInstanceFieldsInUnitTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[CREATED_RESOLVED_UNIT9, RESOLVED_UNIT9]);\n\n  /**\n   * Initialize a newly created task to build a library element for the given\n   * [unit] in the given [context].\n   */\n  ResolveInstanceFieldsInUnitTask(\n      InternalAnalysisContext context, LibrarySpecificUnit unit)\n      : super(context, unit);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement libraryElement = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n\n    CompilationUnitElement unitElement = unit.element;\n    if (context.analysisOptions.strongMode) {\n      //\n      // Resolve references.\n      //\n      InstanceFieldResolverVisitor visitor = new InstanceFieldResolverVisitor(\n          libraryElement,\n          unitElement.source,\n          typeProvider,\n          AnalysisErrorListener.NULL_LISTENER);\n      visitor.resolveCompilationUnit(unit);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[RESOLVED_UNIT9] = unit;\n    outputs[CREATED_RESOLVED_UNIT9] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [libSource].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      UNIT_INPUT: RESOLVED_UNIT8.of(unit),\n      LIBRARY_INPUT: LIBRARY_ELEMENT6.of(unit.library),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      // In strong mode, add additional dependencies to enforce inference\n      // ordering.\n\n      // Require that static variable inference  be complete for all units in\n      // the current library cycle.\n      'orderLibraryCycleTasks':\n          LIBRARY_CYCLE_UNITS.of(unit.library).toListOf(CREATED_RESOLVED_UNIT8),\n      // Require that full inference be complete for all dependencies of the\n      // current library cycle.\n      'orderLibraryCycles': LIBRARY_CYCLE_DEPENDENCIES\n          .of(unit.library)\n          .toListOf(CREATED_RESOLVED_UNIT10)\n    };\n  }\n\n  /**\n   * Create a [ResolveInstanceFieldsInUnitTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveInstanceFieldsInUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveInstanceFieldsInUnitTask(context, target);\n  }\n}\n\n/**\n * A task that finishes resolution by requesting [RESOLVED_UNIT11] for every\n * unit in the libraries closure and produces [LIBRARY_ELEMENT9].\n */\nclass ResolveLibraryReferencesTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT8] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveLibraryReferencesTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT9]);\n\n  ResolveLibraryReferencesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    outputs[LIBRARY_ELEMENT9] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT8.of(source),\n      'resolvedUnits':\n          LIBRARY_SPECIFIC_UNITS.of(source).toListOf(RESOLVED_UNIT11),\n    };\n  }\n\n  /**\n   * Create a [ResolveLibraryReferencesTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveLibraryReferencesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveLibraryReferencesTask(context, target);\n  }\n}\n\n/**\n * A task that finishes resolution by requesting [RESOLVED_UNIT12] for every\n * unit in the libraries closure and produces [LIBRARY_ELEMENT].\n */\nclass ResolveLibraryTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT9] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the list of [RESOLVED_UNIT12] input.\n   */\n  static const String UNITS_INPUT = 'UNITS_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveLibraryTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT]);\n\n  ResolveLibraryTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    //\n    // Record outputs.\n    //\n    outputs[LIBRARY_ELEMENT] = library;\n  }\n\n/**\n * Return a map from the names of the inputs of this kind of task to the task\n * input descriptors describing those inputs for a task with the\n * given [target].\n */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT9.of(source),\n      'thisLibraryClosureIsReady': READY_RESOLVED_UNIT.of(source),\n    };\n  }\n\n/**\n * Create a [ResolveLibraryTask] based on the given [target] in the given\n * [context].\n */\n  static ResolveLibraryTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveLibraryTask(context, target);\n  }\n}\n\n/**\n * An artificial task that does nothing except to force type names resolution\n * for the defining and part units of a library.\n */\nclass ResolveLibraryTypeNamesTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT5] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveLibraryTypeNamesTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT6]);\n\n  ResolveLibraryTypeNamesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Create the synthetic element for `loadLibrary`.\n    //\n    (library as LibraryElementImpl).createLoadLibraryFunction(typeProvider);\n    //\n    // Record outputs.\n    //\n    outputs[LIBRARY_ELEMENT6] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      'resolvedUnit':\n          LIBRARY_SPECIFIC_UNITS.of(source).toListOf(RESOLVED_UNIT5),\n      LIBRARY_INPUT: LIBRARY_ELEMENT5.of(source),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [ResolveLibraryTypeNamesTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveLibraryTypeNamesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveLibraryTypeNamesTask(context, target);\n  }\n}\n\n/**\n * An artificial task that does nothing except to force type parameter bounds\n * type names resolution for the defining and part units of a library.\n */\nclass ResolveTopLevelLibraryTypeBoundsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT4] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveTopLevelLibraryTypeBoundsTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[LIBRARY_ELEMENT5]);\n\n  ResolveTopLevelLibraryTypeBoundsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  bool get handlesDependencyCycles => true;\n\n  @override\n  void internalPerform() {\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    outputs[LIBRARY_ELEMENT5] = library;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    Source source = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT4.of(source),\n      'thisLibraryUnitsReady':\n          LIBRARY_SPECIFIC_UNITS.of(source).toListOf(RESOLVED_UNIT4),\n      'directlyImportedLibrariesReady':\n          IMPORTED_LIBRARIES.of(source).toListOf(LIBRARY_ELEMENT5),\n      'directlyExportedLibrariesReady':\n          EXPORTED_LIBRARIES.of(source).toListOf(LIBRARY_ELEMENT5),\n    };\n  }\n\n  /**\n   * Create a [ResolveTopLevelLibraryTypeBoundsTask] based on the given [target]\n   * in the given [context].\n   */\n  static ResolveTopLevelLibraryTypeBoundsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveTopLevelLibraryTypeBoundsTask(context, target);\n  }\n}\n\n/**\n * A task that builds [RESOLVED_UNIT4] for a unit.\n */\nclass ResolveTopLevelUnitTypeBoundsTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [LIBRARY_ELEMENT4].\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT3] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveTopLevelUnitTypeBoundsTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    RESOLVE_TYPE_BOUNDS_ERRORS,\n    CREATED_RESOLVED_UNIT4,\n    RESOLVED_UNIT4\n  ]);\n\n  ResolveTopLevelUnitTypeBoundsTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    //\n    // Resolve TypeName nodes.\n    //\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    new TypeParameterBoundsResolver(\n            context.typeSystem, library, unitElement.source, errorListener)\n        .resolveTypeBounds(unit);\n    //\n    // Record outputs.\n    //\n    outputs[RESOLVE_TYPE_BOUNDS_ERRORS] =\n        getTargetSourceErrors(errorListener, target);\n    outputs[RESOLVED_UNIT4] = unit;\n    outputs[CREATED_RESOLVED_UNIT4] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    // TODO(brianwilkerson) This task updates the element model to have type\n    // information and updates the class hierarchy. It should produce a new\n    // version of the element model in order to record those changes.\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      'importsExportNamespace':\n          IMPORTED_LIBRARIES.of(unit.library).toMapOf(LIBRARY_ELEMENT4),\n      'dependOnAllExportedSources':\n          IMPORTED_LIBRARIES.of(unit.library).toMapOf(EXPORT_SOURCE_CLOSURE),\n      LIBRARY_INPUT: LIBRARY_ELEMENT4.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT3.of(unit)\n    };\n  }\n\n  /**\n   * Create a [ResolveTopLevelUnitTypeBoundsTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveTopLevelUnitTypeBoundsTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveTopLevelUnitTypeBoundsTask(context, target);\n  }\n}\n\n/**\n * A task that resolves the bodies of top-level functions, constructors, and\n * methods within a single compilation unit.\n */\nclass ResolveUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [LIBRARY_ELEMENT8].\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT10] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveUnitTask', createTask, buildInputs, <ResultDescriptor>[\n    CONSTANT_EXPRESSIONS_DEPENDENCIES,\n    RESOLVE_UNIT_ERRORS,\n    CREATED_RESOLVED_UNIT11,\n    RESOLVED_UNIT11\n  ]);\n\n  ResolveUnitTask(\n      InternalAnalysisContext context, LibrarySpecificUnit compilationUnit)\n      : super(context, compilationUnit);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibrarySpecificUnit target = this.target;\n    LibraryElement libraryElement = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Resolve everything.\n    //\n    CompilationUnitElement unitElement = unit.element;\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    ResolverVisitor visitor = new ResolverVisitor(\n        libraryElement, unitElement.source, typeProvider, errorListener);\n    unit.accept(visitor);\n    //\n    // Compute constant expressions' dependencies.\n    //\n    List<ConstantEvaluationTarget> constExprDependencies;\n    {\n      ConstantExpressionsDependenciesFinder finder =\n          new ConstantExpressionsDependenciesFinder();\n      unit.accept(finder);\n      constExprDependencies = finder.dependencies.toList();\n    }\n    //\n    // Record outputs.\n    //\n    // TODO(brianwilkerson) This task modifies the element model (by copying the\n    // AST's for constructor initializers into it) but does not produce an\n    // updated version of the element model.\n    //\n    outputs[CONSTANT_EXPRESSIONS_DEPENDENCIES] = constExprDependencies;\n    outputs[RESOLVE_UNIT_ERRORS] = getTargetSourceErrors(errorListener, target);\n    outputs[RESOLVED_UNIT11] = unit;\n    outputs[CREATED_RESOLVED_UNIT11] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT8.of(unit.library),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n      UNIT_INPUT: RESOLVED_UNIT10.of(unit),\n      // In strong mode, add additional dependencies to enforce inference\n      // ordering.\n\n      // Require that inference be complete for all units in the\n      // current library cycle.\n      'orderLibraryCycleTasks':\n          LIBRARY_CYCLE_UNITS.of(unit.library).toListOf(CREATED_RESOLVED_UNIT10)\n    };\n  }\n\n  /**\n   * Create a [ResolveUnitTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveUnitTask(context, target);\n  }\n}\n\n/**\n * A task that builds [RESOLVED_UNIT5] for a unit.\n */\nclass ResolveUnitTypeNamesTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the defining [LIBRARY_ELEMENT5].\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT4] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveUnitTypeNamesTask', createTask, buildInputs, <ResultDescriptor>[\n    RESOLVE_TYPE_NAMES_ERRORS,\n    CREATED_RESOLVED_UNIT5,\n    RESOLVED_UNIT5\n  ]);\n\n  ResolveUnitTypeNamesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement library = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Resolve TypeName nodes.\n    //\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    TypeResolverVisitor visitor = new TypeResolverVisitor(\n        library, unitElement.source, typeProvider, errorListener);\n    unit.accept(visitor);\n    //\n    // Re-write the AST to handle the optional new and const feature.\n    //\n    if (library.context.analysisOptions.previewDart2) {\n      unit.accept(new AstRewriteVisitor(\n          context.typeSystem,\n          library,\n          unit.element.source,\n          typeProvider,\n          AnalysisErrorListener.NULL_LISTENER));\n    }\n    //\n    // Record outputs.\n    //\n    outputs[RESOLVE_TYPE_NAMES_ERRORS] =\n        getTargetSourceErrors(errorListener, target);\n    outputs[RESOLVED_UNIT5] = unit;\n    outputs[CREATED_RESOLVED_UNIT5] = true;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    // TODO(brianwilkerson) This task updates the element model to have type\n    // information and updates the class hierarchy. It should produce a new\n    // version of the element model in order to record those changes.\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT5.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT4.of(unit),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [ResolveUnitTypeNamesTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveUnitTypeNamesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveUnitTypeNamesTask(context, target);\n  }\n}\n\n/**\n * A task that builds [RESOLVED_UNIT6] for a unit.\n */\nclass ResolveVariableReferencesTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [LIBRARY_ELEMENT1] input.\n   */\n  static const String LIBRARY_INPUT = 'LIBRARY_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT5] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ResolveVariableReferencesTask',\n      createTask,\n      buildInputs, <ResultDescriptor>[\n    CREATED_RESOLVED_UNIT6,\n    RESOLVED_UNIT6,\n    VARIABLE_REFERENCE_ERRORS\n  ]);\n\n  ResolveVariableReferencesTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    //\n    // Prepare inputs.\n    //\n    LibraryElement libraryElement = getRequiredInput(LIBRARY_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Resolve local variables.\n    //\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    Scope nameScope = new LibraryScope(libraryElement);\n    VariableResolverVisitor visitor = new VariableResolverVisitor(\n        libraryElement, unitElement.source, typeProvider, errorListener,\n        nameScope: nameScope);\n    unit.accept(visitor);\n    //\n    // Record outputs.\n    //\n    outputs[RESOLVED_UNIT6] = unit;\n    outputs[CREATED_RESOLVED_UNIT6] = true;\n    outputs[VARIABLE_REFERENCE_ERRORS] =\n        getTargetSourceErrors(errorListener, target);\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      LIBRARY_INPUT: LIBRARY_ELEMENT1.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT5.of(unit),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [ResolveVariableReferencesTask] based on the given [target] in\n   * the given [context].\n   */\n  static ResolveVariableReferencesTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ResolveVariableReferencesTask(context, target);\n  }\n}\n\n/**\n * A task that scans the content of a Dart file, producing a stream of Dart\n * tokens, line information, and any lexical errors encountered in the process.\n */\nclass ScanDartTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the input whose value is the content of the file.\n   */\n  static const String CONTENT_INPUT_NAME = 'CONTENT_INPUT_NAME';\n\n  /**\n   * The name of the input whose value is the modification time of the file.\n   */\n  static const String MODIFICATION_TIME_INPUT = 'MODIFICATION_TIME_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'ScanDartTask',\n      createTask,\n      buildInputs,\n      <ResultDescriptor>[IGNORE_INFO, LINE_INFO, SCAN_ERRORS, TOKEN_STREAM],\n      suitabilityFor: suitabilityFor);\n\n  /**\n   * Initialize a newly created task to access the content of the source\n   * associated with the given [target] in the given [context].\n   */\n  ScanDartTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    Source source = getRequiredSource();\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n\n    int modificationTime = getRequiredInput(MODIFICATION_TIME_INPUT);\n    if (modificationTime < 0) {\n      String message = 'Content could not be read';\n      if (context is InternalAnalysisContext) {\n        CacheEntry entry =\n            (context as InternalAnalysisContext).getCacheEntry(target);\n        CaughtException exception = entry.exception;\n        if (exception != null) {\n          message = exception.toString();\n        }\n      }\n      if (source.exists()) {\n        errorListener.onError(new AnalysisError(\n            source, 0, 0, ScannerErrorCode.UNABLE_GET_CONTENT, [message]));\n      }\n    }\n    if (target is DartScript) {\n      DartScript script = target;\n      List<ScriptFragment> fragments = script.fragments;\n      if (fragments.length < 1) {\n        throw new AnalysisException('Cannot scan scripts with no fragments');\n      } else if (fragments.length > 1) {\n        throw new AnalysisException(\n            'Cannot scan scripts with multiple fragments');\n      }\n      ScriptFragment fragment = fragments[0];\n\n      Scanner scanner = new Scanner(\n          source,\n          new SubSequenceReader(fragment.content, fragment.offset),\n          errorListener);\n      scanner.setSourceStart(fragment.line, fragment.column);\n      scanner.preserveComments = context.analysisOptions.preserveComments;\n      scanner.scanGenericMethodComments = context.analysisOptions.strongMode;\n      scanner.scanLazyAssignmentOperators =\n          context.analysisOptions.enableLazyAssignmentOperators;\n\n      LineInfo lineInfo = new LineInfo(scanner.lineStarts);\n\n      outputs[TOKEN_STREAM] = scanner.tokenize();\n      outputs[LINE_INFO] = lineInfo;\n      outputs[IGNORE_INFO] =\n          IgnoreInfo.calculateIgnores(fragment.content, lineInfo);\n      outputs[SCAN_ERRORS] = getUniqueErrors(errorListener.errors);\n    } else if (target is Source) {\n      String content = getRequiredInput(CONTENT_INPUT_NAME);\n\n      Scanner scanner =\n          new Scanner(source, new CharSequenceReader(content), errorListener);\n      scanner.preserveComments = context.analysisOptions.preserveComments;\n      scanner.scanGenericMethodComments = context.analysisOptions.strongMode;\n      scanner.scanLazyAssignmentOperators =\n          context.analysisOptions.enableLazyAssignmentOperators;\n\n      LineInfo lineInfo = new LineInfo(scanner.lineStarts);\n\n      outputs[TOKEN_STREAM] = scanner.tokenize();\n      outputs[LINE_INFO] = lineInfo;\n      outputs[IGNORE_INFO] = IgnoreInfo.calculateIgnores(content, lineInfo);\n      outputs[SCAN_ERRORS] = getUniqueErrors(errorListener.errors);\n    } else {\n      throw new AnalysisException(\n          'Cannot scan Dart code from a ${target.runtimeType}');\n    }\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the given\n   * [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    if (target is Source) {\n      return <String, TaskInput>{\n        CONTENT_INPUT_NAME: CONTENT.of(target, flushOnAccess: true),\n        MODIFICATION_TIME_INPUT: MODIFICATION_TIME.of(target)\n      };\n    } else if (target is DartScript) {\n      // This task does not use the following input; it is included only to add\n      // a dependency between this value and the containing source so that when\n      // the containing source is modified these results will be invalidated.\n      Source source = target.source;\n      return <String, TaskInput>{\n        '-': DART_SCRIPTS.of(source),\n        MODIFICATION_TIME_INPUT: MODIFICATION_TIME.of(source)\n      };\n    }\n    throw new AnalysisException(\n        'Cannot build inputs for a ${target.runtimeType}');\n  }\n\n  /**\n   * Create a [ScanDartTask] based on the given [target] in the given [context].\n   */\n  static ScanDartTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new ScanDartTask(context, target);\n  }\n\n  /**\n   * Return an indication of how suitable this task is for the given [target].\n   */\n  static TaskSuitability suitabilityFor(AnalysisTarget target) {\n    if (target is Source) {\n      if (target.shortName.endsWith(AnalysisEngine.SUFFIX_DART)) {\n        return TaskSuitability.HIGHEST;\n      }\n      return TaskSuitability.LOWEST;\n    } else if (target is DartScript) {\n      return TaskSuitability.HIGHEST;\n    }\n    return TaskSuitability.NONE;\n  }\n}\n\n/**\n * A task that builds [STRONG_MODE_ERRORS] for a unit.  Also builds\n * [RESOLVED_UNIT] for a unit.\n */\nclass StrongModeVerifyUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [RESOLVED_UNIT12] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor(\n      'StrongModeVerifyUnitTask', createTask, buildInputs, <ResultDescriptor>[\n    STRONG_MODE_ERRORS,\n    CREATED_RESOLVED_UNIT,\n    RESOLVED_UNIT\n  ]);\n\n  StrongModeVerifyUnitTask(\n      InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    //\n    // Prepare inputs.\n    //\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    AnalysisOptionsImpl options = context.analysisOptions;\n    if (options.strongMode) {\n      CodeChecker checker = new CodeChecker(\n          typeProvider,\n          new StrongTypeSystemImpl(typeProvider,\n              implicitCasts: options.implicitCasts,\n              declarationCasts: options.declarationCasts,\n              nonnullableTypes: options.nonnullableTypes),\n          errorListener,\n          options);\n      checker.visitCompilationUnit(unit);\n    }\n    //\n    // Record outputs.\n    //\n    outputs[STRONG_MODE_ERRORS] = getUniqueErrors(errorListener.errors);\n    outputs[CREATED_RESOLVED_UNIT] = true;\n    outputs[RESOLVED_UNIT] = unit;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      UNIT_INPUT: RESOLVED_UNIT12.of(unit),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request),\n    };\n  }\n\n  /**\n   * Create a [StrongModeVerifyUnitTask] based on the given [target] in\n   * the given [context].\n   */\n  static StrongModeVerifyUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new StrongModeVerifyUnitTask(context, target);\n  }\n}\n\n/**\n * A task that builds [VERIFY_ERRORS] for a unit.\n */\nclass VerifyUnitTask extends SourceBasedAnalysisTask {\n  /**\n   * The name of the [PENDING_ERRORS] input.\n   */\n  static const String PENDING_ERRORS_INPUT = 'PENDING_ERRORS_INPUT';\n\n  /**\n   * The name of the input of a mapping from [REFERENCED_SOURCES] to their\n   * [MODIFICATION_TIME]s.\n   */\n  static const String REFERENCED_SOURCE_MODIFICATION_TIME_MAP_INPUT =\n      'REFERENCED_SOURCE_MODIFICATION_TIME_MAP_INPUT';\n\n  /**\n   * The name of the [TYPE_PROVIDER] input.\n   */\n  static const String TYPE_PROVIDER_INPUT = 'TYPE_PROVIDER_INPUT';\n\n  /**\n   * The name of the [RESOLVED_UNIT] input.\n   */\n  static const String UNIT_INPUT = 'UNIT_INPUT';\n\n  /**\n   * The task descriptor describing this kind of task.\n   */\n  static final TaskDescriptor DESCRIPTOR = new TaskDescriptor('VerifyUnitTask',\n      createTask, buildInputs, <ResultDescriptor>[VERIFY_ERRORS]);\n\n  /**\n   * The [ErrorReporter] to report errors to.\n   */\n  ErrorReporter errorReporter;\n\n  /**\n   * The mapping from the current library referenced sources to their\n   * modification times.\n   */\n  Map<Source, int> sourceTimeMap;\n\n  VerifyUnitTask(InternalAnalysisContext context, AnalysisTarget target)\n      : super(context, target);\n\n  @override\n  TaskDescriptor get descriptor => DESCRIPTOR;\n\n  @override\n  void internalPerform() {\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    Source source = getRequiredSource();\n    errorReporter = new ErrorReporter(errorListener, source);\n    //\n    // Prepare inputs.\n    //\n    CompilationUnit unit = getRequiredInput(UNIT_INPUT);\n    CompilationUnitElement unitElement = unit.element;\n    LibraryElement libraryElement = unitElement.library;\n    if (libraryElement == null) {\n      throw new AnalysisException(\n          'VerifyUnitTask verifying a unit with no library: '\n          '${unitElement.source.fullName}');\n    }\n    List<PendingError> pendingErrors = getRequiredInput(PENDING_ERRORS_INPUT);\n    sourceTimeMap =\n        getRequiredInput(REFERENCED_SOURCE_MODIFICATION_TIME_MAP_INPUT);\n    TypeProvider typeProvider = getRequiredInput(TYPE_PROVIDER_INPUT);\n    //\n    // Validate the directives.\n    //\n    validateDirectives(unit);\n    //\n    // Use the ConstantVerifier to compute errors.\n    //\n    ConstantVerifier constantVerifier = new ConstantVerifier(\n        errorReporter, libraryElement, typeProvider, context.declaredVariables);\n    unit.accept(constantVerifier);\n    //\n    // Use the ErrorVerifier to compute errors.\n    //\n    ErrorVerifier errorVerifier = new ErrorVerifier(\n        errorReporter,\n        libraryElement,\n        typeProvider,\n        new InheritanceManager(libraryElement),\n        context.analysisOptions.enableSuperMixins,\n        disableConflictingGenericsCheck: true);\n    unit.accept(errorVerifier);\n    //\n    // Convert the pending errors into actual errors.\n    //\n    for (PendingError pendingError in pendingErrors) {\n      errorListener.onError(pendingError.toAnalysisError());\n    }\n    //\n    // Record outputs.\n    //\n    outputs[VERIFY_ERRORS] = getUniqueErrors(errorListener.errors);\n  }\n\n  /**\n   * Check each directive in the given [unit] to see if the referenced source\n   * exists and report an error if it does not.\n   */\n  void validateDirectives(CompilationUnit unit) {\n    NodeList<Directive> directives = unit.directives;\n    int length = directives.length;\n    for (int i = 0; i < length; i++) {\n      Directive directive = directives[i];\n      if (directive is UriBasedDirective) {\n        validateReferencedSource(directive);\n      }\n    }\n  }\n\n  /**\n   * Check the given [directive] to see if the referenced source exists and\n   * report an error if it does not.\n   */\n  void validateReferencedSource(UriBasedDirectiveImpl directive) {\n    if (directive is NamespaceDirectiveImpl) {\n      for (Configuration configuration in directive.configurations) {\n        Source source = configuration.uriSource;\n        StringLiteral uriLiteral = configuration.uri;\n        String uriContent = uriLiteral?.stringValue?.trim();\n        if (source != null) {\n          int modificationTime = sourceTimeMap[source] ?? -1;\n          if (modificationTime >= 0) {\n            continue;\n          }\n        } else {\n          // Don't report errors already reported by ParseDartTask.resolveDirective\n          if (UriBasedDirectiveImpl.validateUri(\n                  directive is ImportDirective, uriLiteral, uriContent) !=\n              null) {\n            continue;\n          }\n        }\n        CompileTimeErrorCode errorCode =\n            CompileTimeErrorCode.URI_DOES_NOT_EXIST;\n        if (_isGenerated(source)) {\n          errorCode = CompileTimeErrorCode.URI_HAS_NOT_BEEN_GENERATED;\n        }\n        errorReporter.reportErrorForNode(errorCode, uriLiteral, [uriContent]);\n      }\n    }\n    Source source = directive.uriSource;\n    if (source != null) {\n      int modificationTime = sourceTimeMap[source] ?? -1;\n      if (modificationTime >= 0) {\n        return;\n      }\n    } else {\n      // Don't report errors already reported by ParseDartTask.resolveDirective\n      if (directive.validate() != null) {\n        return;\n      }\n    }\n    StringLiteral uriLiteral = directive.uri;\n    CompileTimeErrorCode errorCode = CompileTimeErrorCode.URI_DOES_NOT_EXIST;\n    if (_isGenerated(source)) {\n      errorCode = CompileTimeErrorCode.URI_HAS_NOT_BEEN_GENERATED;\n    }\n    errorReporter\n        .reportErrorForNode(errorCode, uriLiteral, [directive.uriContent]);\n  }\n\n  /**\n   * Return `true` if the given [source] refers to a file that is assumed to be\n   * generated.\n   */\n  bool _isGenerated(Source source) {\n    if (source == null) {\n      return false;\n    }\n    // TODO(brianwilkerson) Generalize this mechanism.\n    const List<String> suffixes = const <String>[\n      '.g.dart',\n      '.pb.dart',\n      '.pbenum.dart',\n      '.pbserver.dart',\n      '.pbjson.dart',\n      '.template.dart'\n    ];\n    String fullName = source.fullName;\n    for (String suffix in suffixes) {\n      if (fullName.endsWith(suffix)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return a map from the names of the inputs of this kind of task to the task\n   * input descriptors describing those inputs for a task with the\n   * given [target].\n   */\n  static Map<String, TaskInput> buildInputs(AnalysisTarget target) {\n    LibrarySpecificUnit unit = target;\n    return <String, TaskInput>{\n      'thisLibraryClosureIsReady': READY_RESOLVED_UNIT.of(unit.library),\n      UNIT_INPUT: RESOLVED_UNIT.of(unit),\n      REFERENCED_SOURCE_MODIFICATION_TIME_MAP_INPUT:\n          REFERENCED_SOURCES.of(unit.library).toMapOf(MODIFICATION_TIME),\n      PENDING_ERRORS_INPUT: PENDING_ERRORS.of(unit),\n      'requiredConstants': REQUIRED_CONSTANTS.of(unit).toListOf(CONSTANT_VALUE),\n      TYPE_PROVIDER_INPUT: TYPE_PROVIDER.of(AnalysisContextTarget.request)\n    };\n  }\n\n  /**\n   * Create a [VerifyUnitTask] based on the given [target] in\n   * the given [context].\n   */\n  static VerifyUnitTask createTask(\n      AnalysisContext context, AnalysisTarget target) {\n    return new VerifyUnitTask(context, target);\n  }\n}\n\n/**\n * A [TaskInput] whose value is a list of library sources exported directly\n * or indirectly by the target [Source].\n *\n * [resultDescriptor] is the type of result which should be produced for each\n * target [Source].\n */\nclass _ExportSourceClosureTaskInput extends TaskInputImpl<List<Source>> {\n  final Source target;\n  final ResultDescriptor resultDescriptor;\n\n  _ExportSourceClosureTaskInput(this.target, this.resultDescriptor);\n\n  @override\n  TaskInputBuilder<List<Source>> createBuilder() =>\n      new _SourceClosureTaskInputBuilder(\n          target, _SourceClosureKind.EXPORT, resultDescriptor);\n}\n\n/**\n * A [TaskInput] whose value is a list of library sources imported directly\n * or indirectly by the target [Source].\n *\n * [resultDescriptor] is the type of result which should be produced for each\n * target [Source].\n */\nclass _ImportSourceClosureTaskInput extends TaskInputImpl<List<Source>> {\n  final Source target;\n  final ResultDescriptor resultDescriptor;\n\n  _ImportSourceClosureTaskInput(this.target, this.resultDescriptor);\n\n  @override\n  TaskInputBuilder<List<Source>> createBuilder() =>\n      new _SourceClosureTaskInputBuilder(\n          target, _SourceClosureKind.IMPORT, resultDescriptor);\n}\n\n/**\n * An object holding either the name or the source associated with a part-of\n * directive.\n */\nclass _NameOrSource {\n  final String name;\n\n  final Source source;\n\n  _NameOrSource(this.name, this.source);\n}\n\n/**\n * The kind of the source closure to build.\n */\nenum _SourceClosureKind { IMPORT, EXPORT, IMPORT_EXPORT }\n\n/**\n * A [TaskInputBuilder] to build values for [_ImportSourceClosureTaskInput].\n */\nclass _SourceClosureTaskInputBuilder implements TaskInputBuilder<List<Source>> {\n  final _SourceClosureKind kind;\n  final Set<LibraryElement> _libraries = new HashSet<LibraryElement>();\n  final List<Source> _newSources = <Source>[];\n\n  @override\n  final ResultDescriptor currentResult;\n\n  Source currentTarget;\n\n  _SourceClosureTaskInputBuilder(\n      Source librarySource, this.kind, this.currentResult) {\n    _newSources.add(librarySource);\n  }\n\n  @override\n  void set currentValue(Object value) {\n    LibraryElement library = value;\n    if (_libraries.add(library)) {\n      if (kind == _SourceClosureKind.IMPORT ||\n          kind == _SourceClosureKind.IMPORT_EXPORT) {\n        List<ImportElement> imports = library.imports;\n        int length = imports.length;\n        for (int i = 0; i < length; i++) {\n          ImportElement importElement = imports[i];\n          Source importedSource = importElement.importedLibrary?.source;\n          if (importedSource != null) {\n            _newSources.add(importedSource);\n          }\n        }\n      }\n      if (kind == _SourceClosureKind.EXPORT ||\n          kind == _SourceClosureKind.IMPORT_EXPORT) {\n        List<ExportElement> exports = library.exports;\n        int length = exports.length;\n        for (int i = 0; i < length; i++) {\n          ExportElement exportElement = exports[i];\n          Source exportedSource = exportElement.exportedLibrary?.source;\n          if (exportedSource != null) {\n            _newSources.add(exportedSource);\n          }\n        }\n      }\n    }\n  }\n\n  @override\n  bool get flushOnAccess => false;\n\n  @override\n  List<Source> get inputValue {\n    return _libraries.map((LibraryElement library) => library.source).toList();\n  }\n\n  @override\n  void currentValueNotAvailable() {\n    // Nothing needs to be done.  moveNext() will simply go on to the next new\n    // source.\n  }\n\n  @override\n  bool moveNext() {\n    if (_newSources.isEmpty) {\n      return false;\n    }\n    currentTarget = _newSources.removeLast();\n    return true;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/src/task/dart.dart	(date 1533041846000)
+++ lib/src/task/dart.dart	(date 1533825325000)
@@ -50,6 +50,8 @@
 import 'package:analyzer/src/task/strong/checker.dart';
 import 'package:analyzer/src/task/strong_mode.dart';
 
+const EXAMINED_ASSET_NAME = 'date_picker.template.dart';
+
 /**
  * The [ResultCachingPolicy] for ASTs.
  */
@@ -1062,12 +1064,18 @@
     //
     // Build or reuse CompilationUnitElement.
     //
+    if (target.librarySource.source.shortName == EXAMINED_ASSET_NAME) {
+      print('!!! Task1 is going to execute for $target');
+    }
     if (element == null) {
       CompilationUnitBuilder builder = new CompilationUnitBuilder();
       element = builder.buildCompilationUnit(
           source, unit, librarySpecificUnit.library);
       (element as CompilationUnitElementImpl).lineInfo = lineInfo;
     } else {
+      if (element.name == EXAMINED_ASSET_NAME) {
+        print('!!! COMPILATION_UNIT_ELEMENT is available in cache for $unit');
+      }
       new DeclarationResolver().resolve(unit, element);
     }
     //
@@ -5117,6 +5125,9 @@
     //
     // Resolve TypeName nodes.
     //
+    if (unitElement.name == EXAMINED_ASSET_NAME) {
+      print('!!!! Task2 is going to execute for ${unitElement.name}');
+    }
     RecordingErrorListener errorListener = new RecordingErrorListener();
     TypeResolverVisitor visitor = new TypeResolverVisitor(
         library, unitElement.source, typeProvider, errorListener);
Index: lib/src/generated/resolver.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary analyzer.src.generated.resolver;\n\nimport 'dart:collection';\n\nimport 'package:analyzer/dart/ast/ast.dart';\nimport 'package:analyzer/dart/ast/ast_factory.dart';\nimport 'package:analyzer/dart/ast/standard_resolution_map.dart';\nimport 'package:analyzer/dart/ast/token.dart';\nimport 'package:analyzer/dart/ast/visitor.dart';\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/type.dart';\nimport 'package:analyzer/error/error.dart';\nimport 'package:analyzer/error/listener.dart';\nimport 'package:analyzer/exception/exception.dart';\nimport 'package:analyzer/src/dart/ast/ast.dart';\nimport 'package:analyzer/src/dart/ast/ast_factory.dart';\nimport 'package:analyzer/src/dart/ast/token.dart';\nimport 'package:analyzer/src/dart/ast/utilities.dart';\nimport 'package:analyzer/src/dart/element/element.dart';\nimport 'package:analyzer/src/dart/element/member.dart' show ConstructorMember;\nimport 'package:analyzer/src/dart/element/type.dart';\nimport 'package:analyzer/src/dart/resolver/inheritance_manager.dart';\nimport 'package:analyzer/src/dart/resolver/scope.dart';\nimport 'package:analyzer/src/error/codes.dart';\nimport 'package:analyzer/src/generated/constant.dart';\nimport 'package:analyzer/src/generated/element_resolver.dart';\nimport 'package:analyzer/src/generated/engine.dart';\nimport 'package:analyzer/src/generated/error_verifier.dart';\nimport 'package:analyzer/src/generated/source.dart';\nimport 'package:analyzer/src/generated/static_type_analyzer.dart';\nimport 'package:analyzer/src/generated/testing/element_factory.dart';\nimport 'package:analyzer/src/generated/type_system.dart';\nimport 'package:path/path.dart' as path;\n\nexport 'package:analyzer/src/dart/resolver/inheritance_manager.dart';\nexport 'package:analyzer/src/dart/resolver/scope.dart';\nexport 'package:analyzer/src/generated/type_system.dart';\n\n/**\n * A visitor that will re-write an AST to support the optional `new` and `const`\n * feature.\n */\nclass AstRewriteVisitor extends ScopedVisitor {\n  final bool addConstKeyword;\n  final TypeSystem typeSystem;\n\n  /**\n   * Initialize a newly created visitor.\n   */\n  AstRewriteVisitor(\n      this.typeSystem,\n      LibraryElement definingLibrary,\n      Source source,\n      TypeProvider typeProvider,\n      AnalysisErrorListener errorListener,\n      {Scope nameScope,\n      this.addConstKeyword: false})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope);\n\n  @override\n  Object visitMethodInvocation(MethodInvocation node) {\n    super.visitMethodInvocation(node);\n\n    SimpleIdentifier methodName = node.methodName;\n    if (methodName.isSynthetic) {\n      // This isn't a constructor invocation because the method name is\n      // synthetic.\n      return null;\n    }\n\n    Expression target = node.target;\n    if (target == null) {\n      // Possible cases: C() or C<>()\n      if (node.realTarget != null) {\n        // This isn't a constructor invocation because it's in a cascade.\n        return null;\n      }\n      Element element = nameScope.lookup(methodName, definingLibrary);\n      if (element is ClassElement) {\n        AstFactory astFactory = new AstFactoryImpl();\n        TypeName typeName = astFactory.typeName(methodName, node.typeArguments);\n        ConstructorName constructorName =\n            astFactory.constructorName(typeName, null, null);\n        InstanceCreationExpression instanceCreationExpression =\n            astFactory.instanceCreationExpression(\n                _getKeyword(node), constructorName, node.argumentList);\n        InterfaceType type = _getType(element, node.typeArguments);\n        ConstructorElement constructorElement =\n            type.lookUpConstructor(null, definingLibrary);\n        methodName.staticElement = element;\n        methodName.staticType = type;\n        typeName.type = type;\n        constructorName.staticElement = constructorElement;\n        instanceCreationExpression.staticType = type;\n        instanceCreationExpression.staticElement = constructorElement;\n        NodeReplacer.replace(node, instanceCreationExpression);\n      }\n    } else if (target is SimpleIdentifier) {\n      // Possible cases: C.n(), p.C() or p.C<>()\n      if (node.operator.type == TokenType.QUESTION_PERIOD) {\n        // This isn't a constructor invocation because a null aware operator is\n        // being used.\n      }\n      Element element = nameScope.lookup(target, definingLibrary);\n      if (element is ClassElement) {\n        // Possible case: C.n()\n        var constructorElement = element.getNamedConstructor(methodName.name);\n        if (constructorElement != null) {\n          AstFactory astFactory = new AstFactoryImpl();\n          TypeName typeName = astFactory.typeName(target, node.typeArguments);\n          ConstructorName constructorName =\n              astFactory.constructorName(typeName, node.operator, methodName);\n          InstanceCreationExpression instanceCreationExpression =\n              astFactory.instanceCreationExpression(\n                  _getKeyword(node), constructorName, node.argumentList);\n          InterfaceType type = _getType(element, node.typeArguments);\n          constructorElement =\n              type.lookUpConstructor(methodName.name, definingLibrary);\n          methodName.staticElement = element;\n          methodName.staticType = type;\n          typeName.type = type;\n          constructorName.staticElement = constructorElement;\n          instanceCreationExpression.staticType = type;\n          instanceCreationExpression.staticElement = constructorElement;\n          NodeReplacer.replace(node, instanceCreationExpression);\n        }\n      } else if (element is PrefixElement) {\n        // Possible cases: p.C() or p.C<>()\n        AstFactory astFactory = new AstFactoryImpl();\n        Identifier identifier = astFactory.prefixedIdentifier(\n            astFactory.simpleIdentifier(target.token),\n            null,\n            astFactory.simpleIdentifier(methodName.token));\n        Element prefixedElement = nameScope.lookup(identifier, definingLibrary);\n        if (prefixedElement is ClassElement) {\n          TypeName typeName = astFactory.typeName(\n              astFactory.prefixedIdentifier(target, node.operator, methodName),\n              node.typeArguments);\n          ConstructorName constructorName =\n              astFactory.constructorName(typeName, null, null);\n          InstanceCreationExpression instanceCreationExpression =\n              astFactory.instanceCreationExpression(\n                  _getKeyword(node), constructorName, node.argumentList);\n          InterfaceType type = _getType(prefixedElement, node.typeArguments);\n          ConstructorElement constructorElement =\n              type.lookUpConstructor(null, definingLibrary);\n          methodName.staticElement = element;\n          methodName.staticType = type;\n          typeName.type = type;\n          constructorName.staticElement = constructorElement;\n          instanceCreationExpression.staticType = type;\n          instanceCreationExpression.staticElement = constructorElement;\n          NodeReplacer.replace(node, instanceCreationExpression);\n        }\n      }\n    } else if (target is PrefixedIdentifier) {\n      // Possible case: p.C.n()\n      Element prefixElement = nameScope.lookup(target.prefix, definingLibrary);\n      if (prefixElement is PrefixElement) {\n        Element element = nameScope.lookup(target, definingLibrary);\n        if (element is ClassElement) {\n          var constructorElement = element.getNamedConstructor(methodName.name);\n          if (constructorElement != null) {\n            AstFactory astFactory = new AstFactoryImpl();\n            TypeName typeName = astFactory.typeName(target, node.typeArguments);\n            ConstructorName constructorName =\n                astFactory.constructorName(typeName, node.operator, methodName);\n            InstanceCreationExpression instanceCreationExpression =\n                astFactory.instanceCreationExpression(\n                    _getKeyword(node), constructorName, node.argumentList);\n            InterfaceType type = _getType(element, node.typeArguments);\n            constructorElement =\n                type.lookUpConstructor(methodName.name, definingLibrary);\n            methodName.staticElement = element;\n            methodName.staticType = type;\n            typeName.type = type;\n            constructorName.staticElement = constructorElement;\n            instanceCreationExpression.staticType = type;\n            instanceCreationExpression.staticElement = constructorElement;\n            NodeReplacer.replace(node, instanceCreationExpression);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the token that should be used in the [InstanceCreationExpression]\n   * that corresponds to the given invocation [node].\n   */\n  Token _getKeyword(MethodInvocation node) {\n    return addConstKeyword\n        ? new KeywordToken(Keyword.CONST, node.offset)\n        : null;\n  }\n\n  /**\n   * Return the type of the given class [element] after substituting any type\n   * arguments from the list of [typeArguments] for the class' type parameters.\n   */\n  DartType _getType(ClassElement element, TypeArgumentList typeArguments) {\n    DartType type = element.type;\n    List<TypeParameterElement> typeParameters = element.typeParameters;\n    if (typeArguments != null &&\n        typeParameters != null &&\n        typeArguments.arguments.length == typeParameters.length) {\n      List<DartType> argumentTypes = typeArguments.arguments\n          .map((TypeAnnotation argument) => argument.type)\n          .toList();\n      List<DartType> parameterTypes = typeParameters\n          .map((TypeParameterElement parameter) => parameter.type)\n          .toList();\n      type = type.substitute2(argumentTypes, parameterTypes);\n    } else if (typeArguments == null && typeParameters != null) {\n      type = typeSystem.instantiateToBounds(type);\n    }\n    return type;\n  }\n}\n\n/**\n * Instances of the class `BestPracticesVerifier` traverse an AST structure looking for\n * violations of Dart best practices.\n */\nclass BestPracticesVerifier extends RecursiveAstVisitor<Object> {\n//  static String _HASHCODE_GETTER_NAME = \"hashCode\";\n\n  static String _NULL_TYPE_NAME = \"Null\";\n\n  static String _TO_INT_METHOD_NAME = \"toInt\";\n\n  static final _testDir = '${path.separator}test${path.separator}';\n\n  static final _testingDir = '${path.separator}testing${path.separator}';\n\n  /**\n   * The class containing the AST nodes being visited, or `null` if we are not in the scope of\n   * a class.\n   */\n  ClassElementImpl _enclosingClass;\n\n  /**\n   * A flag indicating whether a surrounding member (compilation unit or class)\n   * is deprecated.\n   */\n  bool inDeprecatedMember;\n\n  /**\n   * The error reporter by which errors will be reported.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * The type [Null].\n   */\n  final InterfaceType _nullType;\n\n  /**\n   * The type Future<Null>, which is needed for determining whether it is safe\n   * to have a bare \"return;\" in an async method.\n   */\n  final InterfaceType _futureNullType;\n\n  /**\n   * The type system primitives\n   */\n  TypeSystem _typeSystem;\n\n  /**\n   * The current library\n   */\n  LibraryElement _currentLibrary;\n\n  /**\n   * The inheritance manager used to find overridden methods.\n   */\n  InheritanceManager _manager;\n\n  /**\n   * Create a new instance of the [BestPracticesVerifier].\n   *\n   * @param errorReporter the error reporter\n   */\n  BestPracticesVerifier(this._errorReporter, TypeProvider typeProvider,\n      this._currentLibrary, this._manager,\n      {TypeSystem typeSystem})\n      : _nullType = typeProvider.nullType,\n        _futureNullType = typeProvider.futureNullType,\n        _typeSystem = typeSystem ?? new TypeSystemImpl(typeProvider) {\n    inDeprecatedMember = _currentLibrary.hasDeprecated;\n  }\n\n  @override\n  Object visitAnnotation(Annotation node) {\n    ElementAnnotation element =\n        resolutionMap.elementAnnotationForAnnotation(node);\n    if (element?.isFactory == true) {\n      AstNode parent = node.parent;\n      if (parent is MethodDeclaration) {\n        _checkForInvalidFactory(parent);\n      } else {\n        _errorReporter\n            .reportErrorForNode(HintCode.INVALID_FACTORY_ANNOTATION, node, []);\n      }\n    } else if (element?.isImmutable == true) {\n      AstNode parent = node.parent;\n      if (parent is! ClassDeclaration) {\n        _errorReporter.reportErrorForNode(\n            HintCode.INVALID_IMMUTABLE_ANNOTATION, node, []);\n      }\n    }\n    return super.visitAnnotation(node);\n  }\n\n  @override\n  Object visitArgumentList(ArgumentList node) {\n    for (Expression argument in node.arguments) {\n      ParameterElement parameter = argument.bestParameterElement;\n      if (parameter?.isOptionalPositional == true) {\n        _checkForDeprecatedMemberUse(parameter, argument);\n      }\n    }\n    _checkForArgumentTypesNotAssignableInList(node);\n    return super.visitArgumentList(node);\n  }\n\n  @override\n  Object visitAsExpression(AsExpression node) {\n    _checkForUnnecessaryCast(node);\n    return super.visitAsExpression(node);\n  }\n\n  @override\n  Object visitAssignmentExpression(AssignmentExpression node) {\n    TokenType operatorType = node.operator.type;\n    if (operatorType == TokenType.EQ) {\n      _checkForInvalidAssignment(node.leftHandSide, node.rightHandSide);\n    } else {\n      _checkForDeprecatedMemberUse(node.bestElement, node);\n    }\n    return super.visitAssignmentExpression(node);\n  }\n\n  @override\n  Object visitBinaryExpression(BinaryExpression node) {\n    _checkForDivisionOptimizationHint(node);\n    _checkForDeprecatedMemberUse(node.bestElement, node);\n    return super.visitBinaryExpression(node);\n  }\n\n  @override\n  Object visitClassDeclaration(ClassDeclaration node) {\n    ClassElementImpl outerClass = _enclosingClass;\n    bool wasInDeprecatedMember = inDeprecatedMember;\n    ClassElement element = AbstractClassElementImpl.getImpl(node.element);\n    if (element != null && element.hasDeprecated) {\n      inDeprecatedMember = true;\n    }\n    try {\n      _enclosingClass = element;\n      // Commented out until we decide that we want this hint in the analyzer\n      //    checkForOverrideEqualsButNotHashCode(node);\n      _checkForImmutable(node);\n      return super.visitClassDeclaration(node);\n    } finally {\n      _enclosingClass = outerClass;\n      inDeprecatedMember = wasInDeprecatedMember;\n    }\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    if (resolutionMap.elementDeclaredByConstructorDeclaration(node).isFactory) {\n      if (node.body is BlockFunctionBody) {\n        // Check the block for a return statement, if not, create the hint.\n        if (!ExitDetector.exits(node.body)) {\n          _errorReporter.reportErrorForNode(\n              HintCode.MISSING_RETURN, node, [node.returnType.name]);\n        }\n      }\n    }\n    return super.visitConstructorDeclaration(node);\n  }\n\n  @override\n  Object visitExportDirective(ExportDirective node) {\n    _checkForDeprecatedMemberUse(node.uriElement, node);\n    return super.visitExportDirective(node);\n  }\n\n  @override\n  Object visitFormalParameterList(FormalParameterList node) {\n    _checkRequiredParameter(node);\n    return super.visitFormalParameterList(node);\n  }\n\n  @override\n  Object visitFunctionDeclaration(FunctionDeclaration node) {\n    bool wasInDeprecatedMember = inDeprecatedMember;\n    ExecutableElement element = node.element;\n    if (element != null && element.hasDeprecated) {\n      inDeprecatedMember = true;\n    }\n    try {\n      _checkForMissingReturn(node.returnType, node.functionExpression.body);\n      return super.visitFunctionDeclaration(node);\n    } finally {\n      inDeprecatedMember = wasInDeprecatedMember;\n    }\n  }\n\n  @override\n  Object visitImportDirective(ImportDirective node) {\n    _checkForDeprecatedMemberUse(node.uriElement, node);\n    ImportElement importElement = node.element;\n    if (importElement != null && importElement.isDeferred) {\n      _checkForLoadLibraryFunction(node, importElement);\n    }\n    return super.visitImportDirective(node);\n  }\n\n  @override\n  Object visitIndexExpression(IndexExpression node) {\n    _checkForDeprecatedMemberUse(node.bestElement, node);\n    return super.visitIndexExpression(node);\n  }\n\n  @override\n  Object visitInstanceCreationExpression(InstanceCreationExpression node) {\n    _checkForDeprecatedMemberUse(node.staticElement, node);\n    return super.visitInstanceCreationExpression(node);\n  }\n\n  @override\n  Object visitIsExpression(IsExpression node) {\n    _checkAllTypeChecks(node);\n    return super.visitIsExpression(node);\n  }\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    bool wasInDeprecatedMember = inDeprecatedMember;\n    ExecutableElement element = node.element;\n    if (element != null && element.hasDeprecated) {\n      inDeprecatedMember = true;\n    }\n    try {\n      // This was determined to not be a good hint, see: dartbug.com/16029\n      //checkForOverridingPrivateMember(node);\n      _checkForMissingReturn(node.returnType, node.body);\n      _checkForUnnecessaryNoSuchMethod(node);\n      return super.visitMethodDeclaration(node);\n    } finally {\n      inDeprecatedMember = wasInDeprecatedMember;\n    }\n  }\n\n  @override\n  Object visitMethodInvocation(MethodInvocation node) {\n    Expression realTarget = node.realTarget;\n    _checkForAbstractSuperMemberReference(realTarget, node.methodName);\n    _checkForNullAwareHints(node, node.operator);\n    DartType staticInvokeType = node.staticInvokeType;\n    Element callElement = staticInvokeType?.element;\n    if (callElement is MethodElement &&\n        callElement.name == FunctionElement.CALL_METHOD_NAME) {\n      _checkForDeprecatedMemberUse(callElement, node);\n    }\n    return super.visitMethodInvocation(node);\n  }\n\n  @override\n  Object visitPostfixExpression(PostfixExpression node) {\n    _checkForDeprecatedMemberUse(node.bestElement, node);\n    return super.visitPostfixExpression(node);\n  }\n\n  @override\n  Object visitPrefixExpression(PrefixExpression node) {\n    _checkForDeprecatedMemberUse(node.bestElement, node);\n    return super.visitPrefixExpression(node);\n  }\n\n  @override\n  Object visitPropertyAccess(PropertyAccess node) {\n    Expression realTarget = node.realTarget;\n    _checkForAbstractSuperMemberReference(realTarget, node.propertyName);\n    _checkForNullAwareHints(node, node.operator);\n    return super.visitPropertyAccess(node);\n  }\n\n  @override\n  Object visitRedirectingConstructorInvocation(\n      RedirectingConstructorInvocation node) {\n    _checkForDeprecatedMemberUse(node.staticElement, node);\n    return super.visitRedirectingConstructorInvocation(node);\n  }\n\n  @override\n  Object visitSimpleIdentifier(SimpleIdentifier node) {\n    _checkForDeprecatedMemberUseAtIdentifier(node);\n    _checkForInvalidAccess(node);\n    return super.visitSimpleIdentifier(node);\n  }\n\n  @override\n  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {\n    _checkForDeprecatedMemberUse(node.staticElement, node);\n    return super.visitSuperConstructorInvocation(node);\n  }\n\n  @override\n  Object visitVariableDeclaration(VariableDeclaration node) {\n    _checkForInvalidAssignment(node.name, node.initializer);\n    return super.visitVariableDeclaration(node);\n  }\n\n  /**\n   * Check for the passed is expression for the unnecessary type check hint codes as well as null\n   * checks expressed using an is expression.\n   *\n   * @param node the is expression to check\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.TYPE_CHECK_IS_NOT_NULL], [HintCode.TYPE_CHECK_IS_NULL],\n   * [HintCode.UNNECESSARY_TYPE_CHECK_TRUE], and\n   * [HintCode.UNNECESSARY_TYPE_CHECK_FALSE].\n   */\n  bool _checkAllTypeChecks(IsExpression node) {\n    Expression expression = node.expression;\n    TypeAnnotation typeName = node.type;\n    DartType lhsType = expression.staticType;\n    DartType rhsType = typeName.type;\n    if (lhsType == null || rhsType == null) {\n      return false;\n    }\n    String rhsNameStr = typeName is TypeName ? typeName.name.name : null;\n    // if x is dynamic\n    if (rhsType.isDynamic && rhsNameStr == Keyword.DYNAMIC.lexeme) {\n      if (node.notOperator == null) {\n        // the is case\n        _errorReporter.reportErrorForNode(\n            HintCode.UNNECESSARY_TYPE_CHECK_TRUE, node);\n      } else {\n        // the is not case\n        _errorReporter.reportErrorForNode(\n            HintCode.UNNECESSARY_TYPE_CHECK_FALSE, node);\n      }\n      return true;\n    }\n    Element rhsElement = rhsType.element;\n    LibraryElement libraryElement = rhsElement?.library;\n    if (libraryElement != null && libraryElement.isDartCore) {\n      // if x is Object or null is Null\n      if (rhsType.isObject ||\n          (expression is NullLiteral && rhsNameStr == _NULL_TYPE_NAME)) {\n        if (node.notOperator == null) {\n          // the is case\n          _errorReporter.reportErrorForNode(\n              HintCode.UNNECESSARY_TYPE_CHECK_TRUE, node);\n        } else {\n          // the is not case\n          _errorReporter.reportErrorForNode(\n              HintCode.UNNECESSARY_TYPE_CHECK_FALSE, node);\n        }\n        return true;\n      } else if (rhsNameStr == _NULL_TYPE_NAME) {\n        if (node.notOperator == null) {\n          // the is case\n          _errorReporter.reportErrorForNode(HintCode.TYPE_CHECK_IS_NULL, node);\n        } else {\n          // the is not case\n          _errorReporter.reportErrorForNode(\n              HintCode.TYPE_CHECK_IS_NOT_NULL, node);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void _checkForAbstractSuperMemberReference(\n      Expression target, SimpleIdentifier name) {\n    if (target is SuperExpression &&\n        !_currentLibrary.context.analysisOptions.enableSuperMixins) {\n      Element element = name.staticElement;\n      if (element is ExecutableElement && element.isAbstract) {\n        ExecutableElement concrete = null;\n        if (element.kind == ElementKind.METHOD) {\n          concrete = _enclosingClass.lookUpInheritedConcreteMethod(\n              element.displayName, _currentLibrary);\n        } else if (element.kind == ElementKind.GETTER) {\n          concrete = _enclosingClass.lookUpInheritedConcreteGetter(\n              element.displayName, _currentLibrary);\n        } else if (element.kind == ElementKind.SETTER) {\n          concrete = _enclosingClass.lookUpInheritedConcreteSetter(\n              element.displayName, _currentLibrary);\n        }\n        if (concrete == null) {\n          _errorReporter.reportTypeErrorForNode(\n              HintCode.ABSTRACT_SUPER_MEMBER_REFERENCE,\n              name,\n              [element.kind.displayName, name.name]);\n        }\n      }\n    }\n  }\n\n  /**\n   * This verifies that the passed expression can be assigned to its corresponding parameters.\n   *\n   * This method corresponds to ErrorVerifier.checkForArgumentTypeNotAssignable.\n   *\n   * TODO (jwren) In the ErrorVerifier there are other warnings that we could have a corresponding\n   * hint for: see other callers of ErrorVerifier.checkForArgumentTypeNotAssignable(..).\n   *\n   * @param expression the expression to evaluate\n   * @param expectedStaticType the expected static type of the parameter\n   * @param actualStaticType the actual static type of the argument\n   * @param expectedPropagatedType the expected propagated type of the parameter, may be\n   *          `null`\n   * @param actualPropagatedType the expected propagated type of the parameter, may be `null`\n   * @return `true` if and only if an hint code is generated on the passed node\n   * See [HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE].\n   */\n  bool _checkForArgumentTypeNotAssignable(\n      Expression expression,\n      DartType expectedStaticType,\n      DartType actualStaticType,\n      DartType expectedPropagatedType,\n      DartType actualPropagatedType,\n      ErrorCode hintCode) {\n    //\n    // Warning case: test static type information\n    //\n    if (actualStaticType != null && expectedStaticType != null) {\n      if (!_typeSystem.isAssignableTo(actualStaticType, expectedStaticType)) {\n        // A warning was created in the ErrorVerifier, return false, don't\n        // create a hint when a warning has already been created.\n        return false;\n      }\n    }\n    //\n    // Hint case: test propagated type information\n    //\n    // Compute the best types to use.\n    DartType expectedBestType = expectedPropagatedType ?? expectedStaticType;\n    DartType actualBestType = actualPropagatedType ?? actualStaticType;\n    if (actualBestType != null && expectedBestType != null) {\n      if (!_typeSystem.isAssignableTo(actualBestType, expectedBestType)) {\n        _errorReporter.reportTypeErrorForNode(\n            hintCode, expression, [actualBestType, expectedBestType]);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * This verifies that the passed argument can be assigned to its corresponding parameter.\n   *\n   * This method corresponds to ErrorCode.checkForArgumentTypeNotAssignableForArgument.\n   *\n   * @param argument the argument to evaluate\n   * @return `true` if and only if an hint code is generated on the passed node\n   * See [HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE].\n   */\n  bool _checkForArgumentTypeNotAssignableForArgument(Expression argument) {\n    if (argument == null) {\n      return false;\n    }\n    ParameterElement staticParameterElement = argument.staticParameterElement;\n    DartType staticParameterType = staticParameterElement?.type;\n    ParameterElement propagatedParameterElement =\n        argument.propagatedParameterElement;\n    DartType propagatedParameterType = propagatedParameterElement?.type;\n    return _checkForArgumentTypeNotAssignableWithExpectedTypes(\n        argument,\n        staticParameterType,\n        propagatedParameterType,\n        HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE);\n  }\n\n  /**\n   * This verifies that the passed expression can be assigned to its corresponding parameters.\n   *\n   * This method corresponds to ErrorCode.checkForArgumentTypeNotAssignableWithExpectedTypes.\n   *\n   * @param expression the expression to evaluate\n   * @param expectedStaticType the expected static type\n   * @param expectedPropagatedType the expected propagated type, may be `null`\n   * @return `true` if and only if an hint code is generated on the passed node\n   * See [HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE].\n   */\n  bool _checkForArgumentTypeNotAssignableWithExpectedTypes(\n          Expression expression,\n          DartType expectedStaticType,\n          DartType expectedPropagatedType,\n          ErrorCode errorCode) =>\n      _checkForArgumentTypeNotAssignable(\n          expression,\n          expectedStaticType,\n          expression.staticType,\n          expectedPropagatedType,\n          expression.propagatedType,\n          errorCode);\n\n  /**\n   * This verifies that the passed arguments can be assigned to their corresponding parameters.\n   *\n   * This method corresponds to ErrorCode.checkForArgumentTypesNotAssignableInList.\n   *\n   * @param node the arguments to evaluate\n   * @return `true` if and only if an hint code is generated on the passed node\n   * See [HintCode.ARGUMENT_TYPE_NOT_ASSIGNABLE].\n   */\n  bool _checkForArgumentTypesNotAssignableInList(ArgumentList argumentList) {\n    if (argumentList == null) {\n      return false;\n    }\n    bool problemReported = false;\n    for (Expression argument in argumentList.arguments) {\n      if (_checkForArgumentTypeNotAssignableForArgument(argument)) {\n        problemReported = true;\n      }\n    }\n    return problemReported;\n  }\n\n  /**\n   * Given some [Element], look at the associated metadata and report the use of the member if\n   * it is declared as deprecated.\n   *\n   * @param element some element to check for deprecated use of\n   * @param node the node use for the location of the error\n   * See [HintCode.DEPRECATED_MEMBER_USE].\n   */\n  void _checkForDeprecatedMemberUse(Element element, AstNode node) {\n    bool isDeprecated(Element element) {\n      if (element is PropertyAccessorElement && element.isSynthetic) {\n        // TODO(brianwilkerson) Why isn't this the implementation for PropertyAccessorElement?\n        Element variable = element.variable;\n        if (variable == null) {\n          return false;\n        }\n        return variable.hasDeprecated;\n      }\n      return element.hasDeprecated;\n    }\n\n    bool isLocalParameter(Element element, AstNode node) {\n      if (element is ParameterElement) {\n        ExecutableElement definingFunction = element.enclosingElement;\n        FunctionBody body =\n            node.getAncestor((ancestor) => ancestor is FunctionBody);\n        while (body != null) {\n          ExecutableElement enclosingFunction;\n          AstNode parent = body.parent;\n          if (parent is ConstructorDeclaration) {\n            enclosingFunction = parent.element;\n          } else if (parent is FunctionExpression) {\n            enclosingFunction = parent.element;\n          } else if (parent is MethodDeclaration) {\n            enclosingFunction = parent.element;\n          }\n          if (enclosingFunction == definingFunction) {\n            return true;\n          }\n          body = parent?.getAncestor((ancestor) => ancestor is FunctionBody);\n        }\n      }\n      return false;\n    }\n\n    if (!inDeprecatedMember &&\n        element != null &&\n        isDeprecated(element) &&\n        !isLocalParameter(element, node)) {\n      String displayName = element.displayName;\n      if (element is ConstructorElement) {\n        // TODO(jwren) We should modify ConstructorElement.getDisplayName(),\n        // or have the logic centralized elsewhere, instead of doing this logic\n        // here.\n        displayName = element.enclosingElement.displayName;\n        if (!element.displayName.isEmpty) {\n          displayName = \"$displayName.${element.displayName}\";\n        }\n      } else if (displayName == FunctionElement.CALL_METHOD_NAME &&\n          node is MethodInvocation &&\n          node.staticInvokeType is InterfaceType) {\n        displayName =\n            \"${resolutionMap.staticInvokeTypeForInvocationExpression(node).displayName}.${element.displayName}\";\n      }\n      _errorReporter.reportErrorForNode(\n          HintCode.DEPRECATED_MEMBER_USE, node, [displayName]);\n    }\n  }\n\n  /**\n   * For [SimpleIdentifier]s, only call [checkForDeprecatedMemberUse]\n   * if the node is not in a declaration context.\n   *\n   * Also, if the identifier is a constructor name in a constructor invocation, then calls to the\n   * deprecated constructor will be caught by\n   * [visitInstanceCreationExpression] and\n   * [visitSuperConstructorInvocation], and can be ignored by\n   * this visit method.\n   *\n   * @param identifier some simple identifier to check for deprecated use of\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.DEPRECATED_MEMBER_USE].\n   */\n  void _checkForDeprecatedMemberUseAtIdentifier(SimpleIdentifier identifier) {\n    if (identifier.inDeclarationContext()) {\n      return;\n    }\n    AstNode parent = identifier.parent;\n    if ((parent is ConstructorName && identical(identifier, parent.name)) ||\n        (parent is ConstructorDeclaration &&\n            identical(identifier, parent.returnType)) ||\n        (parent is SuperConstructorInvocation &&\n            identical(identifier, parent.constructorName)) ||\n        parent is HideCombinator) {\n      return;\n    }\n    _checkForDeprecatedMemberUse(identifier.bestElement, identifier);\n  }\n\n  /**\n   * Check for the passed binary expression for the [HintCode.DIVISION_OPTIMIZATION].\n   *\n   * @param node the binary expression to check\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.DIVISION_OPTIMIZATION].\n   */\n  bool _checkForDivisionOptimizationHint(BinaryExpression node) {\n    // Return if the operator is not '/'\n    if (node.operator.type != TokenType.SLASH) {\n      return false;\n    }\n    // Return if the '/' operator is not defined in core, or if we don't know\n    // its static or propagated type\n    MethodElement methodElement = node.bestElement;\n    if (methodElement == null) {\n      return false;\n    }\n    LibraryElement libraryElement = methodElement.library;\n    if (libraryElement != null && !libraryElement.isDartCore) {\n      return false;\n    }\n    // Report error if the (x/y) has toInt() invoked on it\n    AstNode parent = node.parent;\n    if (parent is ParenthesizedExpression) {\n      ParenthesizedExpression parenthesizedExpression =\n          _wrapParenthesizedExpression(parent);\n      AstNode grandParent = parenthesizedExpression.parent;\n      if (grandParent is MethodInvocation) {\n        if (_TO_INT_METHOD_NAME == grandParent.methodName.name &&\n            grandParent.argumentList.arguments.isEmpty) {\n          _errorReporter.reportErrorForNode(\n              HintCode.DIVISION_OPTIMIZATION, grandParent);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  void _checkForImmutable(ClassDeclaration node) {\n    /**\n     * Return `true` if the given class [element] is annotated with the\n     * `@immutable` annotation.\n     */\n    bool isImmutable(ClassElement element) {\n      for (ElementAnnotation annotation in element.metadata) {\n        if (annotation.isImmutable) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Return `true` if the given class [element] or any superclass of it is\n     * annotated with the `@immutable` annotation.\n     */\n    bool isOrInheritsImmutable(\n        ClassElement element, HashSet<ClassElement> visited) {\n      if (visited.add(element)) {\n        if (isImmutable(element)) {\n          return true;\n        }\n        for (InterfaceType interface in element.mixins) {\n          if (isOrInheritsImmutable(interface.element, visited)) {\n            return true;\n          }\n        }\n        for (InterfaceType mixin in element.interfaces) {\n          if (isOrInheritsImmutable(mixin.element, visited)) {\n            return true;\n          }\n        }\n        if (element.supertype != null) {\n          return isOrInheritsImmutable(element.supertype.element, visited);\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Return `true` if the given class [element] defines a non-final instance\n     * field.\n     */\n    bool hasNonFinalInstanceField(ClassElement element) {\n      for (FieldElement field in element.fields) {\n        if (!field.isSynthetic && !field.isFinal && !field.isStatic) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Return `true` if the given class [element] defines or inherits a\n     * non-final field.\n     */\n    bool hasOrInheritsNonFinalInstanceField(\n        ClassElement element, HashSet<ClassElement> visited) {\n      if (visited.add(element)) {\n        if (hasNonFinalInstanceField(element)) {\n          return true;\n        }\n        for (InterfaceType mixin in element.mixins) {\n          if (hasNonFinalInstanceField(mixin.element)) {\n            return true;\n          }\n        }\n        if (element.supertype != null) {\n          return hasOrInheritsNonFinalInstanceField(\n              element.supertype.element, visited);\n        }\n      }\n      return false;\n    }\n\n    ClassElement element = node.element;\n    if (isOrInheritsImmutable(element, new HashSet<ClassElement>()) &&\n        hasOrInheritsNonFinalInstanceField(\n            element, new HashSet<ClassElement>())) {\n      _errorReporter.reportErrorForNode(HintCode.MUST_BE_IMMUTABLE, node.name);\n    }\n  }\n\n  /// Produces a hint if [identifier] is accessed from an invalid location. In\n  /// particular:\n  ///\n  /// * if the given identifier is a protected closure, field or\n  ///   getter/setter, method closure or invocation accessed outside a subclass,\n  ///   or accessed outside the library wherein the identifier is declared, or\n  /// * if the given identifier is a closure, field, getter, setter, method\n  ///   closure or invocation which is annotated with `visibleForTesting`, and\n  ///   is accessed outside of the defining library, and the current library\n  ///   does not have the word 'test' in its name.\n  void _checkForInvalidAccess(SimpleIdentifier identifier) {\n    if (identifier.inDeclarationContext()) {\n      return;\n    }\n\n    bool isProtected(Element element) {\n      if (element is PropertyAccessorElement &&\n          element.enclosingElement is ClassElement &&\n          (element.hasProtected || element.variable.hasProtected)) {\n        return true;\n      }\n      if (element is MethodElement &&\n          element.enclosingElement is ClassElement &&\n          element.hasProtected) {\n        return true;\n      }\n      return false;\n    }\n\n    bool isVisibleForTesting(Element element) {\n      if (element == null) {\n        return false;\n      }\n      if (element.hasVisibleForTesting) {\n        return true;\n      }\n      if (element is PropertyAccessorElement &&\n          element.enclosingElement is ClassElement &&\n          element.variable.hasVisibleForTesting) {\n        return true;\n      }\n      return false;\n    }\n\n    bool inCommentReference(SimpleIdentifier identifier) =>\n        identifier.getAncestor((AstNode node) => node is CommentReference) !=\n        null;\n\n    bool inCurrentLibrary(Element element) =>\n        element.library == _currentLibrary;\n\n    bool inExportDirective(SimpleIdentifier identifier) =>\n        identifier.parent is Combinator &&\n        identifier.parent.parent is ExportDirective;\n\n    bool inTestDirectory(LibraryElement library) =>\n        library.definingCompilationUnit.source.fullName.contains(_testDir) ||\n        library.definingCompilationUnit.source.fullName.contains(_testingDir);\n\n    Element element = identifier.bestElement;\n    if (!isProtected(element) && !isVisibleForTesting(element)) {\n      return;\n    }\n\n    if (isProtected(element)) {\n      if (inCurrentLibrary(element) || inCommentReference(identifier)) {\n        // The access is valid; even if [element] is also marked\n        // `visibleForTesting`, the \"visibilities\" are unioned.\n        return;\n      }\n      ClassElement definingClass = element.enclosingElement;\n      ClassDeclaration accessingClass =\n          identifier.getAncestor((AstNode node) => node is ClassDeclaration);\n      if (_hasTypeOrSuperType(accessingClass?.element, definingClass.type)) {\n        return;\n      }\n    }\n    if (isVisibleForTesting(element)) {\n      if (inCurrentLibrary(element) ||\n          inTestDirectory(_currentLibrary) ||\n          inExportDirective(identifier) ||\n          inCommentReference(identifier)) {\n        // The access is valid; even if [element] is also marked\n        // `protected`, the \"visibilities\" are unioned.\n        return;\n      }\n    }\n\n    // At this point, [identifier] was not cleared as protected access, nor\n    // cleared as access for testing. Report the appropriate violation(s).\n    Element definingClass = element.enclosingElement;\n    if (isProtected(element)) {\n      _errorReporter.reportErrorForNode(\n          HintCode.INVALID_USE_OF_PROTECTED_MEMBER,\n          identifier,\n          [identifier.name.toString(), definingClass.name]);\n    }\n    if (isVisibleForTesting(element)) {\n      _errorReporter.reportErrorForNode(\n          HintCode.INVALID_USE_OF_VISIBLE_FOR_TESTING_MEMBER,\n          identifier,\n          [identifier.name.toString(), definingClass.name]);\n    }\n  }\n\n  /**\n   * This verifies that the passed left hand side and right hand side represent a valid assignment.\n   *\n   * This method corresponds to ErrorVerifier.checkForInvalidAssignment.\n   *\n   * @param lhs the left hand side expression\n   * @param rhs the right hand side expression\n   * @return `true` if and only if an error code is generated on the passed node\n   * See [HintCode.INVALID_ASSIGNMENT].\n   */\n  bool _checkForInvalidAssignment(Expression lhs, Expression rhs) {\n    if (lhs == null || rhs == null) {\n      return false;\n    }\n    VariableElement leftVariableElement = ErrorVerifier.getVariableElement(lhs);\n    DartType leftType = (leftVariableElement == null)\n        ? ErrorVerifier.getStaticType(lhs)\n        : leftVariableElement.type;\n    DartType staticRightType = ErrorVerifier.getStaticType(rhs);\n    if (!_typeSystem.isAssignableTo(staticRightType, leftType,\n        isDeclarationCast: true)) {\n      // The warning was generated on this rhs\n      return false;\n    }\n    // Test for, and then generate the hint\n    DartType bestRightType = rhs.bestType;\n    if (leftType != null && bestRightType != null) {\n      if (!_typeSystem.isAssignableTo(bestRightType, leftType,\n          isDeclarationCast: true)) {\n        _errorReporter.reportTypeErrorForNode(\n            HintCode.INVALID_ASSIGNMENT, rhs, [bestRightType, leftType]);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void _checkForInvalidFactory(MethodDeclaration decl) {\n    // Check declaration.\n    // Note that null return types are expected to be flagged by other analyses.\n    DartType returnType = decl.returnType?.type;\n    if (returnType is VoidType) {\n      _errorReporter.reportErrorForNode(HintCode.INVALID_FACTORY_METHOD_DECL,\n          decl.name, [decl.name.toString()]);\n      return;\n    }\n\n    // Check implementation.\n\n    FunctionBody body = decl.body;\n    if (body is EmptyFunctionBody) {\n      // Abstract methods are OK.\n      return;\n    }\n\n    // `new Foo()` or `null`.\n    bool factoryExpression(Expression expression) =>\n        expression is InstanceCreationExpression || expression is NullLiteral;\n\n    if (body is ExpressionFunctionBody && factoryExpression(body.expression)) {\n      return;\n    } else if (body is BlockFunctionBody) {\n      NodeList<Statement> statements = body.block.statements;\n      if (statements.isNotEmpty) {\n        Statement last = statements.last;\n        if (last is ReturnStatement && factoryExpression(last.expression)) {\n          return;\n        }\n      }\n    }\n\n    _errorReporter.reportErrorForNode(HintCode.INVALID_FACTORY_METHOD_IMPL,\n        decl.name, [decl.name.toString()]);\n  }\n\n  /**\n   * Check that the imported library does not define a loadLibrary function. The import has already\n   * been determined to be deferred when this is called.\n   *\n   * @param node the import directive to evaluate\n   * @param importElement the [ImportElement] retrieved from the node\n   * @return `true` if and only if an error code is generated on the passed node\n   * See [CompileTimeErrorCode.IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION].\n   */\n  bool _checkForLoadLibraryFunction(\n      ImportDirective node, ImportElement importElement) {\n    LibraryElement importedLibrary = importElement.importedLibrary;\n    if (importedLibrary == null) {\n      return false;\n    }\n    if (importedLibrary.hasLoadLibraryFunction) {\n      _errorReporter.reportErrorForNode(\n          HintCode.IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION,\n          node,\n          [importedLibrary.name]);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Generate a hint for functions or methods that have a return type, but do not have a return\n   * statement on all branches. At the end of blocks with no return, Dart implicitly returns\n   * `null`, avoiding these implicit returns is considered a best practice.\n   *\n   * Note: for async functions/methods, this hint only applies when the\n   * function has a return type that Future<Null> is not assignable to.\n   *\n   * @param node the binary expression to check\n   * @param body the function body\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.MISSING_RETURN].\n   */\n  void _checkForMissingReturn(TypeAnnotation returnType, FunctionBody body) {\n    // Check that the method or function has a return type, and a function body\n    if (returnType == null || body == null) {\n      return;\n    }\n    // Check that the body is a BlockFunctionBody\n    if (body is BlockFunctionBody) {\n      // Generators are never required to have a return statement.\n      if (body.isGenerator) {\n        return;\n      }\n\n      if (_typeSystem is StrongTypeSystemImpl) {\n        // Check that the type is resolvable, and is not \"void\"\n        DartType returnTypeType = returnType.type;\n        if (returnTypeType == null) {\n          return;\n        }\n\n        var flattenedType = body.isAsynchronous\n            ? returnTypeType.flattenFutures(_typeSystem)\n            : returnTypeType;\n        if (flattenedType.isDynamic ||\n            flattenedType.isDartCoreNull ||\n            flattenedType.isVoid) {\n          return;\n        }\n        // Check the block for a return statement, if not, create the hint\n        if (!ExitDetector.exits(body)) {\n          _errorReporter.reportErrorForNode(HintCode.MISSING_RETURN, returnType,\n              [returnTypeType.displayName]);\n        }\n      }\n      // TODO(leafp): Delete this non-strong mode path\n      // Check that the type is resolvable and not \"void\"\n      DartType returnTypeType = returnType.type;\n      if (returnTypeType == null ||\n          returnTypeType.isVoid ||\n          (body.isAsynchronous && _isFutureVoid(returnTypeType))) {\n        return;\n      }\n      // For async, give no hint if the return type does not matter, i.e.\n      // dynamic, Future<Null> or Future<dynamic>.\n      if (body.isAsynchronous) {\n        if (returnTypeType.isDynamic) {\n          return;\n        }\n        if (returnTypeType is InterfaceType &&\n            returnTypeType.isDartAsyncFuture) {\n          DartType futureArgument = returnTypeType.typeArguments[0];\n          if (futureArgument.isDynamic ||\n              futureArgument.isDartCoreNull ||\n              futureArgument.isVoid ||\n              futureArgument.isObject) {\n            return;\n          }\n        }\n      }\n      // Check the block for a return statement, if not, create the hint\n      if (!ExitDetector.exits(body)) {\n        _errorReporter.reportErrorForNode(\n            HintCode.MISSING_RETURN, returnType, [returnTypeType.displayName]);\n      }\n    }\n  }\n\n  /**\n   * Produce several null-aware related hints.\n   */\n  void _checkForNullAwareHints(Expression node, Token operator) {\n    if (operator == null || operator.type != TokenType.QUESTION_PERIOD) {\n      return;\n    }\n\n    // childOfParent is used to know from which branch node comes.\n    var childOfParent = node;\n    var parent = node.parent;\n    while (parent is ParenthesizedExpression) {\n      childOfParent = parent;\n      parent = parent.parent;\n    }\n\n    // CAN_BE_NULL_AFTER_NULL_AWARE\n    if (parent is MethodInvocation &&\n        parent.operator.type != TokenType.QUESTION_PERIOD &&\n        _nullType.lookUpMethod(parent.methodName.name, _currentLibrary) ==\n            null) {\n      _errorReporter.reportErrorForNode(\n          HintCode.CAN_BE_NULL_AFTER_NULL_AWARE, childOfParent);\n      return;\n    }\n    if (parent is PropertyAccess &&\n        parent.operator.type != TokenType.QUESTION_PERIOD &&\n        _nullType.lookUpGetter(parent.propertyName.name, _currentLibrary) ==\n            null) {\n      _errorReporter.reportErrorForNode(\n          HintCode.CAN_BE_NULL_AFTER_NULL_AWARE, childOfParent);\n      return;\n    }\n    if (parent is CascadeExpression && parent.target == childOfParent) {\n      _errorReporter.reportErrorForNode(\n          HintCode.CAN_BE_NULL_AFTER_NULL_AWARE, childOfParent);\n      return;\n    }\n\n    // NULL_AWARE_IN_CONDITION\n    if (parent is IfStatement && parent.condition == childOfParent ||\n        parent is ForStatement && parent.condition == childOfParent ||\n        parent is DoStatement && parent.condition == childOfParent ||\n        parent is WhileStatement && parent.condition == childOfParent ||\n        parent is ConditionalExpression && parent.condition == childOfParent ||\n        parent is AssertStatement && parent.condition == childOfParent) {\n      _errorReporter.reportErrorForNode(\n          HintCode.NULL_AWARE_IN_CONDITION, childOfParent);\n      return;\n    }\n\n    // NULL_AWARE_IN_LOGICAL_OPERATOR\n    if (parent is PrefixExpression && parent.operator.type == TokenType.BANG ||\n        parent is BinaryExpression &&\n            [TokenType.BAR_BAR, TokenType.AMPERSAND_AMPERSAND]\n                .contains(parent.operator.type)) {\n      _errorReporter.reportErrorForNode(\n          HintCode.NULL_AWARE_IN_LOGICAL_OPERATOR, childOfParent);\n      return;\n    }\n\n    // NULL_AWARE_BEFORE_OPERATOR\n    if (parent is BinaryExpression &&\n        ![TokenType.EQ_EQ, TokenType.BANG_EQ, TokenType.QUESTION_QUESTION]\n            .contains(parent.operator.type) &&\n        parent.leftOperand == childOfParent) {\n      _errorReporter.reportErrorForNode(\n          HintCode.NULL_AWARE_BEFORE_OPERATOR, childOfParent);\n      return;\n    }\n  }\n\n  /**\n   * Check for the passed as expression for the [HintCode.UNNECESSARY_CAST] hint code.\n   *\n   * @param node the as expression to check\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.UNNECESSARY_CAST].\n   */\n  bool _checkForUnnecessaryCast(AsExpression node) {\n    // TODO(jwren) After dartbug.com/13732, revisit this, we should be able to\n    // remove the (x is! TypeParameterType) checks.\n    AstNode parent = node.parent;\n    if (parent is ConditionalExpression &&\n        (node == parent.thenExpression || node == parent.elseExpression)) {\n      Expression thenExpression = parent.thenExpression;\n      DartType thenType;\n      if (thenExpression is AsExpression) {\n        thenType = thenExpression.expression.staticType;\n      } else {\n        thenType = thenExpression.staticType;\n      }\n      Expression elseExpression = parent.elseExpression;\n      DartType elseType;\n      if (elseExpression is AsExpression) {\n        elseType = elseExpression.expression.staticType;\n      } else {\n        elseType = elseExpression.staticType;\n      }\n      if (thenType != null &&\n          elseType != null &&\n          !thenType.isDynamic &&\n          !elseType.isDynamic &&\n          !thenType.isMoreSpecificThan(elseType) &&\n          !elseType.isMoreSpecificThan(thenType)) {\n        return false;\n      }\n    }\n    DartType lhsType = node.expression.staticType;\n    DartType rhsType = node.type.type;\n    if (lhsType != null &&\n        rhsType != null &&\n        !lhsType.isDynamic &&\n        !rhsType.isDynamic &&\n        _typeSystem.isMoreSpecificThan(lhsType, rhsType)) {\n      _errorReporter.reportErrorForNode(HintCode.UNNECESSARY_CAST, node);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Generate a hint for `noSuchMethod` methods that do nothing except of\n   * calling another `noSuchMethod` that is not defined by `Object`.\n   *\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.UNNECESSARY_NO_SUCH_METHOD].\n   */\n  bool _checkForUnnecessaryNoSuchMethod(MethodDeclaration node) {\n    if (node.name.name != FunctionElement.NO_SUCH_METHOD_METHOD_NAME) {\n      return false;\n    }\n    bool isNonObjectNoSuchMethodInvocation(Expression invocation) {\n      if (invocation is MethodInvocation &&\n          invocation.target is SuperExpression &&\n          invocation.argumentList.arguments.length == 1) {\n        SimpleIdentifier name = invocation.methodName;\n        if (name.name == FunctionElement.NO_SUCH_METHOD_METHOD_NAME) {\n          Element methodElement = name.staticElement;\n          Element classElement = methodElement?.enclosingElement;\n          return methodElement is MethodElement &&\n              classElement is ClassElement &&\n              !classElement.type.isObject;\n        }\n      }\n      return false;\n    }\n\n    FunctionBody body = node.body;\n    if (body is ExpressionFunctionBody) {\n      if (isNonObjectNoSuchMethodInvocation(body.expression)) {\n        _errorReporter.reportErrorForNode(\n            HintCode.UNNECESSARY_NO_SUCH_METHOD, node);\n        return true;\n      }\n    } else if (body is BlockFunctionBody) {\n      List<Statement> statements = body.block.statements;\n      if (statements.length == 1) {\n        Statement returnStatement = statements.first;\n        if (returnStatement is ReturnStatement &&\n            isNonObjectNoSuchMethodInvocation(returnStatement.expression)) {\n          _errorReporter.reportErrorForNode(\n              HintCode.UNNECESSARY_NO_SUCH_METHOD, node);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  void _checkRequiredParameter(FormalParameterList node) {\n    final requiredParameters =\n        node.parameters.where((p) => p.element?.hasRequired == true);\n    final nonNamedParamsWithRequired =\n        requiredParameters.where((p) => !p.isNamed);\n    final namedParamsWithRequiredAndDefault = requiredParameters\n        .where((p) => p.isNamed)\n        .where((p) => p.element.defaultValueCode != null);\n    final paramsToHint = [\n      nonNamedParamsWithRequired,\n      namedParamsWithRequiredAndDefault\n    ].expand((e) => e);\n    for (final param in paramsToHint) {\n      _errorReporter.reportErrorForNode(\n          HintCode.INVALID_REQUIRED_PARAM, param, [param.identifier.name]);\n    }\n  }\n\n  /**\n   * Check for the passed class declaration for the\n   * [HintCode.OVERRIDE_EQUALS_BUT_NOT_HASH_CODE] hint code.\n   *\n   * @param node the class declaration to check\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.OVERRIDE_EQUALS_BUT_NOT_HASH_CODE].\n   */\n//  bool _checkForOverrideEqualsButNotHashCode(ClassDeclaration node) {\n//    ClassElement classElement = node.element;\n//    if (classElement == null) {\n//      return false;\n//    }\n//    MethodElement equalsOperatorMethodElement =\n//        classElement.getMethod(sc.TokenType.EQ_EQ.lexeme);\n//    if (equalsOperatorMethodElement != null) {\n//      PropertyAccessorElement hashCodeElement =\n//          classElement.getGetter(_HASHCODE_GETTER_NAME);\n//      if (hashCodeElement == null) {\n//        _errorReporter.reportErrorForNode(\n//            HintCode.OVERRIDE_EQUALS_BUT_NOT_HASH_CODE,\n//            node.name,\n//            [classElement.displayName]);\n//        return true;\n//      }\n//    }\n//    return false;\n//  }\n\n  bool _hasTypeOrSuperType(ClassElement element, InterfaceType type) {\n    if (element == null) {\n      return false;\n    }\n    ClassElement typeElement = type.element;\n    return element == typeElement ||\n        element.allSupertypes\n            .any((InterfaceType t) => t.element == typeElement);\n  }\n\n  /**\n   * Return `true` if the given [type] represents `Future<void>`.\n   */\n  bool _isFutureVoid(DartType type) {\n    if (type.isDartAsyncFuture) {\n      List<DartType> typeArgs = (type as InterfaceType).typeArguments;\n      if (typeArgs.length == 1 && typeArgs[0].isVoid) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Given a parenthesized expression, this returns the parent (or recursively grand-parent) of the\n   * expression that is a parenthesized expression, but whose parent is not a parenthesized\n   * expression.\n   *\n   * For example given the code `(((e)))`: `(e) -> (((e)))`.\n   *\n   * @param parenthesizedExpression some expression whose parent is a parenthesized expression\n   * @return the first parent or grand-parent that is a parenthesized expression, that does not have\n   *         a parenthesized expression parent\n   */\n  static ParenthesizedExpression _wrapParenthesizedExpression(\n      ParenthesizedExpression parenthesizedExpression) {\n    AstNode parent = parenthesizedExpression.parent;\n    if (parent is ParenthesizedExpression) {\n      return _wrapParenthesizedExpression(parent);\n    }\n    return parenthesizedExpression;\n  }\n}\n\n/**\n * Utilities for [LibraryElementImpl] building.\n */\nclass BuildLibraryElementUtils {\n  /**\n   * Look through all of the compilation units defined for the given [library],\n   * looking for getters and setters that are defined in different compilation\n   * units but that have the same names. If any are found, make sure that they\n   * have the same variable element.\n   */\n  static void patchTopLevelAccessors(LibraryElementImpl library) {\n    // Without parts getters/setters already share the same variable element.\n    List<CompilationUnitElement> parts = library.parts;\n    if (parts.isEmpty) {\n      return;\n    }\n    // Collect getters and setters.\n    Map<String, PropertyAccessorElement> getters =\n        new HashMap<String, PropertyAccessorElement>();\n    List<PropertyAccessorElement> setters = <PropertyAccessorElement>[];\n    _collectAccessors(getters, setters, library.definingCompilationUnit);\n    int partLength = parts.length;\n    for (int i = 0; i < partLength; i++) {\n      CompilationUnitElement unit = parts[i];\n      _collectAccessors(getters, setters, unit);\n    }\n    // Move every setter to the corresponding getter's variable (if exists).\n    int setterLength = setters.length;\n    for (int j = 0; j < setterLength; j++) {\n      PropertyAccessorElement setter = setters[j];\n      PropertyAccessorElement getter = getters[setter.displayName];\n      if (getter != null) {\n        TopLevelVariableElementImpl variable = getter.variable;\n        TopLevelVariableElementImpl setterVariable = setter.variable;\n        CompilationUnitElementImpl setterUnit = setterVariable.enclosingElement;\n        setterUnit.replaceTopLevelVariable(setterVariable, variable);\n        variable.setter = setter;\n        (setter as PropertyAccessorElementImpl).variable = variable;\n      }\n    }\n  }\n\n  /**\n   * Add all of the non-synthetic [getters] and [setters] defined in the given\n   * [unit] that have no corresponding accessor to one of the given collections.\n   */\n  static void _collectAccessors(Map<String, PropertyAccessorElement> getters,\n      List<PropertyAccessorElement> setters, CompilationUnitElement unit) {\n    List<PropertyAccessorElement> accessors = unit.accessors;\n    int length = accessors.length;\n    for (int i = 0; i < length; i++) {\n      PropertyAccessorElement accessor = accessors[i];\n      if (accessor.isGetter) {\n        if (!accessor.isSynthetic && accessor.correspondingSetter == null) {\n          getters[accessor.displayName] = accessor;\n        }\n      } else {\n        if (!accessor.isSynthetic && accessor.correspondingGetter == null) {\n          setters.add(accessor);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Instances of the class `ConstantVerifier` traverse an AST structure looking for additional\n * errors and warnings not covered by the parser and resolver. In particular, it looks for errors\n * and warnings related to constant expressions.\n */\nclass ConstantVerifier extends RecursiveAstVisitor<Object> {\n  /**\n   * The error reporter by which errors will be reported.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * The type provider used to access the known types.\n   */\n  final TypeProvider _typeProvider;\n\n  /**\n   * The type system in use.\n   */\n  final TypeSystem _typeSystem;\n\n  /**\n   * The set of variables declared using '-D' on the command line.\n   */\n  final DeclaredVariables declaredVariables;\n\n  /**\n   * The type representing the type 'bool'.\n   */\n  InterfaceType _boolType;\n\n  /**\n   * The type representing the type 'int'.\n   */\n  InterfaceType _intType;\n\n  /**\n   * The type representing the type 'num'.\n   */\n  InterfaceType _numType;\n\n  /**\n   * The type representing the type 'string'.\n   */\n  InterfaceType _stringType;\n\n  /**\n   * The current library that is being analyzed.\n   */\n  final LibraryElement _currentLibrary;\n\n  /**\n   * Initialize a newly created constant verifier.\n   *\n   * @param errorReporter the error reporter by which errors will be reported\n   */\n  ConstantVerifier(this._errorReporter, LibraryElement currentLibrary,\n      this._typeProvider, this.declaredVariables)\n      : _currentLibrary = currentLibrary,\n        _typeSystem = currentLibrary.context.typeSystem {\n    this._boolType = _typeProvider.boolType;\n    this._intType = _typeProvider.intType;\n    this._numType = _typeProvider.numType;\n    this._stringType = _typeProvider.stringType;\n  }\n\n  @override\n  Object visitAnnotation(Annotation node) {\n    super.visitAnnotation(node);\n    // check annotation creation\n    Element element = node.element;\n    if (element is ConstructorElement) {\n      // should be 'const' constructor\n      if (!element.isConst) {\n        _errorReporter.reportErrorForNode(\n            CompileTimeErrorCode.NON_CONSTANT_ANNOTATION_CONSTRUCTOR, node);\n        return null;\n      }\n      // should have arguments\n      ArgumentList argumentList = node.arguments;\n      if (argumentList == null) {\n        _errorReporter.reportErrorForNode(\n            CompileTimeErrorCode.NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS, node);\n        return null;\n      }\n      // arguments should be constants\n      _validateConstantArguments(argumentList);\n    }\n    return null;\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    if (node.constKeyword != null) {\n      _validateConstructorInitializers(node);\n      _validateFieldInitializers(node.parent as ClassDeclaration, node);\n    }\n    _validateDefaultValues(node.parameters);\n    return super.visitConstructorDeclaration(node);\n  }\n\n  @override\n  Object visitFunctionExpression(FunctionExpression node) {\n    super.visitFunctionExpression(node);\n    _validateDefaultValues(node.parameters);\n    return null;\n  }\n\n  @override\n  Object visitInstanceCreationExpression(InstanceCreationExpression node) {\n    if (node.isConst) {\n      // We need to evaluate the constant to see if any errors occur during its\n      // evaluation.\n      ConstructorElement constructor = node.staticElement;\n      if (constructor != null) {\n        ConstantEvaluationEngine evaluationEngine =\n            new ConstantEvaluationEngine(_typeProvider, declaredVariables,\n                typeSystem: _typeSystem);\n        ConstantVisitor constantVisitor =\n            new ConstantVisitor(evaluationEngine, _errorReporter);\n        evaluationEngine.evaluateConstructorCall(\n            node,\n            node.argumentList.arguments,\n            constructor,\n            constantVisitor,\n            _errorReporter);\n      }\n    }\n    _validateInstanceCreationArguments(node);\n    return super.visitInstanceCreationExpression(node);\n  }\n\n  @override\n  Object visitListLiteral(ListLiteral node) {\n    super.visitListLiteral(node);\n    if (node.isConst) {\n      DartObjectImpl result;\n      for (Expression element in node.elements) {\n        result =\n            _validate(element, CompileTimeErrorCode.NON_CONSTANT_LIST_ELEMENT);\n        if (result != null) {\n          _reportErrorIfFromDeferredLibrary(\n              element,\n              CompileTimeErrorCode\n                  .NON_CONSTANT_LIST_ELEMENT_FROM_DEFERRED_LIBRARY);\n        }\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitMapLiteral(MapLiteral node) {\n    super.visitMapLiteral(node);\n    bool isConst = node.isConst;\n    bool reportEqualKeys = true;\n    HashSet<DartObject> keys = new HashSet<DartObject>();\n    List<Expression> invalidKeys = new List<Expression>();\n    for (MapLiteralEntry entry in node.entries) {\n      Expression key = entry.key;\n      if (isConst) {\n        DartObjectImpl keyResult =\n            _validate(key, CompileTimeErrorCode.NON_CONSTANT_MAP_KEY);\n        Expression valueExpression = entry.value;\n        DartObjectImpl valueResult = _validate(\n            valueExpression, CompileTimeErrorCode.NON_CONSTANT_MAP_VALUE);\n        if (valueResult != null) {\n          _reportErrorIfFromDeferredLibrary(\n              valueExpression,\n              CompileTimeErrorCode\n                  .NON_CONSTANT_MAP_VALUE_FROM_DEFERRED_LIBRARY);\n        }\n        if (keyResult != null) {\n          _reportErrorIfFromDeferredLibrary(key,\n              CompileTimeErrorCode.NON_CONSTANT_MAP_KEY_FROM_DEFERRED_LIBRARY);\n          if (keys.contains(keyResult)) {\n            invalidKeys.add(key);\n          } else {\n            keys.add(keyResult);\n          }\n          DartType type = keyResult.type;\n          if (_implementsEqualsWhenNotAllowed(type)) {\n            _errorReporter.reportErrorForNode(\n                CompileTimeErrorCode\n                    .CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS,\n                key,\n                [type.displayName]);\n          }\n        }\n      } else {\n        // Note: we throw the errors away because this isn't actually a const.\n        AnalysisErrorListener errorListener =\n            AnalysisErrorListener.NULL_LISTENER;\n        ErrorReporter subErrorReporter =\n            new ErrorReporter(errorListener, _errorReporter.source);\n        DartObjectImpl result = key.accept(new ConstantVisitor(\n            new ConstantEvaluationEngine(_typeProvider, declaredVariables,\n                typeSystem: _typeSystem),\n            subErrorReporter));\n        if (result != null) {\n          if (keys.contains(result)) {\n            invalidKeys.add(key);\n          } else {\n            keys.add(result);\n          }\n        } else {\n          reportEqualKeys = false;\n        }\n      }\n    }\n    if (reportEqualKeys) {\n      int length = invalidKeys.length;\n      for (int i = 0; i < length; i++) {\n        _errorReporter.reportErrorForNode(\n            StaticWarningCode.EQUAL_KEYS_IN_MAP, invalidKeys[i]);\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    super.visitMethodDeclaration(node);\n    _validateDefaultValues(node.parameters);\n    return null;\n  }\n\n  @override\n  Object visitSwitchStatement(SwitchStatement node) {\n    // TODO(paulberry): to minimize error messages, it would be nice to\n    // compare all types with the most popular type rather than the first\n    // type.\n    NodeList<SwitchMember> switchMembers = node.members;\n    bool foundError = false;\n    DartType firstType = null;\n    for (SwitchMember switchMember in switchMembers) {\n      if (switchMember is SwitchCase) {\n        Expression expression = switchMember.expression;\n        DartObjectImpl caseResult = _validate(\n            expression, CompileTimeErrorCode.NON_CONSTANT_CASE_EXPRESSION);\n        if (caseResult != null) {\n          _reportErrorIfFromDeferredLibrary(\n              expression,\n              CompileTimeErrorCode\n                  .NON_CONSTANT_CASE_EXPRESSION_FROM_DEFERRED_LIBRARY);\n          DartObject value = caseResult;\n          if (firstType == null) {\n            firstType = value.type;\n          } else {\n            DartType nType = value.type;\n            if (firstType != nType) {\n              _errorReporter.reportErrorForNode(\n                  CompileTimeErrorCode.INCONSISTENT_CASE_EXPRESSION_TYPES,\n                  expression,\n                  [expression.toSource(), firstType.displayName]);\n              foundError = true;\n            }\n          }\n        }\n      }\n    }\n    if (!foundError) {\n      _checkForCaseExpressionTypeImplementsEquals(node, firstType);\n    }\n    return super.visitSwitchStatement(node);\n  }\n\n  @override\n  Object visitVariableDeclaration(VariableDeclaration node) {\n    super.visitVariableDeclaration(node);\n    Expression initializer = node.initializer;\n    if (initializer != null && (node.isConst || node.isFinal)) {\n      VariableElementImpl element = node.element as VariableElementImpl;\n      EvaluationResultImpl result = element.evaluationResult;\n      if (result == null) {\n        // Variables marked \"const\" should have had their values computed by\n        // ConstantValueComputer.  Other variables will only have had their\n        // values computed if the value was needed (e.g. final variables in a\n        // class containing const constructors).\n        assert(!node.isConst);\n        return null;\n      }\n      _reportErrors(result.errors,\n          CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE);\n      _reportErrorIfFromDeferredLibrary(\n          initializer,\n          CompileTimeErrorCode\n              .CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY);\n    }\n    return null;\n  }\n\n  /**\n   * This verifies that the passed switch statement does not have a case expression with the\n   * operator '==' overridden.\n   *\n   * @param node the switch statement to evaluate\n   * @param type the common type of all 'case' expressions\n   * @return `true` if and only if an error code is generated on the passed node\n   * See [CompileTimeErrorCode.CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS].\n   */\n  bool _checkForCaseExpressionTypeImplementsEquals(\n      SwitchStatement node, DartType type) {\n    if (!_implementsEqualsWhenNotAllowed(type)) {\n      return false;\n    }\n    // report error\n    _errorReporter.reportErrorForToken(\n        CompileTimeErrorCode.CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS,\n        node.switchKeyword,\n        [type.displayName]);\n    return true;\n  }\n\n  /**\n   * @return `true` if given [Type] implements operator <i>==</i>, and it is not\n   *         <i>int</i> or <i>String</i>.\n   */\n  bool _implementsEqualsWhenNotAllowed(DartType type) {\n    // ignore int or String\n    if (type == null || type == _intType || type == _typeProvider.stringType) {\n      return false;\n    } else if (type == _typeProvider.doubleType) {\n      return true;\n    }\n    // prepare ClassElement\n    Element element = type.element;\n    if (element is ClassElement) {\n      // lookup for ==\n      MethodElement method =\n          element.lookUpConcreteMethod(\"==\", _currentLibrary);\n      if (method == null || method.enclosingElement.type.isObject) {\n        return false;\n      }\n      // there is == that we don't like\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Given some computed [Expression], this method generates the passed [ErrorCode] on\n   * the node if its' value consists of information from a deferred library.\n   *\n   * @param expression the expression to be tested for a deferred library reference\n   * @param errorCode the error code to be used if the expression is or consists of a reference to a\n   *          deferred library\n   */\n  void _reportErrorIfFromDeferredLibrary(\n      Expression expression, ErrorCode errorCode) {\n    DeferredLibraryReferenceDetector referenceDetector =\n        new DeferredLibraryReferenceDetector();\n    expression.accept(referenceDetector);\n    if (referenceDetector.result) {\n      _errorReporter.reportErrorForNode(errorCode, expression);\n    }\n  }\n\n  /**\n   * Report any errors in the given list. Except for special cases, use the given error code rather\n   * than the one reported in the error.\n   *\n   * @param errors the errors that need to be reported\n   * @param errorCode the error code to be used\n   */\n  void _reportErrors(List<AnalysisError> errors, ErrorCode errorCode) {\n    int length = errors.length;\n    for (int i = 0; i < length; i++) {\n      AnalysisError data = errors[i];\n      ErrorCode dataErrorCode = data.errorCode;\n      if (identical(dataErrorCode,\n              CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION) ||\n          identical(\n              dataErrorCode, CompileTimeErrorCode.CONST_EVAL_THROWS_IDBZE) ||\n          identical(dataErrorCode,\n              CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING) ||\n          identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL) ||\n          identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_INT) ||\n          identical(dataErrorCode, CompileTimeErrorCode.CONST_EVAL_TYPE_NUM) ||\n          identical(dataErrorCode,\n              CompileTimeErrorCode.RECURSIVE_COMPILE_TIME_CONSTANT) ||\n          identical(dataErrorCode,\n              CheckedModeCompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION) ||\n          identical(\n              dataErrorCode,\n              CheckedModeCompileTimeErrorCode\n                  .CONST_CONSTRUCTOR_FIELD_TYPE_MISMATCH) ||\n          identical(\n              dataErrorCode,\n              CheckedModeCompileTimeErrorCode\n                  .CONST_CONSTRUCTOR_PARAM_TYPE_MISMATCH) ||\n          identical(dataErrorCode,\n              CheckedModeCompileTimeErrorCode.VARIABLE_TYPE_MISMATCH)) {\n        _errorReporter.reportError(data);\n      } else if (errorCode != null) {\n        _errorReporter.reportError(new AnalysisError(\n            data.source, data.offset, data.length, errorCode));\n      }\n    }\n  }\n\n  /**\n   * Validate that the given expression is a compile time constant. Return the value of the compile\n   * time constant, or `null` if the expression is not a compile time constant.\n   *\n   * @param expression the expression to be validated\n   * @param errorCode the error code to be used if the expression is not a compile time constant\n   * @return the value of the compile time constant\n   */\n  DartObjectImpl _validate(Expression expression, ErrorCode errorCode) {\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    ErrorReporter subErrorReporter =\n        new ErrorReporter(errorListener, _errorReporter.source);\n    DartObjectImpl result = expression.accept(new ConstantVisitor(\n        new ConstantEvaluationEngine(_typeProvider, declaredVariables,\n            typeSystem: _typeSystem),\n        subErrorReporter));\n    _reportErrors(errorListener.errors, errorCode);\n    return result;\n  }\n\n  /**\n   * Validate that if the passed arguments are constant expressions.\n   *\n   * @param argumentList the argument list to evaluate\n   */\n  void _validateConstantArguments(ArgumentList argumentList) {\n    for (Expression argument in argumentList.arguments) {\n      Expression realArgument =\n          argument is NamedExpression ? argument.expression : argument;\n      _validate(\n          realArgument, CompileTimeErrorCode.CONST_WITH_NON_CONSTANT_ARGUMENT);\n    }\n  }\n\n  /**\n   * Validates that the expressions of the initializers of the given constant\n   * [constructor] are all compile time constants.\n   */\n  void _validateConstructorInitializers(ConstructorDeclaration constructor) {\n    List<ParameterElement> parameterElements =\n        constructor.parameters.parameterElements;\n    NodeList<ConstructorInitializer> initializers = constructor.initializers;\n    for (ConstructorInitializer initializer in initializers) {\n      if (initializer is AssertInitializer) {\n        _validateInitializerExpression(\n            parameterElements, initializer.condition);\n        Expression message = initializer.message;\n        if (message != null) {\n          _validateInitializerExpression(parameterElements, message);\n        }\n      } else if (initializer is ConstructorFieldInitializer) {\n        _validateInitializerExpression(\n            parameterElements, initializer.expression);\n      } else if (initializer is RedirectingConstructorInvocation) {\n        _validateInitializerInvocationArguments(\n            parameterElements, initializer.argumentList);\n      } else if (initializer is SuperConstructorInvocation) {\n        _validateInitializerInvocationArguments(\n            parameterElements, initializer.argumentList);\n      }\n    }\n  }\n\n  /**\n   * Validate that the default value associated with each of the parameters in the given list is a\n   * compile time constant.\n   *\n   * @param parameters the list of parameters to be validated\n   */\n  void _validateDefaultValues(FormalParameterList parameters) {\n    if (parameters == null) {\n      return;\n    }\n    for (FormalParameter parameter in parameters.parameters) {\n      if (parameter is DefaultFormalParameter) {\n        Expression defaultValue = parameter.defaultValue;\n        DartObjectImpl result;\n        if (defaultValue == null) {\n          result =\n              new DartObjectImpl(_typeProvider.nullType, NullState.NULL_STATE);\n        } else {\n          result = _validate(\n              defaultValue, CompileTimeErrorCode.NON_CONSTANT_DEFAULT_VALUE);\n          if (result != null) {\n            _reportErrorIfFromDeferredLibrary(\n                defaultValue,\n                CompileTimeErrorCode\n                    .NON_CONSTANT_DEFAULT_VALUE_FROM_DEFERRED_LIBRARY);\n          }\n        }\n        VariableElementImpl element = parameter.element as VariableElementImpl;\n        element.evaluationResult = new EvaluationResultImpl(result);\n      }\n    }\n  }\n\n  /**\n   * Validates that the expressions of any field initializers in the class declaration are all\n   * compile time constants. Since this is only required if the class has a constant constructor,\n   * the error is reported at the constructor site.\n   *\n   * @param classDeclaration the class which should be validated\n   * @param errorSite the site at which errors should be reported.\n   */\n  void _validateFieldInitializers(\n      ClassDeclaration classDeclaration, ConstructorDeclaration errorSite) {\n    NodeList<ClassMember> members = classDeclaration.members;\n    for (ClassMember member in members) {\n      if (member is FieldDeclaration && !member.isStatic) {\n        for (VariableDeclaration variableDeclaration\n            in member.fields.variables) {\n          Expression initializer = variableDeclaration.initializer;\n          if (initializer != null) {\n            // Ignore any errors produced during validation--if the constant\n            // can't be evaluated we'll just report a single error.\n            AnalysisErrorListener errorListener =\n                AnalysisErrorListener.NULL_LISTENER;\n            ErrorReporter subErrorReporter =\n                new ErrorReporter(errorListener, _errorReporter.source);\n            DartObjectImpl result = initializer.accept(new ConstantVisitor(\n                new ConstantEvaluationEngine(_typeProvider, declaredVariables,\n                    typeSystem: _typeSystem),\n                subErrorReporter));\n            if (result == null) {\n              _errorReporter.reportErrorForNode(\n                  CompileTimeErrorCode\n                      .CONST_CONSTRUCTOR_WITH_FIELD_INITIALIZED_BY_NON_CONST,\n                  errorSite,\n                  [variableDeclaration.name.name]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validates that the given expression is a compile time constant.\n   *\n   * @param parameterElements the elements of parameters of constant constructor, they are\n   *          considered as a valid potentially constant expressions\n   * @param expression the expression to validate\n   */\n  void _validateInitializerExpression(\n      List<ParameterElement> parameterElements, Expression expression) {\n    RecordingErrorListener errorListener = new RecordingErrorListener();\n    ErrorReporter subErrorReporter =\n        new ErrorReporter(errorListener, _errorReporter.source);\n    DartObjectImpl result = expression.accept(\n        new _ConstantVerifier_validateInitializerExpression(_typeProvider,\n            subErrorReporter, this, parameterElements, declaredVariables,\n            typeSystem: _typeSystem));\n    _reportErrors(errorListener.errors,\n        CompileTimeErrorCode.NON_CONSTANT_VALUE_IN_INITIALIZER);\n    if (result != null) {\n      _reportErrorIfFromDeferredLibrary(\n          expression,\n          CompileTimeErrorCode\n              .NON_CONSTANT_VALUE_IN_INITIALIZER_FROM_DEFERRED_LIBRARY);\n    }\n  }\n\n  /**\n   * Validates that all of the arguments of a constructor initializer are compile time constants.\n   *\n   * @param parameterElements the elements of parameters of constant constructor, they are\n   *          considered as a valid potentially constant expressions\n   * @param argumentList the argument list to validate\n   */\n  void _validateInitializerInvocationArguments(\n      List<ParameterElement> parameterElements, ArgumentList argumentList) {\n    if (argumentList == null) {\n      return;\n    }\n    for (Expression argument in argumentList.arguments) {\n      _validateInitializerExpression(parameterElements, argument);\n    }\n  }\n\n  /**\n   * Validate that if the passed instance creation is 'const' then all its arguments are constant\n   * expressions.\n   *\n   * @param node the instance creation evaluate\n   */\n  void _validateInstanceCreationArguments(InstanceCreationExpression node) {\n    if (!node.isConst) {\n      return;\n    }\n    ArgumentList argumentList = node.argumentList;\n    if (argumentList == null) {\n      return;\n    }\n    _validateConstantArguments(argumentList);\n  }\n}\n\n/**\n * Instances of the class `Dart2JSVerifier` traverse an AST structure looking for hints for\n * code that will be compiled to JS, such as [HintCode.IS_DOUBLE].\n */\nclass Dart2JSVerifier extends RecursiveAstVisitor<Object> {\n  /**\n   * The name of the `double` type.\n   */\n  static String _DOUBLE_TYPE_NAME = \"double\";\n\n  /**\n   * The error reporter by which errors will be reported.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * Create a new instance of the [Dart2JSVerifier].\n   *\n   * @param errorReporter the error reporter\n   */\n  Dart2JSVerifier(this._errorReporter);\n\n  @override\n  Object visitIsExpression(IsExpression node) {\n    _checkForIsDoubleHints(node);\n    return super.visitIsExpression(node);\n  }\n\n  /**\n   * Check for instances of `x is double`, `x is int`, `x is! double` and\n   * `x is! int`.\n   *\n   * @param node the is expression to check\n   * @return `true` if and only if a hint code is generated on the passed node\n   * See [HintCode.IS_DOUBLE],\n   * [HintCode.IS_INT],\n   * [HintCode.IS_NOT_DOUBLE], and\n   * [HintCode.IS_NOT_INT].\n   */\n  bool _checkForIsDoubleHints(IsExpression node) {\n    DartType type = node.type.type;\n    Element element = type?.element;\n    if (element != null) {\n      String typeNameStr = element.name;\n      LibraryElement libraryElement = element.library;\n      //      if (typeNameStr.equals(INT_TYPE_NAME) && libraryElement != null\n      //          && libraryElement.isDartCore()) {\n      //        if (node.getNotOperator() == null) {\n      //          errorReporter.reportError(HintCode.IS_INT, node);\n      //        } else {\n      //          errorReporter.reportError(HintCode.IS_NOT_INT, node);\n      //        }\n      //        return true;\n      //      } else\n      if (typeNameStr == _DOUBLE_TYPE_NAME &&\n          libraryElement != null &&\n          libraryElement.isDartCore) {\n        if (node.notOperator == null) {\n          _errorReporter.reportErrorForNode(HintCode.IS_DOUBLE, node);\n        } else {\n          _errorReporter.reportErrorForNode(HintCode.IS_NOT_DOUBLE, node);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * A visitor that finds dead code and unused labels.\n */\nclass DeadCodeVerifier extends RecursiveAstVisitor<Object> {\n  /**\n   * The error reporter by which errors will be reported.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   *  The type system for this visitor\n   */\n  final TypeSystem _typeSystem;\n\n  /**\n   * The object used to track the usage of labels within a given label scope.\n   */\n  _LabelTracker labelTracker;\n\n  /**\n   * Initialize a newly created dead code verifier that will report dead code to\n   * the given [errorReporter] and will use the given [typeSystem] if one is\n   * provided.\n   */\n  DeadCodeVerifier(this._errorReporter, {TypeSystem typeSystem})\n      : this._typeSystem = typeSystem ?? new TypeSystemImpl(null);\n\n  @override\n  Object visitBinaryExpression(BinaryExpression node) {\n    Token operator = node.operator;\n    bool isAmpAmp = operator.type == TokenType.AMPERSAND_AMPERSAND;\n    bool isBarBar = operator.type == TokenType.BAR_BAR;\n    if (isAmpAmp || isBarBar) {\n      Expression lhsCondition = node.leftOperand;\n      if (!_isDebugConstant(lhsCondition)) {\n        EvaluationResultImpl lhsResult = _getConstantBooleanValue(lhsCondition);\n        if (lhsResult != null) {\n          bool value = lhsResult.value.toBoolValue();\n          if (value == true && isBarBar) {\n            // report error on else block: true || !e!\n            _errorReporter.reportErrorForNode(\n                HintCode.DEAD_CODE, node.rightOperand);\n            // only visit the LHS:\n            lhsCondition?.accept(this);\n            return null;\n          } else if (value == false && isAmpAmp) {\n            // report error on if block: false && !e!\n            _errorReporter.reportErrorForNode(\n                HintCode.DEAD_CODE, node.rightOperand);\n            // only visit the LHS:\n            lhsCondition?.accept(this);\n            return null;\n          }\n        }\n      }\n      // How do we want to handle the RHS? It isn't dead code, but \"pointless\"\n      // or \"obscure\"...\n//            Expression rhsCondition = node.getRightOperand();\n//            ValidResult rhsResult = getConstantBooleanValue(rhsCondition);\n//            if (rhsResult != null) {\n//              if (rhsResult == ValidResult.RESULT_TRUE && isBarBar) {\n//                // report error on else block: !e! || true\n//                errorReporter.reportError(HintCode.DEAD_CODE, node.getRightOperand());\n//                // only visit the RHS:\n//                rhsCondition?.accept(this);\n//                return null;\n//              } else if (rhsResult == ValidResult.RESULT_FALSE && isAmpAmp) {\n//                // report error on if block: !e! && false\n//                errorReporter.reportError(HintCode.DEAD_CODE, node.getRightOperand());\n//                // only visit the RHS:\n//                rhsCondition?.accept(this);\n//                return null;\n//              }\n//            }\n    }\n    return super.visitBinaryExpression(node);\n  }\n\n  /**\n   * For each block, this method reports and error on all statements between the\n   * end of the block and the first return statement (assuming there it is not\n   * at the end of the block.)\n   */\n  @override\n  Object visitBlock(Block node) {\n    NodeList<Statement> statements = node.statements;\n    _checkForDeadStatementsInNodeList(statements);\n    return null;\n  }\n\n  @override\n  Object visitBreakStatement(BreakStatement node) {\n    labelTracker?.recordUsage(node.label?.name);\n    return null;\n  }\n\n  @override\n  Object visitConditionalExpression(ConditionalExpression node) {\n    Expression conditionExpression = node.condition;\n    conditionExpression?.accept(this);\n    if (!_isDebugConstant(conditionExpression)) {\n      EvaluationResultImpl result =\n          _getConstantBooleanValue(conditionExpression);\n      if (result != null) {\n        if (result.value.toBoolValue() == true) {\n          // report error on else block: true ? 1 : !2!\n          _errorReporter.reportErrorForNode(\n              HintCode.DEAD_CODE, node.elseExpression);\n          node.thenExpression?.accept(this);\n          return null;\n        } else {\n          // report error on if block: false ? !1! : 2\n          _errorReporter.reportErrorForNode(\n              HintCode.DEAD_CODE, node.thenExpression);\n          node.elseExpression?.accept(this);\n          return null;\n        }\n      }\n    }\n    return super.visitConditionalExpression(node);\n  }\n\n  @override\n  Object visitContinueStatement(ContinueStatement node) {\n    labelTracker?.recordUsage(node.label?.name);\n    return null;\n  }\n\n  @override\n  Object visitExportDirective(ExportDirective node) {\n    ExportElement exportElement = node.element;\n    if (exportElement != null) {\n      // The element is null when the URI is invalid\n      LibraryElement library = exportElement.exportedLibrary;\n      if (library != null && !library.isSynthetic) {\n        for (Combinator combinator in node.combinators) {\n          _checkCombinator(library, combinator);\n        }\n      }\n    }\n    return super.visitExportDirective(node);\n  }\n\n  @override\n  Object visitIfStatement(IfStatement node) {\n    Expression conditionExpression = node.condition;\n    conditionExpression?.accept(this);\n    if (!_isDebugConstant(conditionExpression)) {\n      EvaluationResultImpl result =\n          _getConstantBooleanValue(conditionExpression);\n      if (result != null) {\n        if (result.value.toBoolValue() == true) {\n          // report error on else block: if(true) {} else {!}\n          Statement elseStatement = node.elseStatement;\n          if (elseStatement != null) {\n            _errorReporter.reportErrorForNode(\n                HintCode.DEAD_CODE, elseStatement);\n            node.thenStatement?.accept(this);\n            return null;\n          }\n        } else {\n          // report error on if block: if (false) {!} else {}\n          _errorReporter.reportErrorForNode(\n              HintCode.DEAD_CODE, node.thenStatement);\n          node.elseStatement?.accept(this);\n          return null;\n        }\n      }\n    }\n    return super.visitIfStatement(node);\n  }\n\n  @override\n  Object visitImportDirective(ImportDirective node) {\n    ImportElement importElement = node.element;\n    if (importElement != null) {\n      // The element is null when the URI is invalid, but not when the URI is\n      // valid but refers to a non-existent file.\n      LibraryElement library = importElement.importedLibrary;\n      if (library != null && !library.isSynthetic) {\n        for (Combinator combinator in node.combinators) {\n          _checkCombinator(library, combinator);\n        }\n      }\n    }\n    return super.visitImportDirective(node);\n  }\n\n  @override\n  Object visitLabeledStatement(LabeledStatement node) {\n    _pushLabels(node.labels);\n    try {\n      super.visitLabeledStatement(node);\n    } finally {\n      _popLabels();\n    }\n    return null;\n  }\n\n  @override\n  Object visitSwitchCase(SwitchCase node) {\n    _checkForDeadStatementsInNodeList(node.statements, allowMandated: true);\n    return super.visitSwitchCase(node);\n  }\n\n  @override\n  Object visitSwitchDefault(SwitchDefault node) {\n    _checkForDeadStatementsInNodeList(node.statements, allowMandated: true);\n    return super.visitSwitchDefault(node);\n  }\n\n  @override\n  Object visitSwitchStatement(SwitchStatement node) {\n    List<Label> labels = <Label>[];\n    for (SwitchMember member in node.members) {\n      labels.addAll(member.labels);\n    }\n    _pushLabels(labels);\n    try {\n      super.visitSwitchStatement(node);\n    } finally {\n      _popLabels();\n    }\n    return null;\n  }\n\n  @override\n  Object visitTryStatement(TryStatement node) {\n    node.body?.accept(this);\n    node.finallyBlock?.accept(this);\n    NodeList<CatchClause> catchClauses = node.catchClauses;\n    int numOfCatchClauses = catchClauses.length;\n    List<DartType> visitedTypes = new List<DartType>();\n    for (int i = 0; i < numOfCatchClauses; i++) {\n      CatchClause catchClause = catchClauses[i];\n      if (catchClause.onKeyword != null) {\n        // on-catch clause found,verify that the exception type is not a\n        // subtype of a previous on-catch exception type\n        DartType currentType = catchClause.exceptionType?.type;\n        if (currentType != null) {\n          if (currentType.isObject) {\n            // Found catch clause clause that has Object as an exception type,\n            // this is equivalent to having a catch clause that doesn't have an\n            // exception type,visit the block, but generate an error on any\n            // following catch clauses (and don't visit them).\n            catchClause?.accept(this);\n            if (i + 1 != numOfCatchClauses) {\n              // this catch clause is not the last in the try statement\n              CatchClause nextCatchClause = catchClauses[i + 1];\n              CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];\n              int offset = nextCatchClause.offset;\n              int length = lastCatchClause.end - offset;\n              _errorReporter.reportErrorForOffset(\n                  HintCode.DEAD_CODE_CATCH_FOLLOWING_CATCH, offset, length);\n              return null;\n            }\n          }\n          int length = visitedTypes.length;\n          for (int j = 0; j < length; j++) {\n            DartType type = visitedTypes[j];\n            if (_typeSystem.isSubtypeOf(currentType, type)) {\n              CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];\n              int offset = catchClause.offset;\n              int length = lastCatchClause.end - offset;\n              _errorReporter.reportErrorForOffset(\n                  HintCode.DEAD_CODE_ON_CATCH_SUBTYPE,\n                  offset,\n                  length,\n                  [currentType.displayName, type.displayName]);\n              return null;\n            }\n          }\n          visitedTypes.add(currentType);\n        }\n        catchClause?.accept(this);\n      } else {\n        // Found catch clause clause that doesn't have an exception type,\n        // visit the block, but generate an error on any following catch clauses\n        // (and don't visit them).\n        catchClause?.accept(this);\n        if (i + 1 != numOfCatchClauses) {\n          // this catch clause is not the last in the try statement\n          CatchClause nextCatchClause = catchClauses[i + 1];\n          CatchClause lastCatchClause = catchClauses[numOfCatchClauses - 1];\n          int offset = nextCatchClause.offset;\n          int length = lastCatchClause.end - offset;\n          _errorReporter.reportErrorForOffset(\n              HintCode.DEAD_CODE_CATCH_FOLLOWING_CATCH, offset, length);\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitWhileStatement(WhileStatement node) {\n    Expression conditionExpression = node.condition;\n    conditionExpression?.accept(this);\n    if (!_isDebugConstant(conditionExpression)) {\n      EvaluationResultImpl result =\n          _getConstantBooleanValue(conditionExpression);\n      if (result != null) {\n        if (result.value.toBoolValue() == false) {\n          // report error on if block: while (false) {!}\n          _errorReporter.reportErrorForNode(HintCode.DEAD_CODE, node.body);\n          return null;\n        }\n      }\n    }\n    node.body?.accept(this);\n    return null;\n  }\n\n  /**\n   * Resolve the names in the given [combinator] in the scope of the given\n   * [library].\n   */\n  void _checkCombinator(LibraryElement library, Combinator combinator) {\n    Namespace namespace =\n        new NamespaceBuilder().createExportNamespaceForLibrary(library);\n    NodeList<SimpleIdentifier> names;\n    ErrorCode hintCode;\n    if (combinator is HideCombinator) {\n      names = combinator.hiddenNames;\n      hintCode = HintCode.UNDEFINED_HIDDEN_NAME;\n    } else {\n      names = (combinator as ShowCombinator).shownNames;\n      hintCode = HintCode.UNDEFINED_SHOWN_NAME;\n    }\n    for (SimpleIdentifier name in names) {\n      String nameStr = name.name;\n      Element element = namespace.get(nameStr);\n      if (element == null) {\n        element = namespace.get(\"$nameStr=\");\n      }\n      if (element == null) {\n        _errorReporter\n            .reportErrorForNode(hintCode, name, [library.identifier, nameStr]);\n      }\n    }\n  }\n\n  /**\n   * Given some list of [statements], loop through the list searching for dead\n   * statements. If [allowMandated] is true, then allow dead statements that are\n   * mandated by the language spec. This allows for a final break, continue,\n   * return, or throw statement at the end of a switch case, that are mandated\n   * by the language spec.\n   */\n  void _checkForDeadStatementsInNodeList(NodeList<Statement> statements,\n      {bool allowMandated: false}) {\n    bool statementExits(Statement statement) {\n      if (statement is BreakStatement) {\n        return statement.label == null;\n      } else if (statement is ContinueStatement) {\n        return statement.label == null;\n      }\n      return ExitDetector.exits(statement);\n    }\n\n    int size = statements.length;\n    for (int i = 0; i < size; i++) {\n      Statement currentStatement = statements[i];\n      currentStatement?.accept(this);\n      if (statementExits(currentStatement) && i != size - 1) {\n        Statement nextStatement = statements[i + 1];\n        Statement lastStatement = statements[size - 1];\n        // If mandated statements are allowed, and only the last statement is\n        // dead, and it's a BreakStatement, then assume it is a statement\n        // mandated by the language spec, there to avoid a\n        // CASE_BLOCK_NOT_TERMINATED error.\n        if (allowMandated && i == size - 2 && nextStatement is BreakStatement) {\n          return;\n        }\n        int offset = nextStatement.offset;\n        int length = lastStatement.end - offset;\n        _errorReporter.reportErrorForOffset(HintCode.DEAD_CODE, offset, length);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Given some [expression], return [ValidResult.RESULT_TRUE] if it is `true`,\n   * [ValidResult.RESULT_FALSE] if it is `false`, or `null` if the expression is\n   * not a constant boolean value.\n   */\n  EvaluationResultImpl _getConstantBooleanValue(Expression expression) {\n    if (expression is BooleanLiteral) {\n      if (expression.value) {\n        return new EvaluationResultImpl(\n            new DartObjectImpl(null, BoolState.from(true)));\n      } else {\n        return new EvaluationResultImpl(\n            new DartObjectImpl(null, BoolState.from(false)));\n      }\n    }\n    // Don't consider situations where we could evaluate to a constant boolean\n    // expression with the ConstantVisitor\n    // else {\n    // EvaluationResultImpl result = expression.accept(new ConstantVisitor());\n    // if (result == ValidResult.RESULT_TRUE) {\n    // return ValidResult.RESULT_TRUE;\n    // } else if (result == ValidResult.RESULT_FALSE) {\n    // return ValidResult.RESULT_FALSE;\n    // }\n    // return null;\n    // }\n    return null;\n  }\n\n  /**\n   * Return `true` if the given [expression] is resolved to a constant variable.\n   */\n  bool _isDebugConstant(Expression expression) {\n    Element element = null;\n    if (expression is Identifier) {\n      element = expression.staticElement;\n    } else if (expression is PropertyAccess) {\n      element = expression.propertyName.staticElement;\n    }\n    if (element is PropertyAccessorElement) {\n      PropertyInducingElement variable = element.variable;\n      return variable != null && variable.isConst;\n    }\n    return false;\n  }\n\n  /**\n   * Exit the most recently entered label scope after reporting any labels that\n   * were not referenced within that scope.\n   */\n  void _popLabels() {\n    for (Label label in labelTracker.unusedLabels()) {\n      _errorReporter\n          .reportErrorForNode(HintCode.UNUSED_LABEL, label, [label.label.name]);\n    }\n    labelTracker = labelTracker.outerTracker;\n  }\n\n  /**\n   * Enter a new label scope in which the given [labels] are defined.\n   */\n  void _pushLabels(List<Label> labels) {\n    labelTracker = new _LabelTracker(labelTracker, labels);\n  }\n}\n\n/**\n * A visitor that resolves directives in an AST structure to already built\n * elements.\n *\n * The resulting AST must have everything resolved that would have been resolved\n * by a [DirectiveElementBuilder].\n */\nclass DirectiveResolver extends SimpleAstVisitor {\n  final Map<Source, int> sourceModificationTimeMap;\n  final Map<Source, SourceKind> importSourceKindMap;\n  final Map<Source, SourceKind> exportSourceKindMap;\n  final List<AnalysisError> errors = <AnalysisError>[];\n\n  LibraryElement _enclosingLibrary;\n\n  DirectiveResolver(this.sourceModificationTimeMap, this.importSourceKindMap,\n      this.exportSourceKindMap);\n\n  @override\n  void visitCompilationUnit(CompilationUnit node) {\n    _enclosingLibrary =\n        resolutionMap.elementDeclaredByCompilationUnit(node).library;\n    for (Directive directive in node.directives) {\n      directive.accept(this);\n    }\n  }\n\n  @override\n  void visitExportDirective(ExportDirective node) {\n    int nodeOffset = node.offset;\n    node.element = null;\n    for (ExportElement element in _enclosingLibrary.exports) {\n      if (element.nameOffset == nodeOffset) {\n        node.element = element;\n        // Verify the exported source kind.\n        LibraryElement exportedLibrary = element.exportedLibrary;\n        if (exportedLibrary != null) {\n          Source exportedSource = exportedLibrary.source;\n          int exportedTime = sourceModificationTimeMap[exportedSource] ?? -1;\n          if (exportedTime >= 0 &&\n              exportSourceKindMap[exportedSource] != SourceKind.LIBRARY) {\n            StringLiteral uriLiteral = node.uri;\n            errors.add(new AnalysisError(\n                _enclosingLibrary.source,\n                uriLiteral.offset,\n                uriLiteral.length,\n                CompileTimeErrorCode.EXPORT_OF_NON_LIBRARY,\n                [uriLiteral.toSource()]));\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  @override\n  void visitImportDirective(ImportDirective node) {\n    int nodeOffset = node.offset;\n    node.element = null;\n    for (ImportElement element in _enclosingLibrary.imports) {\n      if (element.nameOffset == nodeOffset) {\n        node.element = element;\n        // Verify the imported source kind.\n        LibraryElement importedLibrary = element.importedLibrary;\n        if (importedLibrary != null) {\n          Source importedSource = importedLibrary.source;\n          int importedTime = sourceModificationTimeMap[importedSource] ?? -1;\n          if (importedTime >= 0 &&\n              importSourceKindMap[importedSource] != SourceKind.LIBRARY) {\n            StringLiteral uriLiteral = node.uri;\n            ErrorCode errorCode = element.isDeferred\n                ? StaticWarningCode.IMPORT_OF_NON_LIBRARY\n                : CompileTimeErrorCode.IMPORT_OF_NON_LIBRARY;\n            errors.add(new AnalysisError(\n                _enclosingLibrary.source,\n                uriLiteral.offset,\n                uriLiteral.length,\n                errorCode,\n                [uriLiteral.toSource()]));\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  @override\n  void visitLibraryDirective(LibraryDirective node) {\n    node.element = _enclosingLibrary;\n  }\n}\n\n/**\n * Instances of the class `ElementHolder` hold on to elements created while traversing an AST\n * structure so that they can be accessed when creating their enclosing element.\n */\nclass ElementHolder {\n  List<PropertyAccessorElement> _accessors;\n\n  List<ConstructorElement> _constructors;\n\n  List<ClassElement> _enums;\n\n  List<FieldElement> _fields;\n\n  List<FunctionElement> _functions;\n\n  List<LabelElement> _labels;\n\n  List<LocalVariableElement> _localVariables;\n\n  List<MethodElement> _methods;\n\n  List<ParameterElement> _parameters;\n\n  List<TopLevelVariableElement> _topLevelVariables;\n\n  List<ClassElement> _types;\n\n  List<FunctionTypeAliasElement> _typeAliases;\n\n  List<TypeParameterElement> _typeParameters;\n\n  List<PropertyAccessorElement> get accessors {\n    if (_accessors == null) {\n      return PropertyAccessorElement.EMPTY_LIST;\n    }\n    List<PropertyAccessorElement> result = _accessors;\n    _accessors = null;\n    return result;\n  }\n\n  List<ConstructorElement> get constructors {\n    if (_constructors == null) {\n      return ConstructorElement.EMPTY_LIST;\n    }\n    List<ConstructorElement> result = _constructors;\n    _constructors = null;\n    return result;\n  }\n\n  List<ClassElement> get enums {\n    if (_enums == null) {\n      return ClassElement.EMPTY_LIST;\n    }\n    List<ClassElement> result = _enums;\n    _enums = null;\n    return result;\n  }\n\n  List<FieldElement> get fields {\n    if (_fields == null) {\n      return FieldElement.EMPTY_LIST;\n    }\n    List<FieldElement> result = _fields;\n    _fields = null;\n    return result;\n  }\n\n  List<FieldElement> get fieldsWithoutFlushing {\n    if (_fields == null) {\n      return FieldElement.EMPTY_LIST;\n    }\n    List<FieldElement> result = _fields;\n    return result;\n  }\n\n  List<FunctionElement> get functions {\n    if (_functions == null) {\n      return FunctionElement.EMPTY_LIST;\n    }\n    List<FunctionElement> result = _functions;\n    _functions = null;\n    return result;\n  }\n\n  List<LabelElement> get labels {\n    if (_labels == null) {\n      return LabelElement.EMPTY_LIST;\n    }\n    List<LabelElement> result = _labels;\n    _labels = null;\n    return result;\n  }\n\n  List<LocalVariableElement> get localVariables {\n    if (_localVariables == null) {\n      return LocalVariableElement.EMPTY_LIST;\n    }\n    List<LocalVariableElement> result = _localVariables;\n    _localVariables = null;\n    return result;\n  }\n\n  List<MethodElement> get methods {\n    if (_methods == null) {\n      return MethodElement.EMPTY_LIST;\n    }\n    List<MethodElement> result = _methods;\n    _methods = null;\n    return result;\n  }\n\n  List<ParameterElement> get parameters {\n    if (_parameters == null) {\n      return ParameterElement.EMPTY_LIST;\n    }\n    List<ParameterElement> result = _parameters;\n    _parameters = null;\n    return result;\n  }\n\n  List<TopLevelVariableElement> get topLevelVariables {\n    if (_topLevelVariables == null) {\n      return TopLevelVariableElement.EMPTY_LIST;\n    }\n    List<TopLevelVariableElement> result = _topLevelVariables;\n    _topLevelVariables = null;\n    return result;\n  }\n\n  List<FunctionTypeAliasElement> get typeAliases {\n    if (_typeAliases == null) {\n      return FunctionTypeAliasElement.EMPTY_LIST;\n    }\n    List<FunctionTypeAliasElement> result = _typeAliases;\n    _typeAliases = null;\n    return result;\n  }\n\n  List<TypeParameterElement> get typeParameters {\n    if (_typeParameters == null) {\n      return TypeParameterElement.EMPTY_LIST;\n    }\n    List<TypeParameterElement> result = _typeParameters;\n    _typeParameters = null;\n    return result;\n  }\n\n  List<ClassElement> get types {\n    if (_types == null) {\n      return ClassElement.EMPTY_LIST;\n    }\n    List<ClassElement> result = _types;\n    _types = null;\n    return result;\n  }\n\n  void addAccessor(PropertyAccessorElement element) {\n    if (_accessors == null) {\n      _accessors = new List<PropertyAccessorElement>();\n    }\n    _accessors.add(element);\n  }\n\n  void addConstructor(ConstructorElement element) {\n    if (_constructors == null) {\n      _constructors = new List<ConstructorElement>();\n    }\n    _constructors.add(element);\n  }\n\n  void addEnum(ClassElement element) {\n    if (_enums == null) {\n      _enums = new List<ClassElement>();\n    }\n    _enums.add(element);\n  }\n\n  void addField(FieldElement element) {\n    if (_fields == null) {\n      _fields = new List<FieldElement>();\n    }\n    _fields.add(element);\n  }\n\n  void addFunction(FunctionElement element) {\n    if (_functions == null) {\n      _functions = new List<FunctionElement>();\n    }\n    _functions.add(element);\n  }\n\n  void addLabel(LabelElement element) {\n    if (_labels == null) {\n      _labels = new List<LabelElement>();\n    }\n    _labels.add(element);\n  }\n\n  void addLocalVariable(LocalVariableElement element) {\n    if (_localVariables == null) {\n      _localVariables = new List<LocalVariableElement>();\n    }\n    _localVariables.add(element);\n  }\n\n  void addMethod(MethodElement element) {\n    if (_methods == null) {\n      _methods = new List<MethodElement>();\n    }\n    _methods.add(element);\n  }\n\n  void addParameter(ParameterElement element) {\n    if (_parameters == null) {\n      _parameters = new List<ParameterElement>();\n    }\n    _parameters.add(element);\n  }\n\n  void addTopLevelVariable(TopLevelVariableElement element) {\n    if (_topLevelVariables == null) {\n      _topLevelVariables = new List<TopLevelVariableElement>();\n    }\n    _topLevelVariables.add(element);\n  }\n\n  void addType(ClassElement element) {\n    if (_types == null) {\n      _types = new List<ClassElement>();\n    }\n    _types.add(element);\n  }\n\n  void addTypeAlias(FunctionTypeAliasElement element) {\n    if (_typeAliases == null) {\n      _typeAliases = new List<FunctionTypeAliasElement>();\n    }\n    _typeAliases.add(element);\n  }\n\n  void addTypeParameter(TypeParameterElement element) {\n    if (_typeParameters == null) {\n      _typeParameters = new List<TypeParameterElement>();\n    }\n    _typeParameters.add(element);\n  }\n\n  FieldElement getField(String fieldName, {bool synthetic: false}) {\n    if (_fields == null) {\n      return null;\n    }\n    int length = _fields.length;\n    for (int i = 0; i < length; i++) {\n      FieldElement field = _fields[i];\n      if (field.name == fieldName && field.isSynthetic == synthetic) {\n        return field;\n      }\n    }\n    return null;\n  }\n\n  TopLevelVariableElement getTopLevelVariable(String variableName) {\n    if (_topLevelVariables == null) {\n      return null;\n    }\n    int length = _topLevelVariables.length;\n    for (int i = 0; i < length; i++) {\n      TopLevelVariableElement variable = _topLevelVariables[i];\n      if (variable.name == variableName) {\n        return variable;\n      }\n    }\n    return null;\n  }\n\n  void validate() {\n    StringBuffer buffer = new StringBuffer();\n    if (_accessors != null) {\n      buffer.write(_accessors.length);\n      buffer.write(\" accessors\");\n    }\n    if (_constructors != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_constructors.length);\n      buffer.write(\" constructors\");\n    }\n    if (_fields != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_fields.length);\n      buffer.write(\" fields\");\n    }\n    if (_functions != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_functions.length);\n      buffer.write(\" functions\");\n    }\n    if (_labels != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_labels.length);\n      buffer.write(\" labels\");\n    }\n    if (_localVariables != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_localVariables.length);\n      buffer.write(\" local variables\");\n    }\n    if (_methods != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_methods.length);\n      buffer.write(\" methods\");\n    }\n    if (_parameters != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_parameters.length);\n      buffer.write(\" parameters\");\n    }\n    if (_topLevelVariables != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_topLevelVariables.length);\n      buffer.write(\" top-level variables\");\n    }\n    if (_types != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_types.length);\n      buffer.write(\" types\");\n    }\n    if (_typeAliases != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_typeAliases.length);\n      buffer.write(\" type aliases\");\n    }\n    if (_typeParameters != null) {\n      if (buffer.length > 0) {\n        buffer.write(\"; \");\n      }\n      buffer.write(_typeParameters.length);\n      buffer.write(\" type parameters\");\n    }\n    if (buffer.length > 0) {\n      AnalysisEngine.instance.logger\n          .logError(\"Failed to capture elements: $buffer\");\n    }\n  }\n}\n\n/**\n * Instances of the class `EnumMemberBuilder` build the members in enum declarations.\n */\nclass EnumMemberBuilder extends RecursiveAstVisitor<Object> {\n  /**\n   * The type provider used to access the types needed to build an element model for enum\n   * declarations.\n   */\n  final TypeProvider _typeProvider;\n\n  /**\n   * Initialize a newly created enum member builder.\n   *\n   * @param typeProvider the type provider used to access the types needed to build an element model\n   *          for enum declarations\n   */\n  EnumMemberBuilder(this._typeProvider);\n\n  @override\n  Object visitEnumDeclaration(EnumDeclaration node) {\n    //\n    // Finish building the enum.\n    //\n    EnumElementImpl enumElement = node.name.staticElement as EnumElementImpl;\n    InterfaceType enumType = enumElement.type;\n    //\n    // Populate the fields.\n    //\n    List<FieldElement> fields = new List<FieldElement>();\n    List<PropertyAccessorElement> getters = new List<PropertyAccessorElement>();\n    InterfaceType intType = _typeProvider.intType;\n    String indexFieldName = \"index\";\n    FieldElementImpl indexField = new FieldElementImpl(indexFieldName, -1);\n    indexField.isFinal = true;\n    indexField.isSynthetic = true;\n    indexField.type = intType;\n    fields.add(indexField);\n    getters.add(_createGetter(indexField));\n    ConstFieldElementImpl valuesField = new ConstFieldElementImpl(\"values\", -1);\n    valuesField.isStatic = true;\n    valuesField.isConst = true;\n    valuesField.isSynthetic = true;\n    valuesField.type = _typeProvider.listType.instantiate(<DartType>[enumType]);\n    fields.add(valuesField);\n    getters.add(_createGetter(valuesField));\n    //\n    // Build the enum constants.\n    //\n    NodeList<EnumConstantDeclaration> constants = node.constants;\n    List<DartObjectImpl> constantValues = new List<DartObjectImpl>();\n    int constantCount = constants.length;\n    for (int i = 0; i < constantCount; i++) {\n      EnumConstantDeclaration constant = constants[i];\n      FieldElementImpl constantField = constant.name.staticElement;\n      //\n      // Create a value for the constant.\n      //\n      Map<String, DartObjectImpl> fieldMap =\n          new HashMap<String, DartObjectImpl>();\n      fieldMap[indexFieldName] = new DartObjectImpl(intType, new IntState(i));\n      DartObjectImpl value =\n          new DartObjectImpl(enumType, new GenericState(fieldMap));\n      constantValues.add(value);\n      constantField.evaluationResult = new EvaluationResultImpl(value);\n      fields.add(constantField);\n      getters.add(constantField.getter);\n    }\n    //\n    // Build the value of the 'values' field.\n    //\n    valuesField.evaluationResult = new EvaluationResultImpl(\n        new DartObjectImpl(valuesField.type, new ListState(constantValues)));\n    // Update toString() return type.\n    {\n      MethodElementImpl toStringMethod = enumElement.methods[0];\n      toStringMethod.returnType = _typeProvider.stringType;\n      toStringMethod.type = new FunctionTypeImpl(toStringMethod);\n    }\n    //\n    // Finish building the enum.\n    //\n    enumElement.fields = fields;\n    enumElement.accessors = getters;\n    // Client code isn't allowed to invoke the constructor, so we do not model\n    // it.\n    return super.visitEnumDeclaration(node);\n  }\n\n  /**\n   * Create a getter that corresponds to the given [field].\n   */\n  PropertyAccessorElement _createGetter(FieldElementImpl field) {\n    return new PropertyAccessorElementImpl_ImplicitGetter(field);\n  }\n}\n\n/**\n * Instances of the class `ExitDetector` determine whether the visited AST node is guaranteed\n * to terminate by executing a `return` statement, `throw` expression, `rethrow`\n * expression, or simple infinite loop such as `while(true)`.\n */\nclass ExitDetector extends GeneralizingAstVisitor<bool> {\n  /**\n   * Set to `true` when a `break` is encountered, and reset to `false` when a\n   * `do`, `while`, `for` or `switch` block is entered.\n   */\n  bool _enclosingBlockContainsBreak = false;\n\n  /**\n   * Set to `true` when a `continue` is encountered, and reset to `false` when a\n   * `do`, `while`, `for` or `switch` block is entered.\n   */\n  bool _enclosingBlockContainsContinue = false;\n\n  /**\n   * Add node when a labelled `break` is encountered.\n   */\n  Set<AstNode> _enclosingBlockBreaksLabel = new Set<AstNode>();\n\n  @override\n  bool visitArgumentList(ArgumentList node) =>\n      _visitExpressions(node.arguments);\n\n  @override\n  bool visitAsExpression(AsExpression node) => _nodeExits(node.expression);\n\n  @override\n  bool visitAssertInitializer(AssertInitializer node) => false;\n\n  @override\n  bool visitAssertStatement(AssertStatement node) => false;\n\n  @override\n  bool visitAssignmentExpression(AssignmentExpression node) {\n    Expression leftHandSide = node.leftHandSide;\n    if (_nodeExits(leftHandSide)) {\n      return true;\n    }\n    TokenType operatorType = node.operator.type;\n    if (operatorType == TokenType.AMPERSAND_AMPERSAND_EQ ||\n        operatorType == TokenType.BAR_BAR_EQ ||\n        operatorType == TokenType.QUESTION_QUESTION_EQ) {\n      return false;\n    }\n    if (leftHandSide is PropertyAccess &&\n        leftHandSide.operator.type == TokenType.QUESTION_PERIOD) {\n      return false;\n    }\n    return _nodeExits(node.rightHandSide);\n  }\n\n  @override\n  bool visitAwaitExpression(AwaitExpression node) =>\n      _nodeExits(node.expression);\n\n  @override\n  bool visitBinaryExpression(BinaryExpression node) {\n    Expression lhsExpression = node.leftOperand;\n    Expression rhsExpression = node.rightOperand;\n    TokenType operatorType = node.operator.type;\n    // If the operator is ||, then only consider the RHS of the binary\n    // expression if the left hand side is the false literal.\n    // TODO(jwren) Do we want to take constant expressions into account,\n    // evaluate if(false) {} differently than if(<condition>), when <condition>\n    // evaluates to a constant false value?\n    if (operatorType == TokenType.BAR_BAR) {\n      if (lhsExpression is BooleanLiteral) {\n        if (!lhsExpression.value) {\n          return _nodeExits(rhsExpression);\n        }\n      }\n      return _nodeExits(lhsExpression);\n    }\n    // If the operator is &&, then only consider the RHS of the binary\n    // expression if the left hand side is the true literal.\n    if (operatorType == TokenType.AMPERSAND_AMPERSAND) {\n      if (lhsExpression is BooleanLiteral) {\n        if (lhsExpression.value) {\n          return _nodeExits(rhsExpression);\n        }\n      }\n      return _nodeExits(lhsExpression);\n    }\n    // If the operator is ??, then don't consider the RHS of the binary\n    // expression.\n    if (operatorType == TokenType.QUESTION_QUESTION) {\n      return _nodeExits(lhsExpression);\n    }\n    return _nodeExits(lhsExpression) || _nodeExits(rhsExpression);\n  }\n\n  @override\n  bool visitBlock(Block node) => _visitStatements(node.statements);\n\n  @override\n  bool visitBlockFunctionBody(BlockFunctionBody node) => _nodeExits(node.block);\n\n  @override\n  bool visitBreakStatement(BreakStatement node) {\n    _enclosingBlockContainsBreak = true;\n    if (node.label != null) {\n      _enclosingBlockBreaksLabel.add(node.target);\n    }\n    return false;\n  }\n\n  @override\n  bool visitCascadeExpression(CascadeExpression node) =>\n      _nodeExits(node.target) || _visitExpressions(node.cascadeSections);\n\n  @override\n  bool visitConditionalExpression(ConditionalExpression node) {\n    Expression conditionExpression = node.condition;\n    Expression thenStatement = node.thenExpression;\n    Expression elseStatement = node.elseExpression;\n    // TODO(jwren) Do we want to take constant expressions into account,\n    // evaluate if(false) {} differently than if(<condition>), when <condition>\n    // evaluates to a constant false value?\n    if (_nodeExits(conditionExpression)) {\n      return true;\n    }\n    if (thenStatement == null || elseStatement == null) {\n      return false;\n    }\n    return thenStatement.accept(this) && elseStatement.accept(this);\n  }\n\n  @override\n  bool visitContinueStatement(ContinueStatement node) {\n    _enclosingBlockContainsContinue = true;\n    return false;\n  }\n\n  @override\n  bool visitDoStatement(DoStatement node) {\n    bool outerBreakValue = _enclosingBlockContainsBreak;\n    bool outerContinueValue = _enclosingBlockContainsContinue;\n    _enclosingBlockContainsBreak = false;\n    _enclosingBlockContainsContinue = false;\n    try {\n      bool bodyExits = _nodeExits(node.body);\n      bool containsBreakOrContinue =\n          _enclosingBlockContainsBreak || _enclosingBlockContainsContinue;\n      // Even if we determine that the body \"exits\", there might be break or\n      // continue statements that actually mean it _doesn't_ always exit.\n      if (bodyExits && !containsBreakOrContinue) {\n        return true;\n      }\n      Expression conditionExpression = node.condition;\n      if (_nodeExits(conditionExpression)) {\n        return true;\n      }\n      // TODO(jwren) Do we want to take all constant expressions into account?\n      if (conditionExpression is BooleanLiteral) {\n        // If do {} while (true), and the body doesn't break, then return true.\n        if (conditionExpression.value && !_enclosingBlockContainsBreak) {\n          return true;\n        }\n      }\n      return false;\n    } finally {\n      _enclosingBlockContainsBreak = outerBreakValue;\n      _enclosingBlockContainsContinue = outerContinueValue;\n    }\n  }\n\n  @override\n  bool visitEmptyStatement(EmptyStatement node) => false;\n\n  @override\n  bool visitExpressionStatement(ExpressionStatement node) =>\n      _nodeExits(node.expression);\n\n  @override\n  bool visitForEachStatement(ForEachStatement node) {\n    bool outerBreakValue = _enclosingBlockContainsBreak;\n    _enclosingBlockContainsBreak = false;\n    try {\n      return _nodeExits(node.iterable);\n    } finally {\n      _enclosingBlockContainsBreak = outerBreakValue;\n    }\n  }\n\n  @override\n  bool visitForStatement(ForStatement node) {\n    bool outerBreakValue = _enclosingBlockContainsBreak;\n    _enclosingBlockContainsBreak = false;\n    try {\n      if (node.variables != null &&\n          _visitVariableDeclarations(node.variables.variables)) {\n        return true;\n      }\n      if (node.initialization != null && _nodeExits(node.initialization)) {\n        return true;\n      }\n      Expression conditionExpression = node.condition;\n      if (conditionExpression != null && _nodeExits(conditionExpression)) {\n        return true;\n      }\n      if (_visitExpressions(node.updaters)) {\n        return true;\n      }\n      bool blockReturns = _nodeExits(node.body);\n      // TODO(jwren) Do we want to take all constant expressions into account?\n      // If for(; true; ) (or for(;;)), and the body doesn't return or the body\n      // doesn't have a break, then return true.\n      bool implicitOrExplictTrue = conditionExpression == null ||\n          (conditionExpression is BooleanLiteral && conditionExpression.value);\n      if (implicitOrExplictTrue) {\n        if (blockReturns || !_enclosingBlockContainsBreak) {\n          return true;\n        }\n      }\n      return false;\n    } finally {\n      _enclosingBlockContainsBreak = outerBreakValue;\n    }\n  }\n\n  @override\n  bool visitFunctionDeclarationStatement(FunctionDeclarationStatement node) =>\n      false;\n\n  @override\n  bool visitFunctionExpression(FunctionExpression node) => false;\n\n  @override\n  bool visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {\n    if (_nodeExits(node.function)) {\n      return true;\n    }\n    return node.argumentList.accept(this);\n  }\n\n  @override\n  bool visitGenericFunctionType(GenericFunctionType node) => false;\n\n  @override\n  bool visitIdentifier(Identifier node) => false;\n\n  @override\n  bool visitIfStatement(IfStatement node) {\n    Expression conditionExpression = node.condition;\n    Statement thenStatement = node.thenStatement;\n    Statement elseStatement = node.elseStatement;\n    if (_nodeExits(conditionExpression)) {\n      return true;\n    }\n    // TODO(jwren) Do we want to take all constant expressions into account?\n    if (conditionExpression is BooleanLiteral) {\n      if (conditionExpression.value) {\n        // if (true) ...\n        return _nodeExits(thenStatement);\n      } else if (elseStatement != null) {\n        // if (false) ...\n        return _nodeExits(elseStatement);\n      }\n    }\n    bool thenExits = _nodeExits(thenStatement);\n    bool elseExits = _nodeExits(elseStatement);\n    if (thenStatement == null || elseStatement == null) {\n      return false;\n    }\n    return thenExits && elseExits;\n  }\n\n  @override\n  bool visitIndexExpression(IndexExpression node) {\n    Expression target = node.realTarget;\n    if (_nodeExits(target)) {\n      return true;\n    }\n    if (_nodeExits(node.index)) {\n      return true;\n    }\n    return false;\n  }\n\n  @override\n  bool visitInstanceCreationExpression(InstanceCreationExpression node) =>\n      _nodeExits(node.argumentList);\n\n  @override\n  bool visitIsExpression(IsExpression node) => node.expression.accept(this);\n\n  @override\n  bool visitLabel(Label node) => false;\n\n  @override\n  bool visitLabeledStatement(LabeledStatement node) {\n    try {\n      bool statementExits = _nodeExits(node.statement);\n      bool neverBrokeFromLabel =\n          !_enclosingBlockBreaksLabel.contains(node.statement);\n      return statementExits && neverBrokeFromLabel;\n    } finally {\n      _enclosingBlockBreaksLabel.remove(node.statement);\n    }\n  }\n\n  @override\n  bool visitLiteral(Literal node) => false;\n\n  @override\n  bool visitMethodInvocation(MethodInvocation node) {\n    Expression target = node.realTarget;\n    if (target != null) {\n      if (target.accept(this)) {\n        return true;\n      }\n      if (node.operator.type == TokenType.QUESTION_PERIOD) {\n        return false;\n      }\n    }\n    Element element = node.methodName.staticElement;\n    if (element != null && element.hasAlwaysThrows) {\n      return true;\n    }\n    return _nodeExits(node.argumentList);\n  }\n\n  @override\n  bool visitNamedExpression(NamedExpression node) =>\n      node.expression.accept(this);\n\n  @override\n  bool visitParenthesizedExpression(ParenthesizedExpression node) =>\n      node.expression.accept(this);\n\n  @override\n  bool visitPostfixExpression(PostfixExpression node) => false;\n\n  @override\n  bool visitPrefixExpression(PrefixExpression node) => false;\n\n  @override\n  bool visitPropertyAccess(PropertyAccess node) {\n    Expression target = node.realTarget;\n    if (target != null && target.accept(this)) {\n      return true;\n    }\n    return false;\n  }\n\n  @override\n  bool visitRethrowExpression(RethrowExpression node) => true;\n\n  @override\n  bool visitReturnStatement(ReturnStatement node) => true;\n\n  @override\n  bool visitSuperExpression(SuperExpression node) => false;\n\n  @override\n  bool visitSwitchCase(SwitchCase node) => _visitStatements(node.statements);\n\n  @override\n  bool visitSwitchDefault(SwitchDefault node) =>\n      _visitStatements(node.statements);\n\n  @override\n  bool visitSwitchStatement(SwitchStatement node) {\n    bool outerBreakValue = _enclosingBlockContainsBreak;\n    _enclosingBlockContainsBreak = false;\n    try {\n      bool hasDefault = false;\n      bool hasNonExitingCase = false;\n      List<SwitchMember> members = node.members;\n      for (int i = 0; i < members.length; i++) {\n        SwitchMember switchMember = members[i];\n        if (switchMember is SwitchDefault) {\n          hasDefault = true;\n          // If this is the last member and there are no statements, then it\n          // does not exit.\n          if (switchMember.statements.isEmpty && i + 1 == members.length) {\n            hasNonExitingCase = true;\n            continue;\n          }\n        }\n        // For switch members with no statements, don't visit the children.\n        // Otherwise, if there children statements don't exit, mark this as a\n        // non-exiting case.\n        if (!switchMember.statements.isEmpty && !switchMember.accept(this)) {\n          hasNonExitingCase = true;\n        }\n      }\n      if (hasNonExitingCase) {\n        return false;\n      }\n      // As all cases exit, return whether that list includes `default`.\n      return hasDefault;\n    } finally {\n      _enclosingBlockContainsBreak = outerBreakValue;\n    }\n  }\n\n  @override\n  bool visitThisExpression(ThisExpression node) => false;\n\n  @override\n  bool visitThrowExpression(ThrowExpression node) => true;\n\n  @override\n  bool visitTryStatement(TryStatement node) {\n    if (_nodeExits(node.finallyBlock)) {\n      return true;\n    }\n    if (!_nodeExits(node.body)) {\n      return false;\n    }\n    for (CatchClause c in node.catchClauses) {\n      if (!_nodeExits(c.body)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @override\n  bool visitTypeName(TypeName node) => false;\n\n  @override\n  bool visitVariableDeclaration(VariableDeclaration node) {\n    Expression initializer = node.initializer;\n    if (initializer != null) {\n      return initializer.accept(this);\n    }\n    return false;\n  }\n\n  @override\n  bool visitVariableDeclarationList(VariableDeclarationList node) =>\n      _visitVariableDeclarations(node.variables);\n\n  @override\n  bool visitVariableDeclarationStatement(VariableDeclarationStatement node) {\n    NodeList<VariableDeclaration> variables = node.variables.variables;\n    for (int i = 0; i < variables.length; i++) {\n      if (variables[i].accept(this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  @override\n  bool visitWhileStatement(WhileStatement node) {\n    bool outerBreakValue = _enclosingBlockContainsBreak;\n    _enclosingBlockContainsBreak = false;\n    try {\n      Expression conditionExpression = node.condition;\n      if (conditionExpression.accept(this)) {\n        return true;\n      }\n      node.body.accept(this);\n      // TODO(jwren) Do we want to take all constant expressions into account?\n      if (conditionExpression is BooleanLiteral) {\n        // If while(true), and the body doesn't have a break, then return true.\n        // The body might be found to exit, but if there are any break\n        // statements, then it is a faulty finding. In other words:\n        //\n        // * If the body exits, and does not contain a break statement, then\n        //   it exits.\n        // * If the body does not exit, and does not contain a break statement,\n        //   then it loops infinitely (also an exit).\n        //\n        // As both conditions forbid any break statements to be found, the logic\n        // just boils down to checking [_enclosingBlockContainsBreak].\n        if (conditionExpression.value && !_enclosingBlockContainsBreak) {\n          return true;\n        }\n      }\n      return false;\n    } finally {\n      _enclosingBlockContainsBreak = outerBreakValue;\n    }\n  }\n\n  @override\n  bool visitYieldStatement(YieldStatement node) => _nodeExits(node.expression);\n\n  /**\n   * Return `true` if the given node exits.\n   *\n   * @param node the node being tested\n   * @return `true` if the given node exits\n   */\n  bool _nodeExits(AstNode node) {\n    if (node == null) {\n      return false;\n    }\n    return node.accept(this);\n  }\n\n  bool _visitExpressions(NodeList<Expression> expressions) {\n    for (int i = expressions.length - 1; i >= 0; i--) {\n      if (expressions[i].accept(this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool _visitStatements(NodeList<Statement> statements) {\n    for (int i = 0; i < statements.length; i++) {\n      if (statements[i].accept(this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool _visitVariableDeclarations(\n      NodeList<VariableDeclaration> variableDeclarations) {\n    for (int i = variableDeclarations.length - 1; i >= 0; i--) {\n      if (variableDeclarations[i].accept(this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return `true` if the given [node] exits.\n   */\n  static bool exits(AstNode node) {\n    return new ExitDetector()._nodeExits(node);\n  }\n}\n\n/**\n * A visitor that visits ASTs and fills [UsedImportedElements].\n */\nclass GatherUsedImportedElementsVisitor extends RecursiveAstVisitor {\n  final LibraryElement library;\n  final UsedImportedElements usedElements = new UsedImportedElements();\n\n  GatherUsedImportedElementsVisitor(this.library);\n\n  @override\n  void visitExportDirective(ExportDirective node) {\n    _visitDirective(node);\n  }\n\n  @override\n  void visitImportDirective(ImportDirective node) {\n    _visitDirective(node);\n  }\n\n  @override\n  void visitLibraryDirective(LibraryDirective node) {\n    _visitDirective(node);\n  }\n\n  @override\n  void visitSimpleIdentifier(SimpleIdentifier node) {\n    _visitIdentifier(node, node.staticElement);\n  }\n\n  /**\n   * If the given [identifier] is prefixed with a [PrefixElement], fill the\n   * corresponding `UsedImportedElements.prefixMap` entry and return `true`.\n   */\n  bool _recordPrefixMap(SimpleIdentifier identifier, Element element) {\n    bool recordIfTargetIsPrefixElement(Expression target) {\n      if (target is SimpleIdentifier && target.staticElement is PrefixElement) {\n        List<Element> prefixedElements = usedElements.prefixMap\n            .putIfAbsent(target.staticElement, () => <Element>[]);\n        prefixedElements.add(element);\n        return true;\n      }\n      return false;\n    }\n\n    AstNode parent = identifier.parent;\n    if (parent is MethodInvocation && parent.methodName == identifier) {\n      return recordIfTargetIsPrefixElement(parent.target);\n    }\n    if (parent is PrefixedIdentifier && parent.identifier == identifier) {\n      return recordIfTargetIsPrefixElement(parent.prefix);\n    }\n    return false;\n  }\n\n  /**\n   * Visit identifiers used by the given [directive].\n   */\n  void _visitDirective(Directive directive) {\n    directive.documentationComment?.accept(this);\n    directive.metadata.accept(this);\n  }\n\n  void _visitIdentifier(SimpleIdentifier identifier, Element element) {\n    if (element == null) {\n      return;\n    }\n    // If the element is multiply defined then call this method recursively for\n    // each of the conflicting elements.\n    if (element is MultiplyDefinedElement) {\n      List<Element> conflictingElements = element.conflictingElements;\n      int length = conflictingElements.length;\n      for (int i = 0; i < length; i++) {\n        Element elt = conflictingElements[i];\n        _visitIdentifier(identifier, elt);\n      }\n      return;\n    }\n\n    // Record `importPrefix.identifier` into 'prefixMap'.\n    if (_recordPrefixMap(identifier, element)) {\n      return;\n    }\n\n    if (element is PrefixElement) {\n      usedElements.prefixMap.putIfAbsent(element, () => <Element>[]);\n      return;\n    } else if (element.enclosingElement is! CompilationUnitElement) {\n      // Identifiers that aren't a prefix element and whose enclosing element\n      // isn't a CompilationUnit are ignored- this covers the case the\n      // identifier is a relative-reference, a reference to an identifier not\n      // imported by this library.\n      return;\n    }\n    // Ignore if an unknown library.\n    LibraryElement containingLibrary = element.library;\n    if (containingLibrary == null) {\n      return;\n    }\n    // Ignore if a local element.\n    if (library == containingLibrary) {\n      return;\n    }\n    // Remember the element.\n    usedElements.elements.add(element);\n  }\n}\n\n/**\n * An [AstVisitor] that fills [UsedLocalElements].\n */\nclass GatherUsedLocalElementsVisitor extends RecursiveAstVisitor {\n  final UsedLocalElements usedElements = new UsedLocalElements();\n\n  final LibraryElement _enclosingLibrary;\n  ClassElement _enclosingClass;\n  ExecutableElement _enclosingExec;\n\n  GatherUsedLocalElementsVisitor(this._enclosingLibrary);\n\n  @override\n  visitCatchClause(CatchClause node) {\n    SimpleIdentifier exceptionParameter = node.exceptionParameter;\n    SimpleIdentifier stackTraceParameter = node.stackTraceParameter;\n    if (exceptionParameter != null) {\n      Element element = exceptionParameter.staticElement;\n      usedElements.addCatchException(element);\n      if (stackTraceParameter != null || node.onKeyword == null) {\n        usedElements.addElement(element);\n      }\n    }\n    if (stackTraceParameter != null) {\n      Element element = stackTraceParameter.staticElement;\n      usedElements.addCatchStackTrace(element);\n    }\n    super.visitCatchClause(node);\n  }\n\n  @override\n  visitClassDeclaration(ClassDeclaration node) {\n    ClassElement enclosingClassOld = _enclosingClass;\n    try {\n      _enclosingClass = node.element;\n      super.visitClassDeclaration(node);\n    } finally {\n      _enclosingClass = enclosingClassOld;\n    }\n  }\n\n  @override\n  visitFunctionDeclaration(FunctionDeclaration node) {\n    ExecutableElement enclosingExecOld = _enclosingExec;\n    try {\n      _enclosingExec = node.element;\n      super.visitFunctionDeclaration(node);\n    } finally {\n      _enclosingExec = enclosingExecOld;\n    }\n  }\n\n  @override\n  visitFunctionExpression(FunctionExpression node) {\n    if (node.parent is! FunctionDeclaration) {\n      usedElements.addElement(node.element);\n    }\n    super.visitFunctionExpression(node);\n  }\n\n  @override\n  visitMethodDeclaration(MethodDeclaration node) {\n    ExecutableElement enclosingExecOld = _enclosingExec;\n    try {\n      _enclosingExec = node.element;\n      super.visitMethodDeclaration(node);\n    } finally {\n      _enclosingExec = enclosingExecOld;\n    }\n  }\n\n  @override\n  visitSimpleIdentifier(SimpleIdentifier node) {\n    if (node.inDeclarationContext()) {\n      return;\n    }\n    Element element = node.staticElement;\n    bool isIdentifierRead = _isReadIdentifier(node);\n    if (element is PropertyAccessorElement &&\n        element.isSynthetic &&\n        isIdentifierRead &&\n        element.variable is TopLevelVariableElement) {\n      usedElements.addElement(element.variable);\n    } else if (element is LocalVariableElement) {\n      if (isIdentifierRead) {\n        usedElements.addElement(element);\n      }\n    } else {\n      _useIdentifierElement(node);\n      if (element == null ||\n          element.enclosingElement is ClassElement &&\n              !identical(element, _enclosingExec)) {\n        usedElements.members.add(node.name);\n        if (isIdentifierRead) {\n          usedElements.readMembers.add(node.name);\n        }\n      }\n    }\n  }\n\n  /**\n   * Marks an [Element] of [node] as used in the library.\n   */\n  void _useIdentifierElement(Identifier node) {\n    Element element = node.staticElement;\n    if (element == null) {\n      return;\n    }\n    // check if a local element\n    if (!identical(element.library, _enclosingLibrary)) {\n      return;\n    }\n    // ignore references to an element from itself\n    if (identical(element, _enclosingClass)) {\n      return;\n    }\n    if (identical(element, _enclosingExec)) {\n      return;\n    }\n    // ignore places where the element is not actually used\n    if (node.parent is TypeName) {\n      if (element is ClassElement) {\n        AstNode parent2 = node.parent.parent;\n        if (parent2 is IsExpression) {\n          return;\n        }\n        if (parent2 is VariableDeclarationList) {\n          // If it's a field's type, it still counts as used.\n          if (parent2.parent is! FieldDeclaration) {\n            return;\n          }\n        }\n      }\n    }\n    // OK\n    usedElements.addElement(element);\n  }\n\n  static bool _isReadIdentifier(SimpleIdentifier node) {\n    // not reading at all\n    if (!node.inGetterContext()) {\n      return false;\n    }\n    // check if useless reading\n    AstNode parent = node.parent;\n    if (parent.parent is ExpressionStatement) {\n      if (parent is PrefixExpression || parent is PostfixExpression) {\n        // v++;\n        // ++v;\n        return false;\n      }\n      if (parent is AssignmentExpression && parent.leftHandSide == node) {\n        // v ??= doSomething();\n        //   vs.\n        // v += 2;\n        TokenType operatorType = parent.operator?.type;\n        return operatorType == TokenType.QUESTION_QUESTION_EQ;\n      }\n    }\n    // OK\n    return true;\n  }\n}\n\n/**\n * Instances of the class `ImportsVerifier` visit all of the referenced libraries in the source code\n * verifying that all of the imports are used, otherwise a [HintCode.UNUSED_IMPORT] hint is\n * generated with [generateUnusedImportHints].\n *\n * Additionally, [generateDuplicateImportHints] generates [HintCode.DUPLICATE_IMPORT] hints and\n * [HintCode.UNUSED_SHOWN_NAME] hints.\n *\n * While this class does not yet have support for an \"Organize Imports\" action, this logic built up\n * in this class could be used for such an action in the future.\n */\nclass ImportsVerifier {\n  /**\n   * All [ImportDirective]s of the current library.\n   */\n  final List<ImportDirective> _allImports = <ImportDirective>[];\n\n  /**\n   * A list of [ImportDirective]s that the current library imports, but does not use.\n   *\n   * As identifiers are visited by this visitor and an import has been identified as being used\n   * by the library, the [ImportDirective] is removed from this list. After all the sources in the\n   * library have been evaluated, this list represents the set of unused imports.\n   *\n   * See [ImportsVerifier.generateUnusedImportErrors].\n   */\n  final List<ImportDirective> _unusedImports = <ImportDirective>[];\n\n  /**\n   * After the list of [unusedImports] has been computed, this list is a proper subset of the\n   * unused imports that are listed more than once.\n   */\n  final List<ImportDirective> _duplicateImports = <ImportDirective>[];\n\n  /**\n   * The cache of [Namespace]s for [ImportDirective]s.\n   */\n  final HashMap<ImportDirective, Namespace> _namespaceMap =\n      new HashMap<ImportDirective, Namespace>();\n\n  /**\n   * This is a map between prefix elements and the import directives from which they are derived. In\n   * cases where a type is referenced via a prefix element, the import directive can be marked as\n   * used (removed from the unusedImports) by looking at the resolved `lib` in `lib.X`,\n   * instead of looking at which library the `lib.X` resolves.\n   *\n   * TODO (jwren) Since multiple [ImportDirective]s can share the same [PrefixElement],\n   * it is possible to have an unreported unused import in situations where two imports use the same\n   * prefix and at least one import directive is used.\n   */\n  final HashMap<PrefixElement, List<ImportDirective>> _prefixElementMap =\n      new HashMap<PrefixElement, List<ImportDirective>>();\n\n  /**\n   * A map of identifiers that the current library's imports show, but that the library does not\n   * use.\n   *\n   * Each import directive maps to a list of the identifiers that are imported via the \"show\"\n   * keyword.\n   *\n   * As each identifier is visited by this visitor, it is identified as being used by the library,\n   * and the identifier is removed from this map (under the import that imported it). After all the\n   * sources in the library have been evaluated, each list in this map's values present the set of\n   * unused shown elements.\n   *\n   * See [ImportsVerifier.generateUnusedShownNameHints].\n   */\n  final HashMap<ImportDirective, List<SimpleIdentifier>> _unusedShownNamesMap =\n      new HashMap<ImportDirective, List<SimpleIdentifier>>();\n\n  /**\n   * A map of names that are hidden more than once.\n   */\n  final HashMap<NamespaceDirective, List<SimpleIdentifier>>\n      _duplicateHiddenNamesMap =\n      new HashMap<NamespaceDirective, List<SimpleIdentifier>>();\n\n  /**\n   * A map of names that are shown more than once.\n   */\n  final HashMap<NamespaceDirective, List<SimpleIdentifier>>\n      _duplicateShownNamesMap =\n      new HashMap<NamespaceDirective, List<SimpleIdentifier>>();\n\n  void addImports(CompilationUnit node) {\n    for (Directive directive in node.directives) {\n      if (directive is ImportDirective) {\n        LibraryElement libraryElement = directive.uriElement;\n        if (libraryElement == null) {\n          continue;\n        }\n        _allImports.add(directive);\n        _unusedImports.add(directive);\n        //\n        // Initialize prefixElementMap\n        //\n        if (directive.asKeyword != null) {\n          SimpleIdentifier prefixIdentifier = directive.prefix;\n          if (prefixIdentifier != null) {\n            Element element = prefixIdentifier.staticElement;\n            if (element is PrefixElement) {\n              List<ImportDirective> list = _prefixElementMap[element];\n              if (list == null) {\n                list = new List<ImportDirective>();\n                _prefixElementMap[element] = list;\n              }\n              list.add(directive);\n            }\n            // TODO (jwren) Can the element ever not be a PrefixElement?\n          }\n        }\n        _addShownNames(directive);\n      }\n      if (directive is NamespaceDirective) {\n        _addDuplicateShownHiddenNames(directive);\n      }\n    }\n    if (_unusedImports.length > 1) {\n      // order the list of unusedImports to find duplicates in faster than\n      // O(n^2) time\n      List<ImportDirective> importDirectiveArray =\n          new List<ImportDirective>.from(_unusedImports);\n      importDirectiveArray.sort(ImportDirective.COMPARATOR);\n      ImportDirective currentDirective = importDirectiveArray[0];\n      for (int i = 1; i < importDirectiveArray.length; i++) {\n        ImportDirective nextDirective = importDirectiveArray[i];\n        if (ImportDirective.COMPARATOR(currentDirective, nextDirective) == 0) {\n          // Add either the currentDirective or nextDirective depending on which\n          // comes second, this guarantees that the first of the duplicates\n          // won't be highlighted.\n          if (currentDirective.offset < nextDirective.offset) {\n            _duplicateImports.add(nextDirective);\n          } else {\n            _duplicateImports.add(currentDirective);\n          }\n        }\n        currentDirective = nextDirective;\n      }\n    }\n  }\n\n  /**\n   * Any time after the defining compilation unit has been visited by this visitor, this method can\n   * be called to report an [HintCode.DUPLICATE_IMPORT] hint for each of the import directives\n   * in the [duplicateImports] list.\n   *\n   * @param errorReporter the error reporter to report the set of [HintCode.DUPLICATE_IMPORT]\n   *          hints to\n   */\n  void generateDuplicateImportHints(ErrorReporter errorReporter) {\n    int length = _duplicateImports.length;\n    for (int i = 0; i < length; i++) {\n      errorReporter.reportErrorForNode(\n          HintCode.DUPLICATE_IMPORT, _duplicateImports[i].uri);\n    }\n  }\n\n  /**\n   * Report a [HintCode.DUPLICATE_SHOWN_HIDDEN_NAME] hint for each duplicate\n   * shown or hidden name.\n   *\n   * Only call this method after all of the compilation units have been visited\n   * by this visitor.\n   *\n   * @param errorReporter the error reporter used to report the set of\n   *          [HintCode.UNUSED_SHOWN_NAME] hints\n   */\n  void generateDuplicateShownHiddenNameHints(ErrorReporter reporter) {\n    _duplicateHiddenNamesMap.forEach(\n        (NamespaceDirective directive, List<SimpleIdentifier> identifiers) {\n      int length = identifiers.length;\n      for (int i = 0; i < length; i++) {\n        Identifier identifier = identifiers[i];\n        reporter.reportErrorForNode(\n            HintCode.DUPLICATE_HIDDEN_NAME, identifier, [identifier.name]);\n      }\n    });\n    _duplicateShownNamesMap.forEach(\n        (NamespaceDirective directive, List<SimpleIdentifier> identifiers) {\n      int length = identifiers.length;\n      for (int i = 0; i < length; i++) {\n        Identifier identifier = identifiers[i];\n        reporter.reportErrorForNode(\n            HintCode.DUPLICATE_SHOWN_NAME, identifier, [identifier.name]);\n      }\n    });\n  }\n\n  /**\n   * Report an [HintCode.UNUSED_IMPORT] hint for each unused import.\n   *\n   * Only call this method after all of the compilation units have been visited by this visitor.\n   *\n   * @param errorReporter the error reporter used to report the set of [HintCode.UNUSED_IMPORT]\n   *          hints\n   */\n  void generateUnusedImportHints(ErrorReporter errorReporter) {\n    int length = _unusedImports.length;\n    for (int i = 0; i < length; i++) {\n      ImportDirective unusedImport = _unusedImports[i];\n      // Check that the imported URI exists and isn't dart:core\n      ImportElement importElement = unusedImport.element;\n      if (importElement != null) {\n        LibraryElement libraryElement = importElement.importedLibrary;\n        if (libraryElement == null ||\n            libraryElement.isDartCore ||\n            libraryElement.isSynthetic) {\n          continue;\n        }\n      }\n      StringLiteral uri = unusedImport.uri;\n      errorReporter\n          .reportErrorForNode(HintCode.UNUSED_IMPORT, uri, [uri.stringValue]);\n    }\n  }\n\n  /**\n   * Report an [HintCode.UNUSED_SHOWN_NAME] hint for each unused shown name.\n   *\n   * Only call this method after all of the compilation units have been visited by this visitor.\n   *\n   * @param errorReporter the error reporter used to report the set of [HintCode.UNUSED_SHOWN_NAME]\n   *          hints\n   */\n  void generateUnusedShownNameHints(ErrorReporter reporter) {\n    _unusedShownNamesMap.forEach(\n        (ImportDirective importDirective, List<SimpleIdentifier> identifiers) {\n      if (_unusedImports.contains(importDirective)) {\n        // This import is actually wholly unused, not just one or more shown names from it.\n        // This is then an \"unused import\", rather than unused shown names.\n        return;\n      }\n      int length = identifiers.length;\n      for (int i = 0; i < length; i++) {\n        Identifier identifier = identifiers[i];\n        reporter.reportErrorForNode(\n            HintCode.UNUSED_SHOWN_NAME, identifier, [identifier.name]);\n      }\n    });\n  }\n\n  /**\n   * Remove elements from [_unusedImports] using the given [usedElements].\n   */\n  void removeUsedElements(UsedImportedElements usedElements) {\n    // Stop if all the imports and shown names are known to be used.\n    if (_unusedImports.isEmpty && _unusedShownNamesMap.isEmpty) {\n      return;\n    }\n    // Process import prefixes.\n    usedElements.prefixMap\n        .forEach((PrefixElement prefix, List<Element> elements) {\n      List<ImportDirective> importDirectives = _prefixElementMap[prefix];\n      if (importDirectives != null) {\n        int importLength = importDirectives.length;\n        for (int i = 0; i < importLength; i++) {\n          ImportDirective importDirective = importDirectives[i];\n          _unusedImports.remove(importDirective);\n          int elementLength = elements.length;\n          for (int j = 0; j < elementLength; j++) {\n            Element element = elements[j];\n            _removeFromUnusedShownNamesMap(element, importDirective);\n          }\n        }\n      }\n    });\n    // Process top-level elements.\n    for (Element element in usedElements.elements) {\n      // Stop if all the imports and shown names are known to be used.\n      if (_unusedImports.isEmpty && _unusedShownNamesMap.isEmpty) {\n        return;\n      }\n      // Find import directives using namespaces.\n      String name = element.name;\n      for (ImportDirective importDirective in _allImports) {\n        Namespace namespace = _computeNamespace(importDirective);\n        if (namespace?.get(name) != null) {\n          _unusedImports.remove(importDirective);\n          _removeFromUnusedShownNamesMap(element, importDirective);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add duplicate shown and hidden names from [directive] into\n   * [_duplicateHiddenNamesMap] and [_duplicateShownNamesMap].\n   */\n  void _addDuplicateShownHiddenNames(NamespaceDirective directive) {\n    if (directive.combinators == null) {\n      return;\n    }\n    for (Combinator combinator in directive.combinators) {\n      // Use a Set to find duplicates in faster than O(n^2) time.\n      Set<Element> identifiers = new Set<Element>();\n      if (combinator is HideCombinator) {\n        for (SimpleIdentifier name in combinator.hiddenNames) {\n          if (name.staticElement != null) {\n            if (!identifiers.add(name.staticElement)) {\n              // [name] is a duplicate.\n              List<SimpleIdentifier> duplicateNames = _duplicateHiddenNamesMap\n                  .putIfAbsent(directive, () => new List<SimpleIdentifier>());\n              duplicateNames.add(name);\n            }\n          }\n        }\n      } else if (combinator is ShowCombinator) {\n        for (SimpleIdentifier name in combinator.shownNames) {\n          if (name.staticElement != null) {\n            if (!identifiers.add(name.staticElement)) {\n              // [name] is a duplicate.\n              List<SimpleIdentifier> duplicateNames = _duplicateShownNamesMap\n                  .putIfAbsent(directive, () => new List<SimpleIdentifier>());\n              duplicateNames.add(name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add every shown name from [importDirective] into [_unusedShownNamesMap].\n   */\n  void _addShownNames(ImportDirective importDirective) {\n    if (importDirective.combinators == null) {\n      return;\n    }\n    List<SimpleIdentifier> identifiers = new List<SimpleIdentifier>();\n    _unusedShownNamesMap[importDirective] = identifiers;\n    for (Combinator combinator in importDirective.combinators) {\n      if (combinator is ShowCombinator) {\n        for (SimpleIdentifier name in combinator.shownNames) {\n          if (name.staticElement != null) {\n            identifiers.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Lookup and return the [Namespace] from the [_namespaceMap].\n   *\n   * If the map does not have the computed namespace, compute it and cache it in the map. If\n   * [importDirective] is not resolved or is not resolvable, `null` is returned.\n   *\n   * @param importDirective the import directive used to compute the returned namespace\n   * @return the computed or looked up [Namespace]\n   */\n  Namespace _computeNamespace(ImportDirective importDirective) {\n    Namespace namespace = _namespaceMap[importDirective];\n    if (namespace == null) {\n      // If the namespace isn't in the namespaceMap, then compute and put it in\n      // the map.\n      ImportElement importElement = importDirective.element;\n      if (importElement != null) {\n        namespace = importElement.namespace;\n        _namespaceMap[importDirective] = namespace;\n      }\n    }\n    return namespace;\n  }\n\n  /**\n   * Remove [element] from the list of names shown by [importDirective].\n   */\n  void _removeFromUnusedShownNamesMap(\n      Element element, ImportDirective importDirective) {\n    List<SimpleIdentifier> identifiers = _unusedShownNamesMap[importDirective];\n    if (identifiers == null) {\n      return;\n    }\n    int length = identifiers.length;\n    for (int i = 0; i < length; i++) {\n      Identifier identifier = identifiers[i];\n      if (element is PropertyAccessorElement) {\n        // If the getter or setter of a variable is used, then the variable (the\n        // shown name) is used.\n        if (identifier.staticElement == element.variable) {\n          identifiers.remove(identifier);\n          break;\n        }\n      } else {\n        if (identifier.staticElement == element) {\n          identifiers.remove(identifier);\n          break;\n        }\n      }\n    }\n    if (identifiers.isEmpty) {\n      _unusedShownNamesMap.remove(importDirective);\n    }\n  }\n}\n\n/**\n * Maintains and manages contextual type information used for\n * inferring types.\n */\nclass InferenceContext {\n  // TODO(leafp): Consider replacing these node properties with a\n  // hash table help in an instance of this class.\n  static const String _typeProperty =\n      'analyzer.src.generated.InferenceContext.contextType';\n\n  /**\n   * The error listener on which to record inference information.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * If true, emit hints when types are inferred\n   */\n  final bool _inferenceHints;\n\n  /**\n   * Type provider, needed for type matching.\n   */\n  final TypeProvider _typeProvider;\n\n  /**\n   * The type system in use.\n   */\n  final TypeSystem _typeSystem;\n\n  /**\n   * When no context type is available, this will track the least upper bound\n   * of all return statements in a lambda.\n   *\n   * This will always be kept in sync with [_returnStack].\n   */\n  final List<DartType> _inferredReturn = <DartType>[];\n\n  /**\n   * A stack of return types for all of the enclosing\n   * functions and methods.\n   */\n  final List<DartType> _returnStack = <DartType>[];\n\n  InferenceContext._(TypeProvider typeProvider, this._typeSystem,\n      this._inferenceHints, this._errorReporter)\n      : _typeProvider = typeProvider;\n\n  /**\n   * Get the return type of the current enclosing function, if any.\n   *\n   * The type returned for a function is the type that is expected\n   * to be used in a return or yield context.  For ordinary functions\n   * this is the same as the return type of the function.  For async\n   * functions returning Future<T> and for generator functions\n   * returning Stream<T> or Iterable<T>, this is T.\n   */\n  DartType get returnContext =>\n      _returnStack.isNotEmpty ? _returnStack.last : null;\n\n  /**\n   * Records the type of the expression of a return statement.\n   *\n   * This will be used for inferring a block bodied lambda, if no context\n   * type was available.\n   */\n  void addReturnOrYieldType(DartType type) {\n    if (_returnStack.isEmpty) {\n      return;\n    }\n\n    DartType inferred = _inferredReturn.last;\n    inferred = _typeSystem.getLeastUpperBound(type, inferred);\n    _inferredReturn[_inferredReturn.length - 1] = inferred;\n  }\n\n  /**\n   * Pop a return type off of the return stack.\n   *\n   * Also record any inferred return type using [setType], unless this node\n   * already has a context type. This recorded type will be the least upper\n   * bound of all types added with [addReturnOrYieldType].\n   */\n  void popReturnContext(FunctionBody node) {\n    if (_returnStack.isNotEmpty && _inferredReturn.isNotEmpty) {\n      DartType context = _returnStack.removeLast() ?? DynamicTypeImpl.instance;\n      DartType inferred = _inferredReturn.removeLast();\n\n      if (_typeSystem.isSubtypeOf(inferred, context)) {\n        setType(node, inferred);\n      }\n    } else {\n      assert(false);\n    }\n  }\n\n  /**\n   * Push a block function body's return type onto the return stack.\n   */\n  void pushReturnContext(FunctionBody node) {\n    _returnStack.add(getContext(node));\n    _inferredReturn.add(_typeProvider.nullType);\n  }\n\n  /**\n   * Place an info node into the error stream indicating that a\n   * [type] has been inferred as the type of [node].\n   */\n  void recordInference(Expression node, DartType type) {\n    if (!_inferenceHints) {\n      return;\n    }\n\n    ErrorCode error;\n    if (node is Literal) {\n      error = StrongModeCode.INFERRED_TYPE_LITERAL;\n    } else if (node is InstanceCreationExpression) {\n      error = StrongModeCode.INFERRED_TYPE_ALLOCATION;\n    } else if (node is FunctionExpression) {\n      error = StrongModeCode.INFERRED_TYPE_CLOSURE;\n    } else {\n      error = StrongModeCode.INFERRED_TYPE;\n    }\n\n    _errorReporter.reportErrorForNode(error, node, [node, type]);\n  }\n\n  /**\n   * Clear the type information associated with [node].\n   */\n  static void clearType(AstNode node) {\n    node?.setProperty(_typeProperty, null);\n  }\n\n  /**\n   * Look for contextual type information attached to [node], and returns\n   * the type if found.\n   *\n   * The returned type may be partially or completely unknown, denoted with an\n   * unknown type `?`, for example `List<?>` or `(?, int) -> void`.\n   * You can use [StrongTypeSystemImpl.upperBoundForType] or\n   * [StrongTypeSystemImpl.lowerBoundForType] if you would prefer a known type\n   * that represents the bound of the context type.\n   */\n  static DartType getContext(AstNode node) => node?.getProperty(_typeProperty);\n\n  /**\n   * Attach contextual type information [type] to [node] for use during\n   * inference.\n   */\n  static void setType(AstNode node, DartType type) {\n    if (type == null || type.isDynamic) {\n      clearType(node);\n    } else {\n      node?.setProperty(_typeProperty, type);\n    }\n  }\n\n  /**\n   * Attach contextual type information [type] to [node] for use during\n   * inference.\n   */\n  static void setTypeFromNode(AstNode innerNode, AstNode outerNode) {\n    setType(innerNode, getContext(outerNode));\n  }\n}\n\n/**\n * The four states of a field initialization state through a constructor\n * signature, not initialized, initialized in the field declaration, initialized\n * in the field formal, and finally, initialized in the initializers list.\n */\nclass INIT_STATE implements Comparable<INIT_STATE> {\n  static const INIT_STATE NOT_INIT = const INIT_STATE('NOT_INIT', 0);\n\n  static const INIT_STATE INIT_IN_DECLARATION =\n      const INIT_STATE('INIT_IN_DECLARATION', 1);\n\n  static const INIT_STATE INIT_IN_FIELD_FORMAL =\n      const INIT_STATE('INIT_IN_FIELD_FORMAL', 2);\n\n  static const INIT_STATE INIT_IN_INITIALIZERS =\n      const INIT_STATE('INIT_IN_INITIALIZERS', 3);\n\n  static const List<INIT_STATE> values = const [\n    NOT_INIT,\n    INIT_IN_DECLARATION,\n    INIT_IN_FIELD_FORMAL,\n    INIT_IN_INITIALIZERS\n  ];\n\n  /**\n   * The name of this init state.\n   */\n  final String name;\n\n  /**\n   * The ordinal value of the init state.\n   */\n  final int ordinal;\n\n  const INIT_STATE(this.name, this.ordinal);\n\n  @override\n  int get hashCode => ordinal;\n\n  @override\n  int compareTo(INIT_STATE other) => ordinal - other.ordinal;\n\n  @override\n  String toString() => name;\n}\n\n/**\n * An AST visitor that is used to re-resolve the initializers of instance\n * fields. Although this class is an AST visitor, clients are expected to use\n * the method [resolveCompilationUnit] to run it over a compilation unit.\n */\nclass InstanceFieldResolverVisitor extends ResolverVisitor {\n  /**\n   * Initialize a newly created visitor to resolve the nodes in an AST node.\n   *\n   * The [definingLibrary] is the element for the library containing the node\n   * being visited. The [source] is the source representing the compilation unit\n   * containing the node being visited. The [typeProvider] is the object used to\n   * access the types from the core library. The [errorListener] is the error\n   * listener that will be informed of any errors that are found during\n   * resolution. The [nameScope] is the scope used to resolve identifiers in the\n   * node that will first be visited.  If `null` or unspecified, a new\n   * [LibraryScope] will be created based on the [definingLibrary].\n   */\n  InstanceFieldResolverVisitor(LibraryElement definingLibrary, Source source,\n      TypeProvider typeProvider, AnalysisErrorListener errorListener,\n      {Scope nameScope})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope);\n\n  /**\n   * Resolve the instance fields in the given compilation unit [node].\n   */\n  void resolveCompilationUnit(CompilationUnit node) {\n    _overrideManager.enterScope();\n    try {\n      NodeList<CompilationUnitMember> declarations = node.declarations;\n      int declarationCount = declarations.length;\n      for (int i = 0; i < declarationCount; i++) {\n        CompilationUnitMember declaration = declarations[i];\n        if (declaration is ClassDeclaration) {\n          _resolveClassDeclaration(declaration);\n        }\n      }\n    } finally {\n      _overrideManager.exitScope();\n    }\n  }\n\n  /**\n   * Resolve the instance fields in the given class declaration [node].\n   */\n  void _resolveClassDeclaration(ClassDeclaration node) {\n    _enclosingClassDeclaration = node;\n    ClassElement outerType = enclosingClass;\n    Scope outerScope = nameScope;\n    try {\n      enclosingClass = node.element;\n      typeAnalyzer.thisType = enclosingClass?.type;\n      if (enclosingClass == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for class declaration ${node.name.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n        // Don't try to re-resolve the initializers if we cannot set up the\n        // right name scope for resolution.\n      } else {\n        nameScope = new ClassScope(nameScope, enclosingClass);\n        NodeList<ClassMember> members = node.members;\n        int length = members.length;\n        for (int i = 0; i < length; i++) {\n          ClassMember member = members[i];\n          if (member is FieldDeclaration) {\n            _resolveFieldDeclaration(member);\n          }\n        }\n      }\n    } finally {\n      nameScope = outerScope;\n      typeAnalyzer.thisType = outerType?.type;\n      enclosingClass = outerType;\n      _enclosingClassDeclaration = null;\n    }\n  }\n\n  /**\n   * Resolve the instance fields in the given field declaration [node].\n   */\n  void _resolveFieldDeclaration(FieldDeclaration node) {\n    if (!node.isStatic) {\n      for (VariableDeclaration field in node.fields.variables) {\n        if (field.initializer != null) {\n          field.initializer.accept(this);\n          FieldElement fieldElement = field.name.staticElement;\n          if (fieldElement.initializer != null) {\n            (fieldElement.initializer as ExecutableElementImpl).returnType =\n                field.initializer.staticType;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Instances of the class `OverrideVerifier` visit all of the declarations in a compilation\n * unit to verify that if they have an override annotation it is being used correctly.\n */\nclass OverrideVerifier extends RecursiveAstVisitor {\n  /**\n   * The error reporter used to report errors.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * The inheritance manager used to find overridden methods.\n   */\n  final InheritanceManager _manager;\n\n  /**\n   * Initialize a newly created verifier to look for inappropriate uses of the override annotation.\n   *\n   * @param errorReporter the error reporter used to report errors\n   * @param manager the inheritance manager used to find overridden methods\n   */\n  OverrideVerifier(this._errorReporter, this._manager);\n\n  @override\n  visitFieldDeclaration(FieldDeclaration node) {\n    for (VariableDeclaration field in node.fields.variables) {\n      VariableElement fieldElement = field.element;\n      if (fieldElement is FieldElement && _isOverride(fieldElement)) {\n        PropertyAccessorElement getter = fieldElement.getter;\n        PropertyAccessorElement setter = fieldElement.setter;\n        if (!(getter != null && _getOverriddenMember(getter) != null ||\n            setter != null && _getOverriddenMember(setter) != null)) {\n          _errorReporter.reportErrorForNode(\n              HintCode.OVERRIDE_ON_NON_OVERRIDING_FIELD, field.name);\n        }\n      }\n    }\n  }\n\n  @override\n  visitMethodDeclaration(MethodDeclaration node) {\n    ExecutableElement element = node.element;\n    if (_isOverride(element)) {\n      if (_getOverriddenMember(element) == null) {\n        if (element is MethodElement) {\n          _errorReporter.reportErrorForNode(\n              HintCode.OVERRIDE_ON_NON_OVERRIDING_METHOD, node.name);\n        } else if (element is PropertyAccessorElement) {\n          if (element.isGetter) {\n            _errorReporter.reportErrorForNode(\n                HintCode.OVERRIDE_ON_NON_OVERRIDING_GETTER, node.name);\n          } else {\n            _errorReporter.reportErrorForNode(\n                HintCode.OVERRIDE_ON_NON_OVERRIDING_SETTER, node.name);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Return the member that overrides the given member.\n   *\n   * @param member the member that overrides the returned member\n   * @return the member that overrides the given member\n   */\n  ExecutableElement _getOverriddenMember(ExecutableElement member) {\n    LibraryElement library = member.library;\n    if (library == null) {\n      return null;\n    }\n    ClassElement classElement =\n        member.getAncestor((element) => element is ClassElement);\n    if (classElement == null) {\n      return null;\n    }\n    return _manager.lookupInheritance(classElement, member.name);\n  }\n\n  /**\n   * Return `true` if the given element has an override annotation associated with it.\n   *\n   * @param element the element being tested\n   * @return `true` if the element has an override annotation associated with it\n   */\n  bool _isOverride(Element element) => element != null && element.hasOverride;\n}\n\n/**\n * An AST visitor that is used to resolve the some of the nodes within a single\n * compilation unit. The nodes that are skipped are those that are within\n * function bodies.\n */\nclass PartialResolverVisitor extends ResolverVisitor {\n  /**\n   * The static variables and fields that have an initializer. These are the\n   * variables that need to be re-resolved after static variables have their\n   * types inferred. A subset of these variables are those whose types should\n   * be inferred.\n   */\n  final List<VariableElement> staticVariables = <VariableElement>[];\n\n  /**\n   * Initialize a newly created visitor to resolve the nodes in an AST node.\n   *\n   * The [definingLibrary] is the element for the library containing the node\n   * being visited. The [source] is the source representing the compilation unit\n   * containing the node being visited. The [typeProvider] is the object used to\n   * access the types from the core library. The [errorListener] is the error\n   * listener that will be informed of any errors that are found during\n   * resolution. The [nameScope] is the scope used to resolve identifiers in the\n   * node that will first be visited.  If `null` or unspecified, a new\n   * [LibraryScope] will be created based on [definingLibrary] and\n   * [typeProvider]. The [inheritanceManager] is used to perform inheritance\n   * lookups.  If `null` or unspecified, a new [InheritanceManager] will be\n   * created based on [definingLibrary]. The [typeAnalyzerFactory] is used to\n   * create the type analyzer.  If `null` or unspecified, a type analyzer of\n   * type [StaticTypeAnalyzer] will be created.\n   */\n  PartialResolverVisitor(LibraryElement definingLibrary, Source source,\n      TypeProvider typeProvider, AnalysisErrorListener errorListener,\n      {Scope nameScope})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope);\n\n  @override\n  Object visitBlockFunctionBody(BlockFunctionBody node) {\n    if (_shouldBeSkipped(node)) {\n      return null;\n    }\n    return super.visitBlockFunctionBody(node);\n  }\n\n  @override\n  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {\n    if (_shouldBeSkipped(node)) {\n      return null;\n    }\n    return super.visitExpressionFunctionBody(node);\n  }\n\n  @override\n  Object visitFieldDeclaration(FieldDeclaration node) {\n    if (node.isStatic) {\n      _addStaticVariables(node.fields.variables);\n    }\n    return super.visitFieldDeclaration(node);\n  }\n\n  @override\n  Object visitNode(AstNode node) {\n    return super.visitNode(node);\n  }\n\n  @override\n  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {\n    _addStaticVariables(node.variables.variables);\n    return super.visitTopLevelVariableDeclaration(node);\n  }\n\n  /**\n   * Add all of the [variables] with initializers to the list of variables whose\n   * type can be inferred. Technically, we only infer the types of variables\n   * that do not have a static type, but all variables with initializers\n   * potentially need to be re-resolved after inference because they might\n   * refer to a field whose type was inferred.\n   */\n  void _addStaticVariables(List<VariableDeclaration> variables) {\n    int length = variables.length;\n    for (int i = 0; i < length; i++) {\n      VariableDeclaration variable = variables[i];\n      if (variable.name.name.isNotEmpty && variable.initializer != null) {\n        staticVariables.add(variable.element);\n      }\n    }\n  }\n\n  /**\n   * Return `true` if the given function body should be skipped because it is\n   * the body of a top-level function, method or constructor.\n   */\n  bool _shouldBeSkipped(FunctionBody body) {\n    AstNode parent = body.parent;\n    if (parent is MethodDeclaration) {\n      return parent.body == body;\n    }\n    if (parent is ConstructorDeclaration) {\n      return parent.body == body;\n    }\n    if (parent is FunctionExpression) {\n      AstNode parent2 = parent.parent;\n      if (parent2 is FunctionDeclaration &&\n          parent2.parent is! FunctionDeclarationStatement) {\n        return parent.body == body;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Kind of the redirecting constructor.\n */\nclass RedirectingConstructorKind\n    implements Comparable<RedirectingConstructorKind> {\n  static const RedirectingConstructorKind CONST =\n      const RedirectingConstructorKind('CONST', 0);\n\n  static const RedirectingConstructorKind NORMAL =\n      const RedirectingConstructorKind('NORMAL', 1);\n\n  static const List<RedirectingConstructorKind> values = const [CONST, NORMAL];\n\n  /**\n   * The name of this redirecting constructor kind.\n   */\n  final String name;\n\n  /**\n   * The ordinal value of the redirecting constructor kind.\n   */\n  final int ordinal;\n\n  const RedirectingConstructorKind(this.name, this.ordinal);\n\n  @override\n  int get hashCode => ordinal;\n\n  @override\n  int compareTo(RedirectingConstructorKind other) => ordinal - other.ordinal;\n\n  @override\n  String toString() => name;\n}\n\n/**\n * The enumeration `ResolverErrorCode` defines the error codes used for errors\n * detected by the resolver. The convention for this class is for the name of\n * the error code to indicate the problem that caused the error to be generated\n * and for the error message to explain what is wrong and, when appropriate, how\n * the problem can be corrected.\n */\nclass ResolverErrorCode extends ErrorCode {\n  static const ResolverErrorCode BREAK_LABEL_ON_SWITCH_MEMBER =\n      const ResolverErrorCode('BREAK_LABEL_ON_SWITCH_MEMBER',\n          \"Break label resolves to case or default statement\");\n\n  static const ResolverErrorCode CONTINUE_LABEL_ON_SWITCH =\n      const ResolverErrorCode('CONTINUE_LABEL_ON_SWITCH',\n          \"A continue label resolves to switch, must be loop or switch member\");\n\n  static const ResolverErrorCode MISSING_LIBRARY_DIRECTIVE_WITH_PART =\n      const ResolverErrorCode('MISSING_LIBRARY_DIRECTIVE_WITH_PART',\n          \"Libraries that have parts must have a library directive\");\n\n  /**\n   * Parts: It is a static warning if the referenced part declaration\n   * <i>p</i> names a library that does not have a library tag.\n   *\n   * Parameters:\n   * 0: the URI of the expected library\n   * 1: the non-matching actual library name from the \"part of\" declaration\n   */\n  static const ResolverErrorCode PART_OF_UNNAMED_LIBRARY =\n      const ResolverErrorCode(\n          'PART_OF_UNNAMED_LIBRARY',\n          \"Library is unnamed. Expected a URI not a library name '{0}' in the \"\n          \"part-of directive.\",\n          correction:\n              \"Try changing the part-of directive to a URI, or try including a\"\n              \" different part.\");\n\n  /**\n   * Initialize a newly created error code to have the given [name]. The message\n   * associated with the error will be created from the given [message]\n   * template. The correction associated with the error will be created from the\n   * given [correction] template.\n   */\n  const ResolverErrorCode(String name, String message, {String correction})\n      : super.temporary(name, message, correction: correction);\n\n  @override\n  ErrorSeverity get errorSeverity => type.severity;\n\n  @override\n  ErrorType get type => ErrorType.COMPILE_TIME_ERROR;\n}\n\n/**\n * Instances of the class `ResolverVisitor` are used to resolve the nodes within a single\n * compilation unit.\n */\nclass ResolverVisitor extends ScopedVisitor {\n  /**\n   * The object used to resolve the element associated with the current node.\n   */\n  ElementResolver elementResolver;\n\n  /**\n   * The object used to compute the type associated with the current node.\n   */\n  StaticTypeAnalyzer typeAnalyzer;\n\n  /**\n   * The type system in use during resolution.\n   */\n  TypeSystem typeSystem;\n\n  /**\n   * The class declaration representing the class containing the current node, or `null` if\n   * the current node is not contained in a class.\n   */\n  ClassDeclaration _enclosingClassDeclaration = null;\n\n  /**\n   * The function type alias representing the function type containing the current node, or\n   * `null` if the current node is not contained in a function type alias.\n   */\n  FunctionTypeAlias _enclosingFunctionTypeAlias = null;\n\n  /**\n   * The element representing the function containing the current node, or `null` if the\n   * current node is not contained in a function.\n   */\n  ExecutableElement _enclosingFunction = null;\n\n  InferenceContext inferenceContext = null;\n\n  /**\n   * The object keeping track of which elements have had their types overridden.\n   */\n  TypeOverrideManager _overrideManager = new TypeOverrideManager();\n\n  /**\n   * The object keeping track of which elements have had their types promoted.\n   */\n  TypePromotionManager _promoteManager = new TypePromotionManager();\n\n  /**\n   * A comment before a function should be resolved in the context of the\n   * function. But when we incrementally resolve a comment, we don't want to\n   * resolve the whole function.\n   *\n   * So, this flag is set to `true`, when just context of the function should\n   * be built and the comment resolved.\n   */\n  bool resolveOnlyCommentInFunctionBody = false;\n\n  /**\n   * Body of the function currently being analyzed, if any.\n   */\n  FunctionBody _currentFunctionBody;\n\n  /**\n   * The type of the expression of the immediately enclosing [SwitchStatement],\n   * or `null` if not in a [SwitchStatement].\n   */\n  DartType _enclosingSwitchStatementExpressionType;\n\n  /**\n   * Are we running in strong mode or not.\n   */\n  bool strongMode;\n\n  /**\n   * Initialize a newly created visitor to resolve the nodes in an AST node.\n   *\n   * The [definingLibrary] is the element for the library containing the node\n   * being visited. The [source] is the source representing the compilation unit\n   * containing the node being visited. The [typeProvider] is the object used to\n   * access the types from the core library. The [errorListener] is the error\n   * listener that will be informed of any errors that are found during\n   * resolution. The [nameScope] is the scope used to resolve identifiers in the\n   * node that will first be visited.  If `null` or unspecified, a new\n   * [LibraryScope] will be created based on [definingLibrary] and\n   * [typeProvider]. The [inheritanceManager] is used to perform inheritance\n   * lookups.  If `null` or unspecified, a new [InheritanceManager] will be\n   * created based on [definingLibrary]. The [typeAnalyzerFactory] is used to\n   * create the type analyzer.  If `null` or unspecified, a type analyzer of\n   * type [StaticTypeAnalyzer] will be created.\n   */\n  ResolverVisitor(LibraryElement definingLibrary, Source source,\n      TypeProvider typeProvider, AnalysisErrorListener errorListener,\n      {Scope nameScope,\n      bool propagateTypes: true,\n      reportConstEvaluationErrors: true})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope) {\n    AnalysisOptions options = definingLibrary.context.analysisOptions;\n    this.strongMode = options.strongMode;\n    this.elementResolver = new ElementResolver(this,\n        reportConstEvaluationErrors: reportConstEvaluationErrors);\n    this.typeSystem = definingLibrary.context.typeSystem;\n    bool strongModeHints = false;\n    if (options is AnalysisOptionsImpl) {\n      strongModeHints = options.strongModeHints;\n    }\n    this.inferenceContext = new InferenceContext._(\n        typeProvider, typeSystem, strongModeHints, errorReporter);\n    this.typeAnalyzer =\n        new StaticTypeAnalyzer(this, propagateTypes: propagateTypes);\n  }\n\n  /**\n   * Return the element representing the function containing the current node, or `null` if\n   * the current node is not contained in a function.\n   *\n   * @return the element representing the function containing the current node\n   */\n  ExecutableElement get enclosingFunction => _enclosingFunction;\n\n  /**\n   * Return the object keeping track of which elements have had their types overridden.\n   *\n   * @return the object keeping track of which elements have had their types overridden\n   */\n  TypeOverrideManager get overrideManager => _overrideManager;\n\n  /**\n   * Return the object keeping track of which elements have had their types promoted.\n   *\n   * @return the object keeping track of which elements have had their types promoted\n   */\n  TypePromotionManager get promoteManager => _promoteManager;\n\n  /**\n   * Return the propagated element associated with the given expression whose type can be\n   * overridden, or `null` if there is no element whose type can be overridden.\n   *\n   * @param expression the expression with which the element is associated\n   * @return the element associated with the given expression\n   */\n  VariableElement getOverridablePropagatedElement(Expression expression) {\n    Element element = null;\n    if (expression is SimpleIdentifier) {\n      element = expression.propagatedElement;\n    } else if (expression is PrefixedIdentifier) {\n      element = expression.propagatedElement;\n    } else if (expression is PropertyAccess) {\n      element = expression.propertyName.propagatedElement;\n    }\n    if (element is VariableElement) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * Return the static element associated with the given expression whose type can be overridden, or\n   * `null` if there is no element whose type can be overridden.\n   *\n   * @param expression the expression with which the element is associated\n   * @return the element associated with the given expression\n   */\n  VariableElement getOverridableStaticElement(Expression expression) {\n    Element element = null;\n    if (expression is SimpleIdentifier) {\n      element = expression.staticElement;\n    } else if (expression is PrefixedIdentifier) {\n      element = expression.staticElement;\n    } else if (expression is PropertyAccess) {\n      element = expression.propertyName.staticElement;\n    }\n    if (element is VariableElement) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * Return the static element associated with the given expression whose type\n   * can be promoted, or `null` if there is no element whose type can be\n   * promoted.\n   */\n  VariableElement getPromotionStaticElement(Expression expression) {\n    expression = expression?.unParenthesized;\n    if (expression is SimpleIdentifier) {\n      Element element = expression.staticElement;\n      if (element is VariableElement) {\n        ElementKind kind = element.kind;\n        if (kind == ElementKind.LOCAL_VARIABLE ||\n            kind == ElementKind.PARAMETER) {\n          return element;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Prepares this [ResolverVisitor] to using it for incremental resolution.\n   */\n  void initForIncrementalResolution() {\n    _overrideManager.enterScope();\n  }\n\n  /**\n   * Given a downward inference type [fnType], and the declared\n   * [typeParameterList] for a function expression, determines if we can enable\n   * downward inference and if so, returns the function type to use for\n   * inference.\n   *\n   * This will return null if inference is not possible. This happens when\n   * there is no way we can find a subtype of the function type, given the\n   * provided type parameter list.\n   */\n  FunctionType matchFunctionTypeParameters(\n      TypeParameterList typeParameterList, FunctionType fnType) {\n    if (typeParameterList == null) {\n      if (fnType.typeFormals.isEmpty) {\n        return fnType;\n      }\n\n      // A non-generic function cannot be a subtype of a generic one.\n      return null;\n    }\n\n    NodeList<TypeParameter> typeParameters = typeParameterList.typeParameters;\n    if (fnType.typeFormals.isEmpty) {\n      // TODO(jmesserly): this is a legal subtype. We don't currently infer\n      // here, but we could.  This is similar to\n      // StrongTypeSystemImpl.inferFunctionTypeInstantiation, but we don't\n      // have the FunctionType yet for the current node, so it's not quite\n      // straightforward to apply.\n      return null;\n    }\n\n    if (fnType.typeFormals.length != typeParameters.length) {\n      // A subtype cannot have different number of type formals.\n      return null;\n    }\n\n    // Same number of type formals. Instantiate the function type so its\n    // parameter and return type are in terms of the surrounding context.\n    return fnType.instantiate(typeParameters\n        .map((TypeParameter t) =>\n            (t.name.staticElement as TypeParameterElement).type)\n        .toList());\n  }\n\n  /**\n   * If it is appropriate to do so, override the current type of the static and propagated elements\n   * associated with the given expression with the given type. Generally speaking, it is appropriate\n   * if the given type is more specific than the current type.\n   *\n   * @param expression the expression used to access the static and propagated elements whose types\n   *          might be overridden\n   * @param potentialType the potential type of the elements\n   * @param allowPrecisionLoss see @{code overrideVariable} docs\n   */\n  void overrideExpression(Expression expression, DartType potentialType,\n      bool allowPrecisionLoss, bool setExpressionType) {\n    VariableElement element = getOverridableStaticElement(expression);\n    if (element != null) {\n      DartType newBestType =\n          overrideVariable(element, potentialType, allowPrecisionLoss);\n      if (setExpressionType) {\n        recordPropagatedTypeIfBetter(expression, newBestType);\n      }\n    }\n    element = getOverridablePropagatedElement(expression);\n    if (element != null) {\n      overrideVariable(element, potentialType, allowPrecisionLoss);\n    }\n  }\n\n  /**\n   * If it is appropriate to do so, override the current type of the given element with the given\n   * type.\n   *\n   * @param element the element whose type might be overridden\n   * @param potentialType the potential type of the element\n   * @param allowPrecisionLoss true if `potentialType` is allowed to be less precise than the\n   *          current best type\n   *\n   * Return a new better [DartType], or `null` if [potentialType] is not better\n   * than the current [element] type.\n   */\n  DartType overrideVariable(VariableElement element, DartType potentialType,\n      bool allowPrecisionLoss) {\n    // TODO(scheglov) type propagation for instance/top-level fields\n    // was disabled because it depends on the order or visiting.\n    // If both field and its client are in the same unit, and we visit\n    // the client before the field, then propagated type is not set yet.\n    if (element is PropertyInducingElement) {\n      return null;\n    }\n\n    if (potentialType == null ||\n        potentialType.isBottom ||\n        potentialType.isDartCoreNull) {\n      return null;\n    }\n    DartType currentType = _overrideManager.getBestType(element);\n\n    if (potentialType == currentType) {\n      return null;\n    }\n\n    // If we aren't allowing precision loss then the third and fourth conditions\n    // check that we aren't losing precision.\n    //\n    // Let [C] be the current type and [P] be the potential type.  When we\n    // aren't allowing precision loss -- which is the case for is-checks -- we\n    // check that [! (C << P)] or  [P << C]. The second check, that [P << C], is\n    // analogous to part of the Dart Language Spec rule for type promotion under\n    // is-checks (in the analogy [T] is [P] and [S] is [C]):\n    //\n    //   An is-expression of the form [v is T] shows that [v] has type [T] iff\n    //   [T] is more specific than the type [S] of the expression [v] and both\n    //   [T != dynamic] and [S != dynamic].\n    //\n    // It also covers an important case that is not applicable in the spec:\n    // for union types, we want an is-check to promote from an union type to\n    // (a subtype of) any of its members.\n    //\n    // The first check, that [! (C << P)], covers the case where [P] and [C] are\n    // unrelated types; This case is not addressed in the spec for static types.\n    if (currentType == null ||\n        allowPrecisionLoss ||\n        !currentType.isMoreSpecificThan(potentialType) ||\n        potentialType.isMoreSpecificThan(currentType)) {\n      _overrideManager.setType(element, potentialType);\n      return potentialType;\n    }\n    return null;\n  }\n\n  /**\n   * A client is about to resolve a member in the given class declaration.\n   */\n  void prepareToResolveMembersInClass(ClassDeclaration node) {\n    _enclosingClassDeclaration = node;\n    enclosingClass = node.element;\n    typeAnalyzer.thisType = enclosingClass?.type;\n  }\n\n  /**\n   * If the given [type] is valid, strongly more specific than the\n   * existing static type of the given [expression], record it as a propagated\n   * type of the given [expression]. Otherwise, reset it to `null`.\n   *\n   * If [hasOldPropagatedType] is `true` then the existing propagated type\n   * should also is checked.\n   */\n  void recordPropagatedTypeIfBetter(Expression expression, DartType type,\n      [bool hasOldPropagatedType = false]) {\n    // Ensure that propagated type invalid.\n    if (strongMode ||\n        type == null ||\n        type.isBottom ||\n        type.isDynamic ||\n        type.isDartCoreNull) {\n      if (!hasOldPropagatedType) {\n        expression.propagatedType = null;\n      }\n      return;\n    }\n    // Ensure that propagated type is more specific than the static type.\n    DartType staticType = expression.staticType;\n    if (type == staticType || !type.isMoreSpecificThan(staticType)) {\n      expression.propagatedType = null;\n      return;\n    }\n    // Ensure that the new propagated type is more specific than the old one.\n    if (hasOldPropagatedType) {\n      DartType oldPropagatedType = expression.propagatedType;\n      if (oldPropagatedType != null &&\n          !type.isMoreSpecificThan(oldPropagatedType)) {\n        return;\n      }\n    }\n    // OK\n    expression.propagatedType = type;\n  }\n\n  /**\n   * Visit the given [comment] if it is not `null`.\n   */\n  void safelyVisitComment(Comment comment) {\n    if (comment != null) {\n      super.visitComment(comment);\n    }\n  }\n\n  @override\n  Object visitAnnotation(Annotation node) {\n    AstNode parent = node.parent;\n    if (identical(parent, _enclosingClassDeclaration) ||\n        identical(parent, _enclosingFunctionTypeAlias)) {\n      return null;\n    }\n    node.name?.accept(this);\n    node.constructorName?.accept(this);\n    Element element = node.element;\n    if (element is ExecutableElement) {\n      InferenceContext.setType(node.arguments, element.type);\n    }\n    node.arguments?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    ElementAnnotationImpl elementAnnotationImpl = node.elementAnnotation;\n    if (elementAnnotationImpl == null) {\n      // Analyzer ignores annotations on \"part of\" directives.\n      assert(parent is PartOfDirective);\n    } else {\n      elementAnnotationImpl.annotationAst = _createCloner().cloneNode(node);\n    }\n    return null;\n  }\n\n  @override\n  Object visitArgumentList(ArgumentList node) {\n    DartType callerType = InferenceContext.getContext(node);\n    if (callerType is FunctionType) {\n      Map<String, DartType> namedParameterTypes =\n          callerType.namedParameterTypes;\n      List<DartType> normalParameterTypes = callerType.normalParameterTypes;\n      List<DartType> optionalParameterTypes = callerType.optionalParameterTypes;\n      int normalCount = normalParameterTypes.length;\n      int optionalCount = optionalParameterTypes.length;\n\n      NodeList<Expression> arguments = node.arguments;\n      Iterable<Expression> positional =\n          arguments.takeWhile((l) => l is! NamedExpression);\n      Iterable<Expression> required = positional.take(normalCount);\n      Iterable<Expression> optional =\n          positional.skip(normalCount).take(optionalCount);\n      Iterable<Expression> named =\n          arguments.skipWhile((l) => l is! NamedExpression);\n\n      //TODO(leafp): Consider using the parameter elements here instead.\n      //TODO(leafp): Make sure that the parameter elements are getting\n      // setup correctly with inference.\n      int index = 0;\n      for (Expression argument in required) {\n        InferenceContext.setType(argument, normalParameterTypes[index++]);\n      }\n      index = 0;\n      for (Expression argument in optional) {\n        InferenceContext.setType(argument, optionalParameterTypes[index++]);\n      }\n\n      for (Expression argument in named) {\n        if (argument is NamedExpression) {\n          DartType type = namedParameterTypes[argument.name.label.name];\n          if (type != null) {\n            InferenceContext.setType(argument, type);\n          }\n        }\n      }\n    }\n    return super.visitArgumentList(node);\n  }\n\n  @override\n  Object visitAsExpression(AsExpression node) {\n    super.visitAsExpression(node);\n    // Since an as-statement doesn't actually change the type, we don't\n    // let it affect the propagated type when it would result in a loss\n    // of precision.\n    overrideExpression(node.expression, node.type.type, false, false);\n    return null;\n  }\n\n  @override\n  Object visitAssertInitializer(AssertInitializer node) {\n    InferenceContext.setType(node.condition, typeProvider.boolType);\n    super.visitAssertInitializer(node);\n    return null;\n  }\n\n  @override\n  Object visitAssertStatement(AssertStatement node) {\n    InferenceContext.setType(node.condition, typeProvider.boolType);\n    super.visitAssertStatement(node);\n    _propagateTrueState(node.condition);\n    return null;\n  }\n\n  @override\n  Object visitAssignmentExpression(AssignmentExpression node) {\n    node.leftHandSide?.accept(this);\n    TokenType operator = node.operator.type;\n    if (operator == TokenType.EQ ||\n        operator == TokenType.QUESTION_QUESTION_EQ) {\n      InferenceContext.setType(\n          node.rightHandSide, node.leftHandSide.staticType);\n    }\n    node.rightHandSide?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitAwaitExpression(AwaitExpression node) {\n    DartType contextType = InferenceContext.getContext(node);\n    if (contextType != null) {\n      var futureUnion = _createFutureOr(contextType);\n      InferenceContext.setType(node.expression, futureUnion);\n    }\n    return super.visitAwaitExpression(node);\n  }\n\n  @override\n  Object visitBinaryExpression(BinaryExpression node) {\n    TokenType operatorType = node.operator.type;\n    Expression leftOperand = node.leftOperand;\n    Expression rightOperand = node.rightOperand;\n    if (operatorType == TokenType.AMPERSAND_AMPERSAND) {\n      InferenceContext.setType(leftOperand, typeProvider.boolType);\n      InferenceContext.setType(rightOperand, typeProvider.boolType);\n      leftOperand?.accept(this);\n      if (rightOperand != null) {\n        _overrideManager.enterScope();\n        try {\n          _promoteManager.enterScope();\n          try {\n            _propagateTrueState(leftOperand);\n            // Type promotion.\n            _promoteTypes(leftOperand);\n            _clearTypePromotionsIfPotentiallyMutatedIn(leftOperand);\n            _clearTypePromotionsIfPotentiallyMutatedIn(rightOperand);\n            _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(\n                rightOperand);\n            // Visit right operand.\n            rightOperand.accept(this);\n          } finally {\n            _promoteManager.exitScope();\n          }\n        } finally {\n          _overrideManager.exitScope();\n        }\n      }\n    } else if (operatorType == TokenType.BAR_BAR) {\n      InferenceContext.setType(leftOperand, typeProvider.boolType);\n      InferenceContext.setType(rightOperand, typeProvider.boolType);\n      leftOperand?.accept(this);\n      if (rightOperand != null) {\n        _overrideManager.enterScope();\n        try {\n          _propagateFalseState(leftOperand);\n          rightOperand.accept(this);\n        } finally {\n          _overrideManager.exitScope();\n        }\n      }\n    } else {\n      // TODO(leafp): Do downwards inference using the declared type\n      // of the binary operator for other cases.\n      if (operatorType == TokenType.QUESTION_QUESTION) {\n        InferenceContext.setTypeFromNode(leftOperand, node);\n      }\n      leftOperand?.accept(this);\n      if (operatorType == TokenType.QUESTION_QUESTION) {\n        // Set the right side, either from the context, or using the information\n        // from the left side if it is more precise.\n        DartType contextType = InferenceContext.getContext(node);\n        DartType leftType = leftOperand?.staticType;\n        if (contextType == null || contextType.isDynamic) {\n          contextType = leftType;\n        }\n        InferenceContext.setType(rightOperand, contextType);\n      }\n      rightOperand?.accept(this);\n    }\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitBlockFunctionBody(BlockFunctionBody node) {\n    _overrideManager.enterScope();\n    try {\n      inferenceContext.pushReturnContext(node);\n      super.visitBlockFunctionBody(node);\n    } finally {\n      _overrideManager.exitScope();\n      inferenceContext.popReturnContext(node);\n    }\n    return null;\n  }\n\n  @override\n  Object visitBreakStatement(BreakStatement node) {\n    //\n    // We do not visit the label because it needs to be visited in the context\n    // of the statement.\n    //\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitCascadeExpression(CascadeExpression node) {\n    InferenceContext.setTypeFromNode(node.target, node);\n    return super.visitCascadeExpression(node);\n  }\n\n  @override\n  Object visitClassDeclaration(ClassDeclaration node) {\n    //\n    // Resolve the metadata in the library scope.\n    //\n    node.metadata?.accept(this);\n    _enclosingClassDeclaration = node;\n    //\n    // Continue the class resolution.\n    //\n    ClassElement outerType = enclosingClass;\n    try {\n      enclosingClass = node.element;\n      typeAnalyzer.thisType = enclosingClass?.type;\n      super.visitClassDeclaration(node);\n      node.accept(elementResolver);\n      node.accept(typeAnalyzer);\n    } finally {\n      typeAnalyzer.thisType = outerType?.type;\n      enclosingClass = outerType;\n      _enclosingClassDeclaration = null;\n    }\n    return null;\n  }\n\n  /**\n   * Implementation of this method should be synchronized with\n   * [visitClassDeclaration].\n   */\n  visitClassDeclarationIncrementally(ClassDeclaration node) {\n    //\n    // Resolve the metadata in the library scope.\n    //\n    node.metadata?.accept(this);\n    _enclosingClassDeclaration = node;\n    //\n    // Continue the class resolution.\n    //\n    enclosingClass = node.element;\n    typeAnalyzer.thisType = enclosingClass?.type;\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n  }\n\n  @override\n  Object visitComment(Comment node) {\n    AstNode parent = node.parent;\n    if (parent is FunctionDeclaration ||\n        parent is FunctionTypeAlias ||\n        parent is ConstructorDeclaration ||\n        parent is MethodDeclaration) {\n      return null;\n    }\n    super.visitComment(node);\n    return null;\n  }\n\n  @override\n  Object visitCommentReference(CommentReference node) {\n    //\n    // We do not visit the identifier because it needs to be visited in the\n    // context of the reference.\n    //\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitCompilationUnit(CompilationUnit node) {\n    _overrideManager.enterScope();\n    try {\n      NodeList<Directive> directives = node.directives;\n      int directiveCount = directives.length;\n      for (int i = 0; i < directiveCount; i++) {\n        directives[i].accept(this);\n      }\n      NodeList<CompilationUnitMember> declarations = node.declarations;\n      int declarationCount = declarations.length;\n      for (int i = 0; i < declarationCount; i++) {\n        declarations[i].accept(this);\n      }\n    } finally {\n      _overrideManager.exitScope();\n    }\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitConditionalExpression(ConditionalExpression node) {\n    Expression condition = node.condition;\n    condition?.accept(this);\n    Expression thenExpression = node.thenExpression;\n    if (thenExpression != null) {\n      _overrideManager.enterScope();\n      try {\n        _promoteManager.enterScope();\n        try {\n          _propagateTrueState(condition);\n          // Type promotion.\n          _promoteTypes(condition);\n          _clearTypePromotionsIfPotentiallyMutatedIn(thenExpression);\n          _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(\n              thenExpression);\n          // Visit \"then\" expression.\n          InferenceContext.setTypeFromNode(thenExpression, node);\n          thenExpression.accept(this);\n        } finally {\n          _promoteManager.exitScope();\n        }\n      } finally {\n        _overrideManager.exitScope();\n      }\n    }\n    Expression elseExpression = node.elseExpression;\n    if (elseExpression != null) {\n      _overrideManager.enterScope();\n      try {\n        _propagateFalseState(condition);\n        InferenceContext.setTypeFromNode(elseExpression, node);\n        elseExpression.accept(this);\n      } finally {\n        _overrideManager.exitScope();\n      }\n    }\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    bool thenIsAbrupt = _isAbruptTerminationExpression(thenExpression);\n    bool elseIsAbrupt = _isAbruptTerminationExpression(elseExpression);\n    if (elseIsAbrupt && !thenIsAbrupt) {\n      _propagateTrueState(condition);\n      _propagateState(thenExpression);\n    } else if (thenIsAbrupt && !elseIsAbrupt) {\n      _propagateFalseState(condition);\n      _propagateState(elseExpression);\n    }\n    return null;\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    FunctionBody outerFunctionBody = _currentFunctionBody;\n    try {\n      _currentFunctionBody = node.body;\n      _enclosingFunction = node.element;\n      FunctionType type = _enclosingFunction.type;\n      InferenceContext.setType(node.body, type.returnType);\n      super.visitConstructorDeclaration(node);\n    } finally {\n      _currentFunctionBody = outerFunctionBody;\n      _enclosingFunction = outerFunction;\n    }\n    ConstructorElementImpl constructor = node.element;\n    constructor.constantInitializers =\n        _createCloner().cloneNodeList(node.initializers);\n    return null;\n  }\n\n  @override\n  void visitConstructorDeclarationInScope(ConstructorDeclaration node) {\n    super.visitConstructorDeclarationInScope(node);\n    // Because of needing a different scope for the initializer list, the\n    // overridden implementation of this method cannot cause the visitNode\n    // method to be invoked. As a result, we have to hard-code using the\n    // element resolver and type analyzer to visit the constructor declaration.\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    safelyVisitComment(node.documentationComment);\n  }\n\n  @override\n  Object visitConstructorFieldInitializer(ConstructorFieldInitializer node) {\n    //\n    // We visit the expression, but do not visit the field name because it needs\n    // to be visited in the context of the constructor field initializer node.\n    //\n    FieldElement fieldElement = enclosingClass.getField(node.fieldName.name);\n    InferenceContext.setType(node.expression, fieldElement?.type);\n    node.expression?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitConstructorName(ConstructorName node) {\n    //\n    // We do not visit either the type name, because it won't be visited anyway,\n    // or the name, because it needs to be visited in the context of the\n    // constructor name.\n    //\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitContinueStatement(ContinueStatement node) {\n    //\n    // We do not visit the label because it needs to be visited in the context\n    // of the statement.\n    //\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitDefaultFormalParameter(DefaultFormalParameter node) {\n    InferenceContext.setType(node.defaultValue,\n        resolutionMap.elementDeclaredByFormalParameter(node.parameter)?.type);\n    super.visitDefaultFormalParameter(node);\n    ParameterElement element = node.element;\n    if (element.initializer != null && node.defaultValue != null) {\n      (element.initializer as FunctionElementImpl).returnType =\n          node.defaultValue.staticType;\n    }\n    // Clone the ASTs for default formal parameters, so that we can use them\n    // during constant evaluation.\n    if (element is ConstVariableElement &&\n        !_hasSerializedConstantInitializer(element)) {\n      (element as ConstVariableElement).constantInitializer =\n          _createCloner().cloneNode(node.defaultValue);\n    }\n    return null;\n  }\n\n  @override\n  Object visitDoStatement(DoStatement node) {\n    _overrideManager.enterScope();\n    try {\n      InferenceContext.setType(node.condition, typeProvider.boolType);\n      super.visitDoStatement(node);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    // TODO(brianwilkerson) If the loop can only be exited because the condition\n    // is false, then propagateFalseState(node.getCondition());\n    return null;\n  }\n\n  @override\n  Object visitEmptyFunctionBody(EmptyFunctionBody node) {\n    if (resolveOnlyCommentInFunctionBody) {\n      return null;\n    }\n    return super.visitEmptyFunctionBody(node);\n  }\n\n  @override\n  Object visitEnumDeclaration(EnumDeclaration node) {\n    //\n    // Resolve the metadata in the library scope\n    // and associate the annotations with the element.\n    //\n    if (node.metadata != null) {\n      node.metadata.accept(this);\n      ElementResolver.resolveMetadata(node);\n      node.constants.forEach(ElementResolver.resolveMetadata);\n    }\n    //\n    // Continue the enum resolution.\n    //\n    ClassElement outerType = enclosingClass;\n    try {\n      enclosingClass = node.element;\n      typeAnalyzer.thisType = enclosingClass?.type;\n      super.visitEnumDeclaration(node);\n      node.accept(elementResolver);\n      node.accept(typeAnalyzer);\n    } finally {\n      typeAnalyzer.thisType = outerType?.type;\n      enclosingClass = outerType;\n      _enclosingClassDeclaration = null;\n    }\n    return null;\n  }\n\n  @override\n  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {\n    if (resolveOnlyCommentInFunctionBody) {\n      return null;\n    }\n    _overrideManager.enterScope();\n    try {\n      InferenceContext.setTypeFromNode(node.expression, node);\n      inferenceContext.pushReturnContext(node);\n      super.visitExpressionFunctionBody(node);\n\n      DartType type = node.expression.staticType;\n      if (_enclosingFunction.isAsynchronous) {\n        type = type.flattenFutures(typeSystem);\n      }\n      if (type != null) {\n        inferenceContext.addReturnOrYieldType(type);\n      }\n    } finally {\n      _overrideManager.exitScope();\n      inferenceContext.popReturnContext(node);\n    }\n    return null;\n  }\n\n  @override\n  Object visitFieldDeclaration(FieldDeclaration node) {\n    _overrideManager.enterScope();\n    try {\n      super.visitFieldDeclaration(node);\n    } finally {\n      Map<VariableElement, DartType> overrides =\n          _overrideManager.captureOverrides(node.fields);\n      _overrideManager.exitScope();\n      _overrideManager.applyOverrides(overrides);\n    }\n    return null;\n  }\n\n  @override\n  Object visitForEachStatement(ForEachStatement node) {\n    _overrideManager.enterScope();\n    try {\n      super.visitForEachStatement(node);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    return null;\n  }\n\n  @override\n  void visitForEachStatementInScope(ForEachStatement node) {\n    Expression iterable = node.iterable;\n    DeclaredIdentifier loopVariable = node.loopVariable;\n    SimpleIdentifier identifier = node.identifier;\n\n    identifier?.accept(this);\n\n    DartType valueType;\n    if (loopVariable != null) {\n      TypeAnnotation typeAnnotation = loopVariable.type;\n      valueType = typeAnnotation?.type ?? UnknownInferredType.instance;\n    }\n    if (identifier != null) {\n      Element element = identifier.staticElement;\n      if (element is VariableElement) {\n        valueType = element.type;\n      } else if (element is PropertyAccessorElement) {\n        if (element.parameters.isNotEmpty) {\n          valueType = element.parameters[0].type;\n        }\n      }\n    }\n    if (valueType != null) {\n      InterfaceType targetType = (node.awaitKeyword == null)\n          ? typeProvider.iterableType\n          : typeProvider.streamType;\n      InferenceContext.setType(iterable, targetType.instantiate([valueType]));\n    }\n\n    //\n    // We visit the iterator before the loop variable because the loop variable\n    // cannot be in scope while visiting the iterator.\n    //\n    iterable?.accept(this);\n    loopVariable?.accept(this);\n    Statement body = node.body;\n    if (body != null) {\n      _overrideManager.enterScope();\n      try {\n        if (loopVariable != null && iterable != null) {\n          LocalVariableElement loopElement = loopVariable.element;\n          if (loopElement != null) {\n            DartType propagatedType = null;\n            if (node.awaitKeyword == null) {\n              propagatedType = _getIteratorElementType(iterable);\n            } else {\n              propagatedType = _getStreamElementType(iterable);\n            }\n            if (propagatedType != null) {\n              overrideVariable(loopElement, propagatedType, true);\n              recordPropagatedTypeIfBetter(\n                  loopVariable.identifier, propagatedType);\n            }\n          }\n        } else if (identifier != null && iterable != null) {\n          Element identifierElement = identifier.staticElement;\n          if (identifierElement is VariableElement) {\n            DartType iteratorElementType = _getIteratorElementType(iterable);\n            overrideVariable(identifierElement, iteratorElementType, true);\n            recordPropagatedTypeIfBetter(identifier, iteratorElementType);\n          }\n        }\n        visitStatementInScope(body);\n      } finally {\n        _overrideManager.exitScope();\n      }\n    }\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n  }\n\n  @override\n  Object visitForStatement(ForStatement node) {\n    _overrideManager.enterScope();\n    try {\n      super.visitForStatement(node);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    return null;\n  }\n\n  @override\n  void visitForStatementInScope(ForStatement node) {\n    node.variables?.accept(this);\n    node.initialization?.accept(this);\n    InferenceContext.setType(node.condition, typeProvider.boolType);\n    node.condition?.accept(this);\n    _overrideManager.enterScope();\n    try {\n      _propagateTrueState(node.condition);\n      visitStatementInScope(node.body);\n      node.updaters.accept(this);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    // TODO(brianwilkerson) If the loop can only be exited because the condition\n    // is false, then propagateFalseState(condition);\n  }\n\n  @override\n  Object visitFunctionDeclaration(FunctionDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    FunctionBody outerFunctionBody = _currentFunctionBody;\n    try {\n      SimpleIdentifier functionName = node.name;\n      _currentFunctionBody = node.functionExpression.body;\n      _enclosingFunction = functionName.staticElement as ExecutableElement;\n      InferenceContext.setType(\n          node.functionExpression, _enclosingFunction.type);\n      super.visitFunctionDeclaration(node);\n    } finally {\n      _currentFunctionBody = outerFunctionBody;\n      _enclosingFunction = outerFunction;\n    }\n    return null;\n  }\n\n  @override\n  void visitFunctionDeclarationInScope(FunctionDeclaration node) {\n    super.visitFunctionDeclarationInScope(node);\n    safelyVisitComment(node.documentationComment);\n  }\n\n  @override\n  Object visitFunctionExpression(FunctionExpression node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    FunctionBody outerFunctionBody = _currentFunctionBody;\n    try {\n      _currentFunctionBody = node.body;\n      _enclosingFunction = node.element;\n      _overrideManager.enterScope();\n      try {\n        DartType functionType = InferenceContext.getContext(node);\n        var ts = typeSystem;\n        if (functionType is FunctionType && ts is StrongTypeSystemImpl) {\n          functionType =\n              matchFunctionTypeParameters(node.typeParameters, functionType);\n          if (functionType is FunctionType) {\n            _inferFormalParameterList(node.parameters, functionType);\n            InferenceContext.setType(\n                node.body, _computeReturnOrYieldType(functionType.returnType));\n          }\n        }\n        super.visitFunctionExpression(node);\n      } finally {\n        _overrideManager.exitScope();\n      }\n    } finally {\n      _currentFunctionBody = outerFunctionBody;\n      _enclosingFunction = outerFunction;\n    }\n    return null;\n  }\n\n  @override\n  Object visitFunctionExpressionInvocation(FunctionExpressionInvocation node) {\n    node.function?.accept(this);\n    node.accept(elementResolver);\n    _inferArgumentTypesForInvocation(node);\n    node.argumentList?.accept(this);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitFunctionTypeAlias(FunctionTypeAlias node) {\n    // Resolve the metadata in the library scope.\n    if (node.metadata != null) {\n      node.metadata.accept(this);\n    }\n    FunctionTypeAlias outerAlias = _enclosingFunctionTypeAlias;\n    _enclosingFunctionTypeAlias = node;\n    try {\n      super.visitFunctionTypeAlias(node);\n    } finally {\n      _enclosingFunctionTypeAlias = outerAlias;\n    }\n    return null;\n  }\n\n  @override\n  void visitFunctionTypeAliasInScope(FunctionTypeAlias node) {\n    super.visitFunctionTypeAliasInScope(node);\n    safelyVisitComment(node.documentationComment);\n  }\n\n  @override\n  Object visitGenericFunctionType(GenericFunctionType node) => null;\n\n  @override\n  Object visitGenericTypeAliasInFunctionScope(GenericTypeAlias node) {\n    super.visitGenericTypeAliasInFunctionScope(node);\n    safelyVisitComment(node.documentationComment);\n    return null;\n  }\n\n  @override\n  Object visitHideCombinator(HideCombinator node) => null;\n\n  @override\n  Object visitIfStatement(IfStatement node) {\n    Expression condition = node.condition;\n    InferenceContext.setType(condition, typeProvider.boolType);\n    condition?.accept(this);\n    Map<VariableElement, DartType> thenOverrides =\n        const <VariableElement, DartType>{};\n    Statement thenStatement = node.thenStatement;\n    if (thenStatement != null) {\n      _overrideManager.enterScope();\n      try {\n        _promoteManager.enterScope();\n        try {\n          _propagateTrueState(condition);\n          // Type promotion.\n          _promoteTypes(condition);\n          _clearTypePromotionsIfPotentiallyMutatedIn(thenStatement);\n          _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(\n              thenStatement);\n          // Visit \"then\".\n          visitStatementInScope(thenStatement);\n        } finally {\n          _promoteManager.exitScope();\n        }\n      } finally {\n        thenOverrides = _overrideManager.captureLocalOverrides();\n        _overrideManager.exitScope();\n      }\n    }\n    Map<VariableElement, DartType> elseOverrides =\n        const <VariableElement, DartType>{};\n    Statement elseStatement = node.elseStatement;\n    if (elseStatement != null) {\n      _overrideManager.enterScope();\n      try {\n        _propagateFalseState(condition);\n        visitStatementInScope(elseStatement);\n      } finally {\n        elseOverrides = _overrideManager.captureLocalOverrides();\n        _overrideManager.exitScope();\n      }\n    }\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    // Join overrides.\n    bool thenIsAbrupt = _isAbruptTerminationStatement(thenStatement);\n    bool elseIsAbrupt = _isAbruptTerminationStatement(elseStatement);\n    if (elseIsAbrupt && !thenIsAbrupt) {\n      _propagateTrueState(condition);\n      _overrideManager.applyOverrides(thenOverrides);\n    } else if (thenIsAbrupt && !elseIsAbrupt) {\n      _propagateFalseState(condition);\n      _overrideManager.applyOverrides(elseOverrides);\n    } else if (!thenIsAbrupt && !elseIsAbrupt) {\n      List<Map<VariableElement, DartType>> perBranchOverrides =\n          <Map<VariableElement, DartType>>[];\n      perBranchOverrides.add(thenOverrides);\n      perBranchOverrides.add(elseOverrides);\n      _overrideManager.mergeOverrides(perBranchOverrides);\n    }\n    return null;\n  }\n\n  @override\n  Object visitInstanceCreationExpression(InstanceCreationExpression node) {\n    node.constructorName?.accept(this);\n    _inferArgumentTypesForInstanceCreate(node);\n    node.argumentList?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitLabel(Label node) => null;\n\n  @override\n  Object visitLibraryIdentifier(LibraryIdentifier node) => null;\n\n  @override\n  Object visitListLiteral(ListLiteral node) {\n    InterfaceType listT;\n\n    if (node.typeArguments != null) {\n      var targs = node.typeArguments.arguments.map((t) => t.type).toList();\n      if (targs.length == 1 && !targs[0].isDynamic) {\n        listT = typeProvider.listType.instantiate([targs[0]]);\n      }\n    } else if (strongMode) {\n      listT = typeAnalyzer.inferListType(node, downwards: true);\n    }\n    if (listT != null) {\n      DartType eType = listT.typeArguments[0];\n      for (Expression child in node.elements) {\n        InferenceContext.setType(child, eType);\n      }\n      InferenceContext.setType(node, listT);\n    } else {\n      InferenceContext.clearType(node);\n    }\n    super.visitListLiteral(node);\n    return null;\n  }\n\n  @override\n  Object visitMapLiteral(MapLiteral node) {\n    InterfaceType mapT;\n    if (node.typeArguments != null) {\n      var targs = node.typeArguments.arguments.map((t) => t.type).toList();\n      if (targs.length == 2 && targs.any((t) => !t.isDynamic)) {\n        mapT = typeProvider.mapType.instantiate([targs[0], targs[1]]);\n      }\n    } else if (strongMode) {\n      mapT = typeAnalyzer.inferMapType(node, downwards: true);\n    }\n    if (mapT != null) {\n      DartType kType = mapT.typeArguments[0];\n      DartType vType = mapT.typeArguments[1];\n      for (MapLiteralEntry entry in node.entries) {\n        InferenceContext.setType(entry.key, kType);\n        InferenceContext.setType(entry.value, vType);\n      }\n      InferenceContext.setType(node, mapT);\n    } else {\n      InferenceContext.clearType(node);\n    }\n    super.visitMapLiteral(node);\n    return null;\n  }\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    FunctionBody outerFunctionBody = _currentFunctionBody;\n    try {\n      _currentFunctionBody = node.body;\n      _enclosingFunction = node.element;\n      DartType returnType =\n          _computeReturnOrYieldType(_enclosingFunction.type?.returnType);\n      InferenceContext.setType(node.body, returnType);\n      super.visitMethodDeclaration(node);\n    } finally {\n      _currentFunctionBody = outerFunctionBody;\n      _enclosingFunction = outerFunction;\n    }\n    return null;\n  }\n\n  @override\n  void visitMethodDeclarationInScope(MethodDeclaration node) {\n    super.visitMethodDeclarationInScope(node);\n    safelyVisitComment(node.documentationComment);\n  }\n\n  @override\n  Object visitMethodInvocation(MethodInvocation node) {\n    //\n    // We visit the target and argument list, but do not visit the method name\n    // because it needs to be visited in the context of the invocation.\n    //\n    node.target?.accept(this);\n    node.typeArguments?.accept(this);\n    node.accept(elementResolver);\n    _inferArgumentTypesForInvocation(node);\n    node.argumentList?.accept(this);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitNamedExpression(NamedExpression node) {\n    InferenceContext.setTypeFromNode(node.expression, node);\n    return super.visitNamedExpression(node);\n  }\n\n  @override\n  Object visitNode(AstNode node) {\n    node.visitChildren(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitParenthesizedExpression(ParenthesizedExpression node) {\n    InferenceContext.setTypeFromNode(node.expression, node);\n    return super.visitParenthesizedExpression(node);\n  }\n\n  @override\n  Object visitPrefixedIdentifier(PrefixedIdentifier node) {\n    //\n    // We visit the prefix, but do not visit the identifier because it needs to\n    // be visited in the context of the prefix.\n    //\n    node.prefix?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitPropertyAccess(PropertyAccess node) {\n    //\n    // We visit the target, but do not visit the property name because it needs\n    // to be visited in the context of the property access node.\n    //\n    node.target?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitRedirectingConstructorInvocation(\n      RedirectingConstructorInvocation node) {\n    //\n    // We visit the argument list, but do not visit the optional identifier\n    // because it needs to be visited in the context of the constructor\n    // invocation.\n    //\n    InferenceContext.setType(node.argumentList,\n        resolutionMap.staticElementForConstructorReference(node)?.type);\n    node.argumentList?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitReturnStatement(ReturnStatement node) {\n    Expression e = node.expression;\n    InferenceContext.setType(e, inferenceContext.returnContext);\n    super.visitReturnStatement(node);\n    DartType type = e?.staticType;\n    // Generators cannot return values, so don't try to do any inference if\n    // we're processing erroneous code.\n    if (type != null && _enclosingFunction?.isGenerator == false) {\n      if (_enclosingFunction.isAsynchronous) {\n        type = type.flattenFutures(typeSystem);\n      }\n      inferenceContext.addReturnOrYieldType(type);\n    }\n    return null;\n  }\n\n  @override\n  Object visitShowCombinator(ShowCombinator node) => null;\n\n  @override\n  Object visitSuperConstructorInvocation(SuperConstructorInvocation node) {\n    //\n    // We visit the argument list, but do not visit the optional identifier\n    // because it needs to be visited in the context of the constructor\n    // invocation.\n    //\n    InferenceContext.setType(node.argumentList,\n        resolutionMap.staticElementForConstructorReference(node)?.type);\n    node.argumentList?.accept(this);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitSwitchCase(SwitchCase node) {\n    _overrideManager.enterScope();\n    try {\n      InferenceContext.setType(\n          node.expression, _enclosingSwitchStatementExpressionType);\n      super.visitSwitchCase(node);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    return null;\n  }\n\n  @override\n  Object visitSwitchDefault(SwitchDefault node) {\n    _overrideManager.enterScope();\n    try {\n      super.visitSwitchDefault(node);\n    } finally {\n      _overrideManager.exitScope();\n    }\n    return null;\n  }\n\n  @override\n  Object visitSwitchStatementInScope(SwitchStatement node) {\n    var previousExpressionType = _enclosingSwitchStatementExpressionType;\n    try {\n      node.expression?.accept(this);\n      _enclosingSwitchStatementExpressionType = node.expression.staticType;\n      node.members.accept(this);\n    } finally {\n      _enclosingSwitchStatementExpressionType = previousExpressionType;\n    }\n    return null;\n  }\n\n  @override\n  Object visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {\n    _overrideManager.enterScope();\n    try {\n      super.visitTopLevelVariableDeclaration(node);\n    } finally {\n      Map<VariableElement, DartType> overrides =\n          _overrideManager.captureOverrides(node.variables);\n      _overrideManager.exitScope();\n      _overrideManager.applyOverrides(overrides);\n    }\n    return null;\n  }\n\n  @override\n  Object visitTypeName(TypeName node) => null;\n\n  @override\n  Object visitVariableDeclaration(VariableDeclaration node) {\n    InferenceContext.setTypeFromNode(node.initializer, node);\n    super.visitVariableDeclaration(node);\n    VariableElement element = node.element;\n    if (element.initializer != null && node.initializer != null) {\n      (element.initializer as FunctionElementImpl).returnType =\n          node.initializer.staticType;\n    }\n    // Note: in addition to cloning the initializers for const variables, we\n    // have to clone the initializers for non-static final fields (because if\n    // they occur in a class with a const constructor, they will be needed to\n    // evaluate the const constructor).\n    if (element is ConstVariableElement) {\n      (element as ConstVariableElement).constantInitializer =\n          _createCloner().cloneNode(node.initializer);\n    }\n    return null;\n  }\n\n  @override\n  visitVariableDeclarationList(VariableDeclarationList node) {\n    for (VariableDeclaration decl in node.variables) {\n      VariableElement variableElement =\n          resolutionMap.elementDeclaredByVariableDeclaration(decl);\n      InferenceContext.setType(decl, variableElement?.type);\n    }\n    super.visitVariableDeclarationList(node);\n  }\n\n  @override\n  Object visitWhileStatement(WhileStatement node) {\n    // Note: since we don't call the base class, we have to maintain\n    // _implicitLabelScope ourselves.\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      Expression condition = node.condition;\n      InferenceContext.setType(condition, typeProvider.boolType);\n      condition?.accept(this);\n      Statement body = node.body;\n      if (body != null) {\n        _overrideManager.enterScope();\n        try {\n          _propagateTrueState(condition);\n          visitStatementInScope(body);\n        } finally {\n          _overrideManager.exitScope();\n        }\n      }\n    } finally {\n      _implicitLabelScope = outerImplicitScope;\n    }\n    // TODO(brianwilkerson) If the loop can only be exited because the condition\n    // is false, then propagateFalseState(condition);\n    node.accept(elementResolver);\n    node.accept(typeAnalyzer);\n    return null;\n  }\n\n  @override\n  Object visitYieldStatement(YieldStatement node) {\n    Expression e = node.expression;\n    DartType returnType = inferenceContext.returnContext;\n    bool isGenerator = _enclosingFunction?.isGenerator ?? false;\n    if (returnType != null && isGenerator) {\n      // If we're not in a generator ([a]sync*, then we shouldn't have a yield.\n      // so don't infer\n\n      // If this just a yield, then we just pass on the element type\n      DartType type = returnType;\n      if (node.star != null) {\n        // If this is a yield*, then we wrap the element return type\n        // If it's synchronous, we expect Iterable<T>, otherwise Stream<T>\n        InterfaceType wrapperType = _enclosingFunction.isSynchronous\n            ? typeProvider.iterableType\n            : typeProvider.streamType;\n        type = wrapperType.instantiate(<DartType>[type]);\n      }\n      InferenceContext.setType(e, type);\n    }\n    super.visitYieldStatement(node);\n    DartType type = e?.staticType;\n    if (type != null && isGenerator) {\n      // If this just a yield, then we just pass on the element type\n      if (node.star != null) {\n        // If this is a yield*, then we unwrap the element return type\n        // If it's synchronous, we expect Iterable<T>, otherwise Stream<T>\n        InterfaceType wrapperType = _enclosingFunction.isSynchronous\n            ? typeProvider.iterableType\n            : typeProvider.streamType;\n        type = typeSystem.mostSpecificTypeArgument(type, wrapperType);\n      }\n      if (type != null) {\n        inferenceContext.addReturnOrYieldType(type);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks each promoted variable in the current scope for compliance with the following\n   * specification statement:\n   *\n   * If the variable <i>v</i> is accessed by a closure in <i>s<sub>1</sub></i> then the variable\n   * <i>v</i> is not potentially mutated anywhere in the scope of <i>v</i>.\n   */\n  void _clearTypePromotionsIfAccessedInClosureAndProtentiallyMutated(\n      AstNode target) {\n    for (Element element in _promoteManager.promotedElements) {\n      if (_currentFunctionBody.isPotentiallyMutatedInScope(element)) {\n        if (_isVariableAccessedInClosure(element, target)) {\n          _promoteManager.setType(element, null);\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks each promoted variable in the current scope for compliance with the following\n   * specification statement:\n   *\n   * <i>v</i> is not potentially mutated in <i>s<sub>1</sub></i> or within a closure.\n   */\n  void _clearTypePromotionsIfPotentiallyMutatedIn(AstNode target) {\n    for (Element element in _promoteManager.promotedElements) {\n      if (_isVariablePotentiallyMutatedIn(element, target)) {\n        _promoteManager.setType(element, null);\n      }\n    }\n  }\n\n  /**\n   * Given the declared return type of a function, compute the type of the\n   * values which should be returned or yielded as appropriate.  If a type\n   * cannot be computed from the declared return type, return null.\n   */\n  DartType _computeReturnOrYieldType(DartType declaredType) {\n    bool isGenerator = _enclosingFunction.isGenerator;\n    bool isAsynchronous = _enclosingFunction.isAsynchronous;\n\n    // Ordinary functions just return their declared types.\n    if (!isGenerator && !isAsynchronous) {\n      return declaredType;\n    }\n    if (declaredType is InterfaceType) {\n      if (isGenerator) {\n        // If it's sync* we expect Iterable<T>\n        // If it's async* we expect Stream<T>\n        InterfaceType rawType = isAsynchronous\n            ? typeProvider.streamType\n            : typeProvider.iterableType;\n        // Match the types to instantiate the type arguments if possible\n        List<DartType> targs = declaredType.typeArguments;\n        if (targs.length == 1 && rawType.instantiate(targs) == declaredType) {\n          return targs[0];\n        }\n      }\n      // async functions expect `Future<T> | T`\n      var futureTypeParam = declaredType.flattenFutures(typeSystem);\n      return _createFutureOr(futureTypeParam);\n    }\n    return declaredType;\n  }\n\n  /**\n   * Return a newly created cloner that can be used to clone constant\n   * expressions.\n   */\n  ConstantAstCloner _createCloner() {\n    return new ConstantAstCloner(\n        definingLibrary.context.analysisOptions.previewDart2);\n  }\n\n  /**\n   * Creates a union of `T | Future<T>`, unless `T` is already a\n   * future-union, in which case it simply returns `T`.\n   */\n  DartType _createFutureOr(DartType type) {\n    if (type.isDartAsyncFutureOr) {\n      return type;\n    }\n    return typeProvider.futureOrType.instantiate([type]);\n  }\n\n  /**\n   * The given expression is the expression used to compute the iterator for a\n   * for-each statement. Attempt to compute the type of objects that will be\n   * assigned to the loop variable and return that type. Return `null` if the\n   * type could not be determined. The [iteratorExpression] is the expression\n   * that will return the Iterable being iterated over.\n   */\n  DartType _getIteratorElementType(Expression iteratorExpression) {\n    DartType expressionType = iteratorExpression.bestType;\n    if (expressionType is InterfaceType) {\n      PropertyAccessorElement iteratorFunction =\n          expressionType.lookUpInheritedGetter(\"iterator\");\n      if (iteratorFunction == null) {\n        // TODO(brianwilkerson) Should we report this error?\n        return null;\n      }\n      DartType iteratorType = iteratorFunction.returnType;\n      if (iteratorType is InterfaceType) {\n        PropertyAccessorElement currentFunction =\n            iteratorType.lookUpInheritedGetter(\"current\");\n        if (currentFunction == null) {\n          // TODO(brianwilkerson) Should we report this error?\n          return null;\n        }\n        return currentFunction.returnType;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * The given expression is the expression used to compute the stream for an\n   * asynchronous for-each statement. Attempt to compute the type of objects\n   * that will be assigned to the loop variable and return that type.\n   * Return `null` if the type could not be determined. The [streamExpression]\n   * is the expression that will return the stream being iterated over.\n   */\n  DartType _getStreamElementType(Expression streamExpression) {\n    DartType streamType = streamExpression.bestType;\n    if (streamType is InterfaceType) {\n      MethodElement listenFunction = streamType.lookUpInheritedMethod(\"listen\");\n      if (listenFunction == null) {\n        return null;\n      }\n      List<ParameterElement> listenParameters = listenFunction.parameters;\n      if (listenParameters == null || listenParameters.length < 1) {\n        return null;\n      }\n      DartType onDataType = listenParameters[0].type;\n      if (onDataType is FunctionType) {\n        List<ParameterElement> onDataParameters = onDataType.parameters;\n        if (onDataParameters == null || onDataParameters.isEmpty) {\n          return null;\n        }\n        return onDataParameters[0].type;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return `true` if the given [parameter] element of the AST being resolved\n   * is resynthesized and is an API-level, not local, so has its initializer\n   * serialized.\n   */\n  bool _hasSerializedConstantInitializer(ParameterElement parameter) {\n    Element executable = parameter.enclosingElement;\n    if (executable is MethodElement ||\n        executable is FunctionElement &&\n            executable.enclosingElement is CompilationUnitElement) {\n      return LibraryElementImpl.hasResolutionCapability(\n          definingLibrary, LibraryResolutionCapability.constantExpressions);\n    }\n    return false;\n  }\n\n  FunctionType _inferArgumentTypesForGeneric(AstNode inferenceNode,\n      DartType uninstantiatedType, TypeArgumentList typeArguments,\n      {AstNode errorNode}) {\n    errorNode ??= inferenceNode;\n    TypeSystem ts = typeSystem;\n    if (typeArguments == null &&\n        uninstantiatedType is FunctionType &&\n        uninstantiatedType.typeFormals.isNotEmpty &&\n        ts is StrongTypeSystemImpl) {\n      return ts.inferGenericFunctionOrType<FunctionType>(\n          uninstantiatedType,\n          ParameterElement.EMPTY_LIST,\n          DartType.EMPTY_LIST,\n          InferenceContext.getContext(inferenceNode),\n          downwards: true,\n          errorReporter: errorReporter,\n          errorNode: errorNode);\n    }\n    return null;\n  }\n\n  void _inferArgumentTypesForInstanceCreate(InstanceCreationExpression node) {\n    ConstructorName constructor = node.constructorName;\n    TypeName classTypeName = constructor?.type;\n    if (classTypeName == null || !strongMode) {\n      return;\n    }\n\n    ConstructorElement originalElement =\n        resolutionMap.staticElementForConstructorReference(constructor);\n    FunctionType inferred;\n    // If the constructor is generic, we'll have a ConstructorMember that\n    // substitutes in type arguments (possibly `dynamic`) from earlier in\n    // resolution.\n    //\n    // Otherwise we'll have a ConstructorElement, and we can skip inference\n    // because there's nothing to infer in a non-generic type.\n    if (classTypeName.typeArguments == null &&\n        originalElement is ConstructorMember) {\n      // TODO(leafp): Currently, we may re-infer types here, since we\n      // sometimes resolve multiple times.  We should really check that we\n      // have not already inferred something.  However, the obvious ways to\n      // check this don't work, since we may have been instantiated\n      // to bounds in an earlier phase, and we *do* want to do inference\n      // in that case.\n\n      // Get back to the uninstantiated generic constructor.\n      // TODO(jmesserly): should we store this earlier in resolution?\n      // Or look it up, instead of jumping backwards through the Member?\n      var rawElement = originalElement.baseElement;\n\n      FunctionType constructorType =\n          StaticTypeAnalyzer.constructorToGenericFunctionType(rawElement);\n\n      inferred = _inferArgumentTypesForGeneric(\n          node, constructorType, constructor.type.typeArguments,\n          errorNode: node.constructorName);\n\n      if (inferred != null) {\n        ArgumentList arguments = node.argumentList;\n        InferenceContext.setType(arguments, inferred);\n        // Fix up the parameter elements based on inferred method.\n        arguments.correspondingStaticParameters =\n            resolveArgumentsToParameters(arguments, inferred.parameters, null);\n\n        constructor.type.type = inferred.returnType;\n        if (UnknownInferredType.isKnown(inferred)) {\n          inferenceContext.recordInference(node, inferred.returnType);\n        }\n\n        // Update the static element as well. This is used in some cases, such\n        // as computing constant values. It is stored in two places.\n        constructor.staticElement =\n            ConstructorMember.from(rawElement, inferred.returnType);\n        node.staticElement = constructor.staticElement;\n      }\n    }\n\n    if (inferred == null) {\n      InferenceContext.setType(node.argumentList, originalElement?.type);\n    }\n  }\n\n  void _inferArgumentTypesForInvocation(InvocationExpression node) {\n    if (!strongMode) {\n      // Use propagated type inference for lambdas if not in strong mode.\n      _inferFunctionExpressionsParametersTypes(node.argumentList);\n      return;\n    }\n    DartType inferred = _inferArgumentTypesForGeneric(\n        node, node.function.staticType, node.typeArguments);\n    InferenceContext.setType(\n        node.argumentList, inferred ?? node.staticInvokeType);\n  }\n\n  void _inferFormalParameterList(FormalParameterList node, DartType type) {\n    if (typeAnalyzer.inferFormalParameterList(node, type)) {\n      // TODO(leafp): This gets dropped on the floor if we're in the field\n      // inference task.  We should probably keep these infos.\n      //\n      // TODO(jmesserly): this is reporting the context type, and therefore not\n      // necessarily the correct inferred type for the lambda.\n      //\n      // For example, `([x]) {}`  could be passed to `int -> void` but its type\n      // will really be `([int]) -> void`. Similar issue for named arguments.\n      // It can also happen if the return type is inferred later on to be\n      // more precise.\n      //\n      // This reporting bug defeats the deduplication of error messages and\n      // results in the same inference message being reported twice.\n      //\n      // To get this right, we'd have to delay reporting until we have the\n      // complete type including return type.\n      inferenceContext.recordInference(node.parent, type);\n    }\n  }\n\n  /**\n   * If given \"mayBeClosure\" is [FunctionExpression] without explicit parameters types and its\n   * required type is [FunctionType], then infer parameters types from [FunctionType].\n   */\n  void _inferFunctionExpressionParametersTypes(\n      Expression mayBeClosure, DartType mayByFunctionType) {\n    // TODO(mfairhurst): remove this code and callers. It's doing\n    // \"propagated type\" inference for the Dart 1 type system.\n    assert(!strongMode);\n    // prepare closure\n    if (mayBeClosure is! FunctionExpression) {\n      return;\n    }\n    FunctionExpression closure = mayBeClosure as FunctionExpression;\n    // prepare expected closure type\n    if (mayByFunctionType is! FunctionType) {\n      return;\n    }\n    FunctionType expectedClosureType = mayByFunctionType as FunctionType;\n    // If the expectedClosureType is not more specific than the static type,\n    // return.\n    DartType staticClosureType =\n        resolutionMap.elementDeclaredByFunctionExpression(closure)?.type;\n    if (staticClosureType != null &&\n        !FunctionTypeImpl.relate(\n            expectedClosureType,\n            staticClosureType,\n            (s, t) => true,\n            new TypeSystemImpl(typeProvider).instantiateToBounds,\n            parameterRelation: (t, s) =>\n                (t.type as TypeImpl).isMoreSpecificThan(s.type))) {\n      return;\n    }\n    // set propagated type for the closure\n    if (!strongMode) {\n      closure.propagatedType = expectedClosureType;\n    }\n    // set inferred types for parameters\n    NodeList<FormalParameter> parameters = closure.parameters.parameters;\n    List<ParameterElement> expectedParameters = expectedClosureType.parameters;\n    for (int i = 0;\n        i < parameters.length && i < expectedParameters.length;\n        i++) {\n      FormalParameter parameter = parameters[i];\n      ParameterElement element = parameter.element;\n      DartType currentType = _overrideManager.getBestType(element);\n      // may be override the type\n      DartType expectedType = expectedParameters[i].type;\n      if (currentType == null || expectedType.isMoreSpecificThan(currentType)) {\n        _overrideManager.setType(element, expectedType);\n      }\n    }\n  }\n\n  /**\n   * Try to infer types of parameters of the [FunctionExpression] arguments.\n   */\n  void _inferFunctionExpressionsParametersTypes(ArgumentList argumentList) {\n    NodeList<Expression> arguments = argumentList.arguments;\n    int length = arguments.length;\n    for (int i = 0; i < length; i++) {\n      Expression argument = arguments[i];\n      ParameterElement parameter = argument.propagatedParameterElement;\n      if (parameter == null) {\n        parameter = argument.staticParameterElement;\n      }\n      if (parameter != null) {\n        _inferFunctionExpressionParametersTypes(argument, parameter.type);\n      }\n    }\n  }\n\n  /**\n   * Return `true` if the given expression terminates abruptly (that is, if any expression\n   * following the given expression will not be reached).\n   *\n   * @param expression the expression being tested\n   * @return `true` if the given expression terminates abruptly\n   */\n  bool _isAbruptTerminationExpression(Expression expression) {\n    // TODO(brianwilkerson) This needs to be significantly improved. Ideally we\n    // would eventually turn this into a method on Expression that returns a\n    // termination indication (normal, abrupt with no exception, abrupt with an\n    // exception).\n    expression = expression?.unParenthesized;\n    return expression is ThrowExpression || expression is RethrowExpression;\n  }\n\n  /**\n   * Return `true` if the given statement terminates abruptly (that is, if any statement\n   * following the given statement will not be reached).\n   *\n   * @param statement the statement being tested\n   * @return `true` if the given statement terminates abruptly\n   */\n  bool _isAbruptTerminationStatement(Statement statement) {\n    // TODO(brianwilkerson) This needs to be significantly improved. Ideally we\n    // would eventually turn this into a method on Statement that returns a\n    // termination indication (normal, abrupt with no exception, abrupt with an\n    // exception).\n    //\n    // collinsn: it is unsound to assume that [break] and [continue] are\n    // \"abrupt\". See: https://code.google.com/p/dart/issues/detail?id=19929#c4\n    // (tests are included in TypePropagationTest.java).\n    // In general, the difficulty is loopy control flow.\n    //\n    // In the presence of exceptions things become much more complicated, but\n    // while we only use this to propagate at [if]-statement join points,\n    // checking for [return] may work well enough in the common case.\n    if (statement is ReturnStatement) {\n      return true;\n    } else if (statement is ExpressionStatement) {\n      return _isAbruptTerminationExpression(statement.expression);\n    } else if (statement is Block) {\n      NodeList<Statement> statements = statement.statements;\n      int size = statements.length;\n      if (size == 0) {\n        return false;\n      }\n\n      // This last-statement-is-return heuristic is unsound for adversarial\n      // code, but probably works well in the common case:\n      //\n      //   var x = 123;\n      //   var c = true;\n      //   L: if (c) {\n      //     x = \"hello\";\n      //     c = false;\n      //     break L;\n      //     return;\n      //   }\n      //   print(x);\n      //\n      // Unsound to assume that [x = \"hello\";] never executed after the\n      // if-statement. Of course, a dead-code analysis could point out that\n      // [return] here is dead.\n      return _isAbruptTerminationStatement(statements[size - 1]);\n    }\n    return false;\n  }\n\n  /**\n   * Return `true` if the given variable is accessed within a closure in the given\n   * [AstNode] and also mutated somewhere in variable scope. This information is only\n   * available for local variables (including parameters).\n   *\n   * @param variable the variable to check\n   * @param target the [AstNode] to check within\n   * @return `true` if this variable is potentially mutated somewhere in the given ASTNode\n   */\n  bool _isVariableAccessedInClosure(Element variable, AstNode target) {\n    _ResolverVisitor_isVariableAccessedInClosure visitor =\n        new _ResolverVisitor_isVariableAccessedInClosure(variable);\n    target.accept(visitor);\n    return visitor.result;\n  }\n\n  /**\n   * Return `true` if the given variable is potentially mutated somewhere in the given\n   * [AstNode]. This information is only available for local variables (including parameters).\n   *\n   * @param variable the variable to check\n   * @param target the [AstNode] to check within\n   * @return `true` if this variable is potentially mutated somewhere in the given ASTNode\n   */\n  bool _isVariablePotentiallyMutatedIn(Element variable, AstNode target) {\n    _ResolverVisitor_isVariablePotentiallyMutatedIn visitor =\n        new _ResolverVisitor_isVariablePotentiallyMutatedIn(variable);\n    target.accept(visitor);\n    return visitor.result;\n  }\n\n  /**\n   * If it is appropriate to do so, promotes the current type of the static element associated with\n   * the given expression with the given type. Generally speaking, it is appropriate if the given\n   * type is more specific than the current type.\n   *\n   * @param expression the expression used to access the static element whose types might be\n   *          promoted\n   * @param potentialType the potential type of the elements\n   */\n  void _promote(Expression expression, DartType potentialType) {\n    VariableElement element = getPromotionStaticElement(expression);\n    if (element != null) {\n      // may be mutated somewhere in closure\n      if (_currentFunctionBody.isPotentiallyMutatedInClosure(element)) {\n        return;\n      }\n      // prepare current variable type\n      DartType type = _promoteManager.getType(element) ??\n          expression.staticType ??\n          DynamicTypeImpl.instance;\n\n      potentialType ??= DynamicTypeImpl.instance;\n\n      // Check if we can promote to potentialType from type.\n      DartType promoteType = typeSystem.tryPromoteToType(potentialType, type);\n      if (promoteType != null) {\n        // Do promote type of variable.\n        _promoteManager.setType(element, promoteType);\n      }\n    }\n  }\n\n  /**\n   * Promotes type information using given condition.\n   */\n  void _promoteTypes(Expression condition) {\n    if (condition is BinaryExpression) {\n      if (condition.operator.type == TokenType.AMPERSAND_AMPERSAND) {\n        Expression left = condition.leftOperand;\n        Expression right = condition.rightOperand;\n        _promoteTypes(left);\n        _promoteTypes(right);\n        _clearTypePromotionsIfPotentiallyMutatedIn(right);\n      }\n    } else if (condition is IsExpression) {\n      if (condition.notOperator == null) {\n        _promote(condition.expression, condition.type.type);\n      }\n    } else if (condition is ParenthesizedExpression) {\n      _promoteTypes(condition.expression);\n    }\n  }\n\n  /**\n   * Propagate any type information that results from knowing that the given condition will have\n   * been evaluated to 'false'.\n   *\n   * @param condition the condition that will have evaluated to 'false'\n   */\n  void _propagateFalseState(Expression condition) {\n    if (condition is BinaryExpression) {\n      if (condition.operator.type == TokenType.BAR_BAR) {\n        _propagateFalseState(condition.leftOperand);\n        _propagateFalseState(condition.rightOperand);\n      }\n    } else if (condition is IsExpression) {\n      if (condition.notOperator != null) {\n        // Since an is-statement doesn't actually change the type, we don't\n        // let it affect the propagated type when it would result in a loss\n        // of precision.\n        overrideExpression(\n            condition.expression, condition.type.type, false, false);\n      }\n    } else if (condition is PrefixExpression) {\n      if (condition.operator.type == TokenType.BANG) {\n        _propagateTrueState(condition.operand);\n      }\n    } else if (condition is ParenthesizedExpression) {\n      _propagateFalseState(condition.expression);\n    }\n  }\n\n  /**\n   * Propagate any type information that results from knowing that the given expression will have\n   * been evaluated without altering the flow of execution.\n   *\n   * @param expression the expression that will have been evaluated\n   */\n  void _propagateState(Expression expression) {\n    // TODO(brianwilkerson) Implement this.\n  }\n\n  /**\n   * Propagate any type information that results from knowing that the given condition will have\n   * been evaluated to 'true'.\n   *\n   * @param condition the condition that will have evaluated to 'true'\n   */\n  void _propagateTrueState(Expression condition) {\n    if (condition is BinaryExpression) {\n      if (condition.operator.type == TokenType.AMPERSAND_AMPERSAND) {\n        _propagateTrueState(condition.leftOperand);\n        _propagateTrueState(condition.rightOperand);\n      }\n    } else if (condition is IsExpression) {\n      if (condition.notOperator == null) {\n        // Since an is-statement doesn't actually change the type, we don't\n        // let it affect the propagated type when it would result in a loss\n        // of precision.\n        overrideExpression(\n            condition.expression, condition.type.type, false, false);\n      }\n    } else if (condition is PrefixExpression) {\n      if (condition.operator.type == TokenType.BANG) {\n        _propagateFalseState(condition.operand);\n      }\n    } else if (condition is ParenthesizedExpression) {\n      _propagateTrueState(condition.expression);\n    }\n  }\n\n  /**\n   * Given an [argumentList] and the [parameters] related to the element that\n   * will be invoked using those arguments, compute the list of parameters that\n   * correspond to the list of arguments.\n   *\n   * An error will be reported to [onError] if any of the arguments cannot be\n   * matched to a parameter. onError can be null to ignore the error.\n   *\n   * The flag [reportAsError] should be `true` if a compile-time error should be\n   * reported; or `false` if a compile-time warning should be reported.\n   *\n   * Returns the parameters that correspond to the arguments. If no parameter\n   * matched an argument, that position will be `null` in the list.\n   */\n  static List<ParameterElement> resolveArgumentsToParameters(\n      ArgumentList argumentList,\n      List<ParameterElement> parameters,\n      void onError(ErrorCode errorCode, AstNode node, [List<Object> arguments]),\n      {bool reportAsError: false}) {\n    if (parameters.isEmpty && argumentList.arguments.isEmpty) {\n      return const <ParameterElement>[];\n    }\n    int requiredParameterCount = 0;\n    int unnamedParameterCount = 0;\n    List<ParameterElement> unnamedParameters = new List<ParameterElement>();\n    Map<String, ParameterElement> namedParameters = null;\n    int length = parameters.length;\n    for (int i = 0; i < length; i++) {\n      ParameterElement parameter = parameters[i];\n      if (parameter.isNotOptional) {\n        unnamedParameters.add(parameter);\n        unnamedParameterCount++;\n        requiredParameterCount++;\n      } else if (parameter.isOptionalPositional) {\n        unnamedParameters.add(parameter);\n        unnamedParameterCount++;\n      } else {\n        namedParameters ??= new HashMap<String, ParameterElement>();\n        namedParameters[parameter.name] = parameter;\n      }\n    }\n    int unnamedIndex = 0;\n    NodeList<Expression> arguments = argumentList.arguments;\n    int argumentCount = arguments.length;\n    List<ParameterElement> resolvedParameters =\n        new List<ParameterElement>(argumentCount);\n    int positionalArgumentCount = 0;\n    HashSet<String> usedNames = null;\n    bool noBlankArguments = true;\n    for (int i = 0; i < argumentCount; i++) {\n      Expression argument = arguments[i];\n      if (argument is NamedExpression) {\n        SimpleIdentifier nameNode = argument.name.label;\n        String name = nameNode.name;\n        ParameterElement element =\n            namedParameters != null ? namedParameters[name] : null;\n        if (element == null) {\n          ErrorCode errorCode = (reportAsError\n              ? CompileTimeErrorCode.UNDEFINED_NAMED_PARAMETER\n              : StaticWarningCode.UNDEFINED_NAMED_PARAMETER);\n          if (onError != null) {\n            onError(errorCode, nameNode, [name]);\n          }\n        } else {\n          resolvedParameters[i] = element;\n          nameNode.staticElement = element;\n        }\n        usedNames ??= new HashSet<String>();\n        if (!usedNames.add(name)) {\n          if (onError != null) {\n            onError(CompileTimeErrorCode.DUPLICATE_NAMED_ARGUMENT, nameNode,\n                [name]);\n          }\n        }\n      } else {\n        if (argument is SimpleIdentifier && argument.name.isEmpty) {\n          noBlankArguments = false;\n        }\n        positionalArgumentCount++;\n        if (unnamedIndex < unnamedParameterCount) {\n          resolvedParameters[i] = unnamedParameters[unnamedIndex++];\n        }\n      }\n    }\n    if (positionalArgumentCount < requiredParameterCount && noBlankArguments) {\n      ErrorCode errorCode = (reportAsError\n          ? CompileTimeErrorCode.NOT_ENOUGH_REQUIRED_ARGUMENTS\n          : StaticWarningCode.NOT_ENOUGH_REQUIRED_ARGUMENTS);\n      if (onError != null) {\n        onError(errorCode, argumentList,\n            [requiredParameterCount, positionalArgumentCount]);\n      }\n    } else if (positionalArgumentCount > unnamedParameterCount &&\n        noBlankArguments) {\n      ErrorCode errorCode;\n      int namedParameterCount = namedParameters?.length ?? 0;\n      int namedArgumentCount = usedNames?.length ?? 0;\n      if (namedParameterCount > namedArgumentCount) {\n        errorCode = (reportAsError\n            ? CompileTimeErrorCode.EXTRA_POSITIONAL_ARGUMENTS_COULD_BE_NAMED\n            : StaticWarningCode.EXTRA_POSITIONAL_ARGUMENTS_COULD_BE_NAMED);\n      } else {\n        errorCode = (reportAsError\n            ? CompileTimeErrorCode.EXTRA_POSITIONAL_ARGUMENTS\n            : StaticWarningCode.EXTRA_POSITIONAL_ARGUMENTS);\n      }\n      if (onError != null) {\n        onError(errorCode, argumentList,\n            [unnamedParameterCount, positionalArgumentCount]);\n      }\n    }\n    return resolvedParameters;\n  }\n}\n\n/**\n * The abstract class `ScopedVisitor` maintains name and label scopes as an AST structure is\n * being visited.\n */\nabstract class ScopedVisitor extends UnifyingAstVisitor<Object> {\n  /**\n   * The element for the library containing the compilation unit being visited.\n   */\n  final LibraryElement definingLibrary;\n\n  /**\n   * The source representing the compilation unit being visited.\n   */\n  final Source source;\n\n  /**\n   * The object used to access the types from the core library.\n   */\n  final TypeProvider typeProvider;\n\n  /**\n   * The error reporter that will be informed of any errors that are found\n   * during resolution.\n   */\n  final ErrorReporter errorReporter;\n\n  /**\n   * The scope used to resolve identifiers.\n   */\n  Scope nameScope;\n\n  /**\n   * The scope used to resolve unlabeled `break` and `continue` statements.\n   */\n  ImplicitLabelScope _implicitLabelScope = ImplicitLabelScope.ROOT;\n\n  /**\n   * The scope used to resolve labels for `break` and `continue` statements, or\n   * `null` if no labels have been defined in the current context.\n   */\n  LabelScope labelScope;\n\n  /**\n   * The class containing the AST nodes being visited,\n   * or `null` if we are not in the scope of a class.\n   */\n  ClassElement enclosingClass;\n\n  /**\n   * Initialize a newly created visitor to resolve the nodes in a compilation\n   * unit.\n   *\n   * [definingLibrary] is the element for the library containing the\n   * compilation unit being visited.\n   * [source] is the source representing the compilation unit being visited.\n   * [typeProvider] is the object used to access the types from the core\n   * library.\n   * [errorListener] is the error listener that will be informed of any errors\n   * that are found during resolution.\n   * [nameScope] is the scope used to resolve identifiers in the node that will\n   * first be visited.  If `null` or unspecified, a new [LibraryScope] will be\n   * created based on [definingLibrary] and [typeProvider].\n   */\n  ScopedVisitor(this.definingLibrary, Source source, this.typeProvider,\n      AnalysisErrorListener errorListener,\n      {Scope nameScope})\n      : source = source,\n        errorReporter = new ErrorReporter(errorListener, source) {\n    if (nameScope == null) {\n      this.nameScope = new LibraryScope(definingLibrary);\n    } else {\n      this.nameScope = nameScope;\n    }\n  }\n\n  /**\n   * Return the implicit label scope in which the current node is being\n   * resolved.\n   */\n  ImplicitLabelScope get implicitLabelScope => _implicitLabelScope;\n\n  /**\n   * Replaces the current [Scope] with the enclosing [Scope].\n   *\n   * @return the enclosing [Scope].\n   */\n  Scope popNameScope() {\n    nameScope = nameScope.enclosingScope;\n    return nameScope;\n  }\n\n  /**\n   * Pushes a new [Scope] into the visitor.\n   *\n   * @return the new [Scope].\n   */\n  Scope pushNameScope() {\n    Scope newScope = new EnclosedScope(nameScope);\n    nameScope = newScope;\n    return nameScope;\n  }\n\n  @override\n  Object visitBlock(Block node) {\n    Scope outerScope = nameScope;\n    try {\n      EnclosedScope enclosedScope = new BlockScope(nameScope, node);\n      nameScope = enclosedScope;\n      super.visitBlock(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitBlockFunctionBody(BlockFunctionBody node) {\n    ImplicitLabelScope implicitOuterScope = _implicitLabelScope;\n    try {\n      _implicitLabelScope = ImplicitLabelScope.ROOT;\n      super.visitBlockFunctionBody(node);\n    } finally {\n      _implicitLabelScope = implicitOuterScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitCatchClause(CatchClause node) {\n    SimpleIdentifier exception = node.exceptionParameter;\n    if (exception != null) {\n      Scope outerScope = nameScope;\n      try {\n        nameScope = new EnclosedScope(nameScope);\n        nameScope.define(exception.staticElement);\n        SimpleIdentifier stackTrace = node.stackTraceParameter;\n        if (stackTrace != null) {\n          nameScope.define(stackTrace.staticElement);\n        }\n        super.visitCatchClause(node);\n      } finally {\n        nameScope = outerScope;\n      }\n    } else {\n      super.visitCatchClause(node);\n    }\n    return null;\n  }\n\n  @override\n  Object visitClassDeclaration(ClassDeclaration node) {\n    ClassElement classElement = node.element;\n    Scope outerScope = nameScope;\n    try {\n      if (classElement == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for class declaration ${node.name.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n        super.visitClassDeclaration(node);\n      } else {\n        ClassElement outerClass = enclosingClass;\n        try {\n          enclosingClass = node.element;\n          nameScope = new TypeParameterScope(nameScope, classElement);\n          visitClassDeclarationInScope(node);\n          nameScope = new ClassScope(nameScope, classElement);\n          visitClassMembersInScope(node);\n        } finally {\n          enclosingClass = outerClass;\n        }\n      }\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitClassDeclarationInScope(ClassDeclaration node) {\n    node.name?.accept(this);\n    node.typeParameters?.accept(this);\n    node.extendsClause?.accept(this);\n    node.withClause?.accept(this);\n    node.implementsClause?.accept(this);\n    node.nativeClause?.accept(this);\n  }\n\n  void visitClassMembersInScope(ClassDeclaration node) {\n    node.documentationComment?.accept(this);\n    node.metadata.accept(this);\n    node.members.accept(this);\n  }\n\n  @override\n  Object visitClassTypeAlias(ClassTypeAlias node) {\n    Scope outerScope = nameScope;\n    try {\n      ClassElement element = node.element;\n      nameScope =\n          new ClassScope(new TypeParameterScope(nameScope, element), element);\n      super.visitClassTypeAlias(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    ConstructorElement constructorElement = node.element;\n    if (constructorElement == null) {\n      StringBuffer buffer = new StringBuffer();\n      buffer.write(\"Missing element for constructor \");\n      buffer.write(node.returnType.name);\n      if (node.name != null) {\n        buffer.write(\".\");\n        buffer.write(node.name.name);\n      }\n      buffer.write(\" in \");\n      buffer.write(definingLibrary.source.fullName);\n      AnalysisEngine.instance.logger.logInformation(buffer.toString(),\n          new CaughtException(new AnalysisException(), null));\n    }\n    Scope outerScope = nameScope;\n    try {\n      if (constructorElement != null) {\n        nameScope = new FunctionScope(nameScope, constructorElement);\n      }\n      node.documentationComment?.accept(this);\n      node.metadata.accept(this);\n      node.returnType?.accept(this);\n      node.name?.accept(this);\n      node.parameters?.accept(this);\n      Scope functionScope = nameScope;\n      try {\n        if (constructorElement != null) {\n          nameScope =\n              new ConstructorInitializerScope(nameScope, constructorElement);\n        }\n        node.initializers.accept(this);\n      } finally {\n        nameScope = functionScope;\n      }\n      node.redirectedConstructor?.accept(this);\n      visitConstructorDeclarationInScope(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitConstructorDeclarationInScope(ConstructorDeclaration node) {\n    node.body?.accept(this);\n  }\n\n  @override\n  Object visitDeclaredIdentifier(DeclaredIdentifier node) {\n    VariableElement element = node.element;\n    if (element != null) {\n      nameScope.define(element);\n    }\n    super.visitDeclaredIdentifier(node);\n    return null;\n  }\n\n  @override\n  Object visitDoStatement(DoStatement node) {\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      visitStatementInScope(node.body);\n      node.condition?.accept(this);\n    } finally {\n      _implicitLabelScope = outerImplicitScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitEnumDeclaration(EnumDeclaration node) {\n    ClassElement classElement = node.element;\n    Scope outerScope = nameScope;\n    try {\n      if (classElement == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for enum declaration ${node.name.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n        super.visitEnumDeclaration(node);\n      } else {\n        ClassElement outerClass = enclosingClass;\n        try {\n          enclosingClass = node.element;\n          nameScope = new ClassScope(nameScope, classElement);\n          visitEnumMembersInScope(node);\n        } finally {\n          enclosingClass = outerClass;\n        }\n      }\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitEnumMembersInScope(EnumDeclaration node) {\n    node.documentationComment?.accept(this);\n    node.metadata.accept(this);\n    node.constants.accept(this);\n  }\n\n  @override\n  Object visitForEachStatement(ForEachStatement node) {\n    Scope outerNameScope = nameScope;\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      nameScope = new EnclosedScope(nameScope);\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      visitForEachStatementInScope(node);\n    } finally {\n      nameScope = outerNameScope;\n      _implicitLabelScope = outerImplicitScope;\n    }\n    return null;\n  }\n\n  /**\n   * Visit the given statement after it's scope has been created. This replaces the normal call to\n   * the inherited visit method so that ResolverVisitor can intervene when type propagation is\n   * enabled.\n   *\n   * @param node the statement to be visited\n   */\n  void visitForEachStatementInScope(ForEachStatement node) {\n    //\n    // We visit the iterator before the loop variable because the loop variable\n    // cannot be in scope while visiting the iterator.\n    //\n    node.identifier?.accept(this);\n    node.iterable?.accept(this);\n    node.loopVariable?.accept(this);\n    visitStatementInScope(node.body);\n  }\n\n  @override\n  Object visitFormalParameterList(FormalParameterList node) {\n    super.visitFormalParameterList(node);\n    // We finished resolving function signature, now include formal parameters\n    // scope.  Note: we must not do this if the parent is a\n    // FunctionTypedFormalParameter, because in that case we aren't finished\n    // resolving the full function signature, just a part of it.\n    if (nameScope is FunctionScope &&\n        node.parent is! FunctionTypedFormalParameter) {\n      (nameScope as FunctionScope).defineParameters();\n    }\n    if (nameScope is FunctionTypeScope) {\n      (nameScope as FunctionTypeScope).defineParameters();\n    }\n    return null;\n  }\n\n  @override\n  Object visitForStatement(ForStatement node) {\n    Scope outerNameScope = nameScope;\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      nameScope = new EnclosedScope(nameScope);\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      visitForStatementInScope(node);\n    } finally {\n      nameScope = outerNameScope;\n      _implicitLabelScope = outerImplicitScope;\n    }\n    return null;\n  }\n\n  /**\n   * Visit the given statement after it's scope has been created. This replaces the normal call to\n   * the inherited visit method so that ResolverVisitor can intervene when type propagation is\n   * enabled.\n   *\n   * @param node the statement to be visited\n   */\n  void visitForStatementInScope(ForStatement node) {\n    node.variables?.accept(this);\n    node.initialization?.accept(this);\n    node.condition?.accept(this);\n    node.updaters.accept(this);\n    visitStatementInScope(node.body);\n  }\n\n  @override\n  Object visitFunctionDeclaration(FunctionDeclaration node) {\n    ExecutableElement functionElement = node.element;\n    if (functionElement != null &&\n        functionElement.enclosingElement is! CompilationUnitElement) {\n      nameScope.define(functionElement);\n    }\n    Scope outerScope = nameScope;\n    try {\n      if (functionElement == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for top-level function ${node.name.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n      } else {\n        nameScope = new FunctionScope(nameScope, functionElement);\n      }\n      visitFunctionDeclarationInScope(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitFunctionDeclarationInScope(FunctionDeclaration node) {\n    super.visitFunctionDeclaration(node);\n  }\n\n  @override\n  Object visitFunctionExpression(FunctionExpression node) {\n    if (node.parent is FunctionDeclaration) {\n      // We have already created a function scope and don't need to do so again.\n      super.visitFunctionExpression(node);\n    } else {\n      Scope outerScope = nameScope;\n      try {\n        ExecutableElement functionElement = node.element;\n        if (functionElement == null) {\n          StringBuffer buffer = new StringBuffer();\n          buffer.write(\"Missing element for function \");\n          AstNode parent = node.parent;\n          while (parent != null) {\n            if (parent is Declaration) {\n              Element parentElement = parent.element;\n              buffer.write(parentElement == null\n                  ? \"<unknown> \"\n                  : \"${parentElement.name} \");\n            }\n            parent = parent.parent;\n          }\n          buffer.write(\"in \");\n          buffer.write(definingLibrary.source.fullName);\n          AnalysisEngine.instance.logger.logInformation(buffer.toString(),\n              new CaughtException(new AnalysisException(), null));\n        } else {\n          nameScope = new FunctionScope(nameScope, functionElement);\n        }\n        super.visitFunctionExpression(node);\n      } finally {\n        nameScope = outerScope;\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitFunctionTypeAlias(FunctionTypeAlias node) {\n    Scope outerScope = nameScope;\n    try {\n      nameScope = new FunctionTypeScope(nameScope, node.element);\n      visitFunctionTypeAliasInScope(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitFunctionTypeAliasInScope(FunctionTypeAlias node) {\n    super.visitFunctionTypeAlias(node);\n  }\n\n  @override\n  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {\n    Scope outerScope = nameScope;\n    try {\n      ParameterElement parameterElement = node.element;\n      if (parameterElement == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for function typed formal parameter ${node.identifier.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n      } else {\n        nameScope = new EnclosedScope(nameScope);\n        GenericFunctionTypeElement typeElement = parameterElement.type.element;\n        List<TypeParameterElement> typeParameters = typeElement.typeParameters;\n        int length = typeParameters.length;\n        for (int i = 0; i < length; i++) {\n          nameScope.define(typeParameters[i]);\n        }\n      }\n      super.visitFunctionTypedFormalParameter(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitGenericFunctionType(GenericFunctionType node) {\n    DartType type = node.type;\n    if (type == null) {\n      // The function type hasn't been resolved yet, so we can't create a scope\n      // for its parameters.\n      return super.visitGenericFunctionType(node);\n    }\n    GenericFunctionTypeElement element = type.element;\n    Scope outerScope = nameScope;\n    try {\n      if (element == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for generic function type in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n        super.visitGenericFunctionType(node);\n      } else {\n        nameScope = new TypeParameterScope(nameScope, element);\n        super.visitGenericFunctionType(node);\n      }\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitGenericTypeAlias(GenericTypeAlias node) {\n    GenericTypeAliasElement element = node.element;\n    Scope outerScope = nameScope;\n    try {\n      if (element == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for generic function type in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n        super.visitGenericTypeAlias(node);\n      } else {\n        nameScope = new TypeParameterScope(nameScope, element);\n        super.visitGenericTypeAlias(node);\n\n        GenericFunctionTypeElement functionElement = element.function;\n        if (functionElement != null) {\n          nameScope = new FunctionScope(nameScope, functionElement)\n            ..defineParameters();\n          visitGenericTypeAliasInFunctionScope(node);\n        }\n      }\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  Object visitGenericTypeAliasInFunctionScope(GenericTypeAlias node) {\n    return null;\n  }\n\n  @override\n  Object visitIfStatement(IfStatement node) {\n    node.condition?.accept(this);\n    visitStatementInScope(node.thenStatement);\n    visitStatementInScope(node.elseStatement);\n    return null;\n  }\n\n  @override\n  Object visitLabeledStatement(LabeledStatement node) {\n    LabelScope outerScope = _addScopesFor(node.labels, node.unlabeled);\n    try {\n      super.visitLabeledStatement(node);\n    } finally {\n      labelScope = outerScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    Scope outerScope = nameScope;\n    try {\n      ExecutableElement methodElement = node.element;\n      if (methodElement == null) {\n        AnalysisEngine.instance.logger.logInformation(\n            \"Missing element for method ${node.name.name} in ${definingLibrary.source.fullName}\",\n            new CaughtException(new AnalysisException(), null));\n      } else {\n        nameScope = new FunctionScope(nameScope, methodElement);\n      }\n      visitMethodDeclarationInScope(node);\n    } finally {\n      nameScope = outerScope;\n    }\n    return null;\n  }\n\n  void visitMethodDeclarationInScope(MethodDeclaration node) {\n    super.visitMethodDeclaration(node);\n  }\n\n  /**\n   * Visit the given statement after it's scope has been created. This is used by ResolverVisitor to\n   * correctly visit the 'then' and 'else' statements of an 'if' statement.\n   *\n   * @param node the statement to be visited\n   */\n  void visitStatementInScope(Statement node) {\n    if (node is Block) {\n      // Don't create a scope around a block because the block will create it's\n      // own scope.\n      visitBlock(node);\n    } else if (node != null) {\n      Scope outerNameScope = nameScope;\n      try {\n        nameScope = new EnclosedScope(nameScope);\n        node.accept(this);\n      } finally {\n        nameScope = outerNameScope;\n      }\n    }\n  }\n\n  @override\n  Object visitSwitchCase(SwitchCase node) {\n    node.expression.accept(this);\n    Scope outerNameScope = nameScope;\n    try {\n      nameScope = new EnclosedScope(nameScope);\n      node.statements.accept(this);\n    } finally {\n      nameScope = outerNameScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitSwitchDefault(SwitchDefault node) {\n    Scope outerNameScope = nameScope;\n    try {\n      nameScope = new EnclosedScope(nameScope);\n      node.statements.accept(this);\n    } finally {\n      nameScope = outerNameScope;\n    }\n    return null;\n  }\n\n  @override\n  Object visitSwitchStatement(SwitchStatement node) {\n    LabelScope outerScope = labelScope;\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      for (SwitchMember member in node.members) {\n        for (Label label in member.labels) {\n          SimpleIdentifier labelName = label.label;\n          LabelElement labelElement = labelName.staticElement as LabelElement;\n          labelScope =\n              new LabelScope(labelScope, labelName.name, member, labelElement);\n        }\n      }\n      visitSwitchStatementInScope(node);\n    } finally {\n      labelScope = outerScope;\n      _implicitLabelScope = outerImplicitScope;\n    }\n    return null;\n  }\n\n  void visitSwitchStatementInScope(SwitchStatement node) {\n    super.visitSwitchStatement(node);\n  }\n\n  @override\n  Object visitVariableDeclaration(VariableDeclaration node) {\n    super.visitVariableDeclaration(node);\n    if (node.parent.parent is! TopLevelVariableDeclaration &&\n        node.parent.parent is! FieldDeclaration) {\n      VariableElement element = node.element;\n      if (element != null) {\n        nameScope.define(element);\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitWhileStatement(WhileStatement node) {\n    node.condition?.accept(this);\n    ImplicitLabelScope outerImplicitScope = _implicitLabelScope;\n    try {\n      _implicitLabelScope = _implicitLabelScope.nest(node);\n      visitStatementInScope(node.body);\n    } finally {\n      _implicitLabelScope = outerImplicitScope;\n    }\n    return null;\n  }\n\n  /**\n   * Add scopes for each of the given labels.\n   *\n   * @param labels the labels for which new scopes are to be added\n   * @return the scope that was in effect before the new scopes were added\n   */\n  LabelScope _addScopesFor(NodeList<Label> labels, AstNode node) {\n    LabelScope outerScope = labelScope;\n    for (Label label in labels) {\n      SimpleIdentifier labelNameNode = label.label;\n      String labelName = labelNameNode.name;\n      LabelElement labelElement = labelNameNode.staticElement as LabelElement;\n      labelScope = new LabelScope(labelScope, labelName, node, labelElement);\n    }\n    return outerScope;\n  }\n}\n\n/**\n * Instances of this class manage the knowledge of what the set of subtypes are for a given type.\n */\nclass SubtypeManager {\n  /**\n   * A map between [ClassElement]s and a set of [ClassElement]s that are subtypes of the\n   * key.\n   */\n  Map<ClassElement, HashSet<ClassElement>> _subtypeMap =\n      new HashMap<ClassElement, HashSet<ClassElement>>();\n\n  /**\n   * The set of all [LibraryElement]s that have been visited by the manager. This is used both\n   * to prevent infinite loops in the recursive methods, and also as a marker for the scope of the\n   * libraries visited by this manager.\n   */\n  HashSet<LibraryElement> _visitedLibraries = new HashSet<LibraryElement>();\n\n  /**\n   * Given some [ClassElement], return the set of all subtypes, and subtypes of subtypes.\n   *\n   * @param classElement the class to recursively return the set of subtypes of\n   */\n  HashSet<ClassElement> computeAllSubtypes(ClassElement classElement) {\n    // Ensure that we have generated the subtype map for the library\n    _computeSubtypesInLibrary(classElement.library);\n    // use the subtypeMap to compute the set of all subtypes and subtype's\n    // subtypes\n    HashSet<ClassElement> allSubtypes = new HashSet<ClassElement>();\n    _safelyComputeAllSubtypes(\n        classElement, new HashSet<ClassElement>(), allSubtypes);\n    return allSubtypes;\n  }\n\n  /**\n   * Given some [LibraryElement], visit all of the types in the library, the passed library,\n   * and any imported libraries, will be in the [visitedLibraries] set.\n   *\n   * @param libraryElement the library to visit, it it hasn't been visited already\n   */\n  void ensureLibraryVisited(LibraryElement libraryElement) {\n    _computeSubtypesInLibrary(libraryElement);\n  }\n\n  /**\n   * Given some [ClassElement], this method adds all of the pairs combinations of itself and\n   * all of its supertypes to the [subtypeMap] map.\n   *\n   * @param classElement the class element\n   */\n  void _computeSubtypesInClass(ClassElement classElement) {\n    InterfaceType supertypeType = classElement.supertype;\n    if (supertypeType != null) {\n      ClassElement supertypeElement = supertypeType.element;\n      if (supertypeElement != null) {\n        _putInSubtypeMap(supertypeElement, classElement);\n      }\n    }\n    List<InterfaceType> interfaceTypes = classElement.interfaces;\n    int interfaceLength = interfaceTypes.length;\n    for (int i = 0; i < interfaceLength; i++) {\n      InterfaceType interfaceType = interfaceTypes[i];\n      ClassElement interfaceElement = interfaceType.element;\n      if (interfaceElement != null) {\n        _putInSubtypeMap(interfaceElement, classElement);\n      }\n    }\n    List<InterfaceType> mixinTypes = classElement.mixins;\n    int mixinLength = mixinTypes.length;\n    for (int i = 0; i < mixinLength; i++) {\n      InterfaceType mixinType = mixinTypes[i];\n      ClassElement mixinElement = mixinType.element;\n      if (mixinElement != null) {\n        _putInSubtypeMap(mixinElement, classElement);\n      }\n    }\n  }\n\n  /**\n   * Given some [CompilationUnitElement], this method calls\n   * [computeAllSubtypes] on all of the [ClassElement]s in the\n   * compilation unit.\n   *\n   * @param unitElement the compilation unit element\n   */\n  void _computeSubtypesInCompilationUnit(CompilationUnitElement unitElement) {\n    List<ClassElement> classElements = unitElement.types;\n    int length = classElements.length;\n    for (int i = 0; i < length; i++) {\n      ClassElement classElement = classElements[i];\n      _computeSubtypesInClass(classElement);\n    }\n  }\n\n  /**\n   * Given some [LibraryElement], this method calls\n   * [computeAllSubtypes] on all of the [ClassElement]s in the\n   * compilation unit, and itself for all imported and exported libraries. All visited libraries are\n   * added to the [visitedLibraries] set.\n   *\n   * @param libraryElement the library element\n   */\n  void _computeSubtypesInLibrary(LibraryElement libraryElement) {\n    if (libraryElement == null || _visitedLibraries.contains(libraryElement)) {\n      return;\n    }\n    _visitedLibraries.add(libraryElement);\n    _computeSubtypesInCompilationUnit(libraryElement.definingCompilationUnit);\n    List<CompilationUnitElement> parts = libraryElement.parts;\n    int partLength = parts.length;\n    for (int i = 0; i < partLength; i++) {\n      CompilationUnitElement part = parts[i];\n      _computeSubtypesInCompilationUnit(part);\n    }\n    List<LibraryElement> imports = libraryElement.importedLibraries;\n    int importLength = imports.length;\n    for (int i = 0; i < importLength; i++) {\n      LibraryElement importElt = imports[i];\n      _computeSubtypesInLibrary(importElt.library);\n    }\n    List<LibraryElement> exports = libraryElement.exportedLibraries;\n    int exportLength = exports.length;\n    for (int i = 0; i < exportLength; i++) {\n      LibraryElement exportElt = exports[i];\n      _computeSubtypesInLibrary(exportElt.library);\n    }\n  }\n\n  /**\n   * Add some key/ value pair into the [subtypeMap] map.\n   *\n   * @param supertypeElement the key for the [subtypeMap] map\n   * @param subtypeElement the value for the [subtypeMap] map\n   */\n  void _putInSubtypeMap(\n      ClassElement supertypeElement, ClassElement subtypeElement) {\n    HashSet<ClassElement> subtypes = _subtypeMap[supertypeElement];\n    if (subtypes == null) {\n      subtypes = new HashSet<ClassElement>();\n      _subtypeMap[supertypeElement] = subtypes;\n    }\n    subtypes.add(subtypeElement);\n  }\n\n  /**\n   * Given some [ClassElement] and a [HashSet<ClassElement>], this method recursively\n   * adds all of the subtypes of the [ClassElement] to the passed array.\n   *\n   * @param classElement the type to compute the set of subtypes of\n   * @param visitedClasses the set of class elements that this method has already recursively seen\n   * @param allSubtypes the computed set of subtypes of the passed class element\n   */\n  void _safelyComputeAllSubtypes(ClassElement classElement,\n      HashSet<ClassElement> visitedClasses, HashSet<ClassElement> allSubtypes) {\n    if (!visitedClasses.add(classElement)) {\n      // if this class has already been called on this class element\n      return;\n    }\n    HashSet<ClassElement> subtypes = _subtypeMap[classElement];\n    if (subtypes == null) {\n      return;\n    }\n    for (ClassElement subtype in subtypes) {\n      _safelyComputeAllSubtypes(subtype, visitedClasses, allSubtypes);\n    }\n    allSubtypes.addAll(subtypes);\n  }\n}\n\n/**\n * Instances of the class `ToDoFinder` find to-do comments in Dart code.\n */\nclass ToDoFinder {\n  /**\n   * The error reporter by which to-do comments will be reported.\n   */\n  final ErrorReporter _errorReporter;\n\n  /**\n   * Initialize a newly created to-do finder to report to-do comments to the given reporter.\n   *\n   * @param errorReporter the error reporter by which to-do comments will be reported\n   */\n  ToDoFinder(this._errorReporter);\n\n  /**\n   * Search the comments in the given compilation unit for to-do comments and report an error for\n   * each.\n   *\n   * @param unit the compilation unit containing the to-do comments\n   */\n  void findIn(CompilationUnit unit) {\n    _gatherTodoComments(unit.beginToken);\n  }\n\n  /**\n   * Search the comment tokens reachable from the given token and create errors for each to-do\n   * comment.\n   *\n   * @param token the head of the list of tokens being searched\n   */\n  void _gatherTodoComments(Token token) {\n    while (token != null && token.type != TokenType.EOF) {\n      Token commentToken = token.precedingComments;\n      while (commentToken != null) {\n        if (commentToken.type == TokenType.SINGLE_LINE_COMMENT ||\n            commentToken.type == TokenType.MULTI_LINE_COMMENT) {\n          _scrapeTodoComment(commentToken);\n        }\n        commentToken = commentToken.next;\n      }\n      token = token.next;\n    }\n  }\n\n  /**\n   * Look for user defined tasks in comments and convert them into info level analysis issues.\n   *\n   * @param commentToken the comment token to analyze\n   */\n  void _scrapeTodoComment(Token commentToken) {\n    Iterable<Match> matches =\n        TodoCode.TODO_REGEX.allMatches(commentToken.lexeme);\n    for (Match match in matches) {\n      int offset = commentToken.offset + match.start + match.group(1).length;\n      int length = match.group(2).length;\n      _errorReporter.reportErrorForOffset(\n          TodoCode.TODO, offset, length, [match.group(2)]);\n    }\n  }\n}\n\n/**\n * Helper for resolving types.\n *\n * The client must set [nameScope] before calling [resolveTypeName].\n */\nclass TypeNameResolver {\n  final TypeSystem typeSystem;\n  final DartType dynamicType;\n  final DartType undefinedType;\n  final LibraryElement definingLibrary;\n  final Source source;\n  final AnalysisErrorListener errorListener;\n\n  Scope nameScope;\n\n  TypeNameResolver(this.typeSystem, TypeProvider typeProvider,\n      this.definingLibrary, this.source, this.errorListener)\n      : dynamicType = typeProvider.dynamicType,\n        undefinedType = typeProvider.undefinedType;\n\n  /**\n   * Report an error with the given error code and arguments.\n   *\n   * @param errorCode the error code of the error to be reported\n   * @param node the node specifying the location of the error\n   * @param arguments the arguments to the error, used to compose the error message\n   */\n  void reportErrorForNode(ErrorCode errorCode, AstNode node,\n      [List<Object> arguments]) {\n    errorListener.onError(new AnalysisError(\n        source, node.offset, node.length, errorCode, arguments));\n  }\n\n  /**\n   * Resolve the given [TypeName] - set its element and static type. Only the\n   * given [node] is resolved, all its children must be already resolved.\n   *\n   * The client must set [nameScope] before calling [resolveTypeName].\n   */\n  void resolveTypeName(TypeName node) {\n    Identifier typeName = node.name;\n    _setElement(typeName, null); // Clear old Elements from previous run.\n    TypeArgumentList argumentList = node.typeArguments;\n    Element element = nameScope.lookup(typeName, definingLibrary);\n    if (element == null) {\n      //\n      // Check to see whether the type name is either 'dynamic' or 'void',\n      // neither of which are in the name scope and hence will not be found by\n      // normal means.\n      //\n      VoidTypeImpl voidType = VoidTypeImpl.instance;\n      if (typeName.name == voidType.name) {\n        // There is no element for 'void'.\n//        if (argumentList != null) {\n//          // TODO(brianwilkerson) Report this error\n//          reporter.reportError(StaticTypeWarningCode.WRONG_NUMBER_OF_TYPE_ARGUMENTS, node, voidType.getName(), 0, argumentList.getArguments().size());\n//        }\n        typeName.staticType = voidType;\n        node.type = voidType;\n        return;\n      }\n      if (nameScope.shouldIgnoreUndefined(typeName)) {\n        typeName.staticType = undefinedType;\n        node.type = undefinedType;\n        return;\n      }\n      //\n      // If not, the look to see whether we might have created the wrong AST\n      // structure for a constructor name. If so, fix the AST structure and then\n      // proceed.\n      //\n      AstNode parent = node.parent;\n      if (typeName is PrefixedIdentifier &&\n          parent is ConstructorName &&\n          argumentList == null) {\n        ConstructorName name = parent;\n        if (name.name == null) {\n          PrefixedIdentifier prefixedIdentifier =\n              typeName as PrefixedIdentifier;\n          SimpleIdentifier prefix = prefixedIdentifier.prefix;\n          element = nameScope.lookup(prefix, definingLibrary);\n          if (element is PrefixElement) {\n            if (nameScope.shouldIgnoreUndefined(typeName)) {\n              typeName.staticType = undefinedType;\n              node.type = undefinedType;\n              return;\n            }\n            AstNode grandParent = parent.parent;\n            if (grandParent is InstanceCreationExpression &&\n                grandParent.isConst) {\n              // If, if this is a const expression, then generate a\n              // CompileTimeErrorCode.CONST_WITH_NON_TYPE error.\n              reportErrorForNode(\n                  CompileTimeErrorCode.CONST_WITH_NON_TYPE,\n                  prefixedIdentifier.identifier,\n                  [prefixedIdentifier.identifier.name]);\n            } else {\n              // Else, if this expression is a new expression, report a\n              // NEW_WITH_NON_TYPE warning.\n              reportErrorForNode(\n                  StaticWarningCode.NEW_WITH_NON_TYPE,\n                  prefixedIdentifier.identifier,\n                  [prefixedIdentifier.identifier.name]);\n            }\n            _setElement(prefix, element);\n            return;\n          } else if (element != null) {\n            //\n            // Rewrite the constructor name. The parser, when it sees a\n            // constructor named \"a.b\", cannot tell whether \"a\" is a prefix and\n            // \"b\" is a class name, or whether \"a\" is a class name and \"b\" is a\n            // constructor name. It arbitrarily chooses the former, but in this\n            // case was wrong.\n            //\n            name.name = prefixedIdentifier.identifier;\n            name.period = prefixedIdentifier.period;\n            node.name = prefix;\n            typeName = prefix;\n          }\n        }\n      }\n      if (nameScope.shouldIgnoreUndefined(typeName)) {\n        typeName.staticType = undefinedType;\n        node.type = undefinedType;\n        return;\n      }\n    }\n    // check element\n    bool elementValid = element is! MultiplyDefinedElement;\n    if (elementValid &&\n        element is! ClassElement &&\n        _isTypeNameInInstanceCreationExpression(node)) {\n      SimpleIdentifier typeNameSimple = _getTypeSimpleIdentifier(typeName);\n      InstanceCreationExpression creation =\n          node.parent.parent as InstanceCreationExpression;\n      if (creation.isConst) {\n        if (element == null) {\n          reportErrorForNode(\n              CompileTimeErrorCode.UNDEFINED_CLASS, typeNameSimple, [typeName]);\n        } else {\n          reportErrorForNode(CompileTimeErrorCode.CONST_WITH_NON_TYPE,\n              typeNameSimple, [typeName]);\n        }\n        elementValid = false;\n      } else {\n        if (element != null) {\n          reportErrorForNode(\n              StaticWarningCode.NEW_WITH_NON_TYPE, typeNameSimple, [typeName]);\n          elementValid = false;\n        }\n      }\n    }\n    if (elementValid && element == null) {\n      // We couldn't resolve the type name.\n      // TODO(jwren) Consider moving the check for\n      // CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE from the\n      // ErrorVerifier, so that we don't have two errors on a built in\n      // identifier being used as a class name.\n      // See CompileTimeErrorCodeTest.test_builtInIdentifierAsType().\n      SimpleIdentifier typeNameSimple = _getTypeSimpleIdentifier(typeName);\n      RedirectingConstructorKind redirectingConstructorKind;\n      if (_isBuiltInIdentifier(node) && _isTypeAnnotation(node)) {\n        reportErrorForNode(CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE,\n            typeName, [typeName.name]);\n      } else if (typeNameSimple.name == \"boolean\") {\n        reportErrorForNode(\n            StaticWarningCode.UNDEFINED_CLASS_BOOLEAN, typeNameSimple, []);\n      } else if (_isTypeNameInCatchClause(node)) {\n        reportErrorForNode(StaticWarningCode.NON_TYPE_IN_CATCH_CLAUSE, typeName,\n            [typeName.name]);\n      } else if (_isTypeNameInAsExpression(node)) {\n        reportErrorForNode(\n            StaticWarningCode.CAST_TO_NON_TYPE, typeName, [typeName.name]);\n      } else if (_isTypeNameInIsExpression(node)) {\n        reportErrorForNode(StaticWarningCode.TYPE_TEST_WITH_UNDEFINED_NAME,\n            typeName, [typeName.name]);\n      } else if ((redirectingConstructorKind =\n              _getRedirectingConstructorKind(node)) !=\n          null) {\n        ErrorCode errorCode =\n            (redirectingConstructorKind == RedirectingConstructorKind.CONST\n                ? CompileTimeErrorCode.REDIRECT_TO_NON_CLASS\n                : StaticWarningCode.REDIRECT_TO_NON_CLASS);\n        reportErrorForNode(errorCode, typeName, [typeName.name]);\n      } else if (_isTypeNameInTypeArgumentList(node)) {\n        reportErrorForNode(StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT,\n            typeName, [typeName.name]);\n      } else {\n        reportErrorForNode(\n            StaticWarningCode.UNDEFINED_CLASS, typeName, [typeName.name]);\n      }\n      elementValid = false;\n    }\n    if (!elementValid) {\n      if (element is MultiplyDefinedElement) {\n        _setElement(typeName, element);\n      }\n      typeName.staticType = undefinedType;\n      node.type = undefinedType;\n      return;\n    }\n    DartType type = null;\n    if (element is ClassElement) {\n      type = element.type;\n      // In non-strong mode `FutureOr<T>` is treated as `dynamic`\n      if (!typeSystem.isStrong && type.isDartAsyncFutureOr) {\n        type = dynamicType;\n        _setElement(typeName, type.element);\n        typeName.staticType = type;\n        node.type = type;\n        if (argumentList != null) {\n          NodeList<TypeAnnotation> arguments = argumentList.arguments;\n          if (arguments.length != 1) {\n            reportErrorForNode(_getInvalidTypeParametersErrorCode(node), node,\n                [typeName.name, 1, arguments.length]);\n          }\n        }\n        return;\n      }\n      _setElement(typeName, element);\n    } else if (element is TypeDefiningElement &&\n        element.kind == ElementKind.DYNAMIC) {\n//      if (argumentList != null) {\n//        // Type parameters cannot have type arguments.\n//        // TODO(mfairhurst) Report this error.\n//        resolver.reportError(ResolverErrorCode.?, keyType);\n//      }\n      _setElement(typeName, element);\n      typeName.staticType = element.type;\n      node.type = element.type;\n      return;\n    } else if (element is FunctionTypeAliasElement) {\n      _setElement(typeName, element);\n      type = element.type;\n    } else if (element is TypeParameterElement) {\n      _setElement(typeName, element);\n      type = element.type;\n//      if (argumentList != null) {\n//        // Type parameters cannot have type arguments.\n//        // TODO(brianwilkerson) Report this error.\n//        //      resolver.reportError(ResolverErrorCode.?, keyType);\n//      }\n    } else if (element is MultiplyDefinedElement) {\n      List<Element> elements = element.conflictingElements;\n      type = _getTypeWhenMultiplyDefined(elements);\n      if (type != null) {\n        node.type = type;\n      }\n    } else {\n      // The name does not represent a type.\n      RedirectingConstructorKind redirectingConstructorKind;\n      if (_isTypeNameInCatchClause(node)) {\n        reportErrorForNode(StaticWarningCode.NON_TYPE_IN_CATCH_CLAUSE, typeName,\n            [typeName.name]);\n      } else if (_isTypeNameInAsExpression(node)) {\n        reportErrorForNode(\n            StaticWarningCode.CAST_TO_NON_TYPE, typeName, [typeName.name]);\n      } else if (_isTypeNameInIsExpression(node)) {\n        reportErrorForNode(StaticWarningCode.TYPE_TEST_WITH_NON_TYPE, typeName,\n            [typeName.name]);\n      } else if ((redirectingConstructorKind =\n              _getRedirectingConstructorKind(node)) !=\n          null) {\n        ErrorCode errorCode =\n            (redirectingConstructorKind == RedirectingConstructorKind.CONST\n                ? CompileTimeErrorCode.REDIRECT_TO_NON_CLASS\n                : StaticWarningCode.REDIRECT_TO_NON_CLASS);\n        reportErrorForNode(errorCode, typeName, [typeName.name]);\n      } else if (_isTypeNameInTypeArgumentList(node)) {\n        reportErrorForNode(StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT,\n            typeName, [typeName.name]);\n      } else {\n        AstNode parent = typeName.parent;\n        while (parent is TypeName) {\n          parent = parent.parent;\n        }\n        if (parent is ExtendsClause ||\n            parent is ImplementsClause ||\n            parent is WithClause ||\n            parent is ClassTypeAlias) {\n          // Ignored. The error will be reported elsewhere.\n        } else if (element is LocalVariableElement ||\n            (element is FunctionElement &&\n                element.enclosingElement is ExecutableElement)) {\n          reportErrorForNode(CompileTimeErrorCode.REFERENCED_BEFORE_DECLARATION,\n              typeName, [typeName.name]);\n        } else {\n          reportErrorForNode(\n              StaticWarningCode.NOT_A_TYPE, typeName, [typeName.name]);\n        }\n      }\n      typeName.staticType = dynamicType;\n      node.type = dynamicType;\n      return;\n    }\n    if (argumentList != null) {\n      NodeList<TypeAnnotation> arguments = argumentList.arguments;\n      int argumentCount = arguments.length;\n      List<DartType> parameters = typeSystem.typeFormalsAsTypes(type);\n      int parameterCount = parameters.length;\n      List<DartType> typeArguments = new List<DartType>(parameterCount);\n      if (argumentCount == parameterCount) {\n        for (int i = 0; i < parameterCount; i++) {\n          typeArguments[i] = _getType(arguments[i]);\n        }\n      } else {\n        reportErrorForNode(_getInvalidTypeParametersErrorCode(node), node,\n            [typeName.name, parameterCount, argumentCount]);\n        for (int i = 0; i < parameterCount; i++) {\n          typeArguments[i] = dynamicType;\n        }\n      }\n      if (element is GenericTypeAliasElementImpl) {\n        type = element.typeAfterSubstitution(typeArguments) ?? dynamicType;\n      } else {\n        type = typeSystem.instantiateType(type, typeArguments);\n      }\n    } else {\n      if (element is GenericTypeAliasElementImpl) {\n        List<DartType> typeArguments =\n            typeSystem.instantiateTypeFormalsToBounds(element.typeParameters);\n        type = element.typeAfterSubstitution(typeArguments) ?? dynamicType;\n      } else {\n        DartType redirectedType =\n            _inferTypeArgumentsForRedirectedConstructor(node, type);\n        if (redirectedType != null) {\n          type = redirectedType;\n        } else {\n          type = typeSystem.instantiateToBounds(type);\n        }\n      }\n    }\n    typeName.staticType = type;\n    node.type = type;\n  }\n\n  /**\n   * The number of type arguments in the given [typeName] does not match the\n   * number of parameters in the corresponding class element. Return the error\n   * code that should be used to report this error.\n   */\n  ErrorCode _getInvalidTypeParametersErrorCode(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is ConstructorName) {\n      parent = parent.parent;\n      if (parent is InstanceCreationExpression) {\n        if (parent.isConst) {\n          return CompileTimeErrorCode.CONST_WITH_INVALID_TYPE_PARAMETERS;\n        } else {\n          return StaticWarningCode.NEW_WITH_INVALID_TYPE_PARAMETERS;\n        }\n      }\n    }\n    return StaticTypeWarningCode.WRONG_NUMBER_OF_TYPE_ARGUMENTS;\n  }\n\n  /**\n   * Checks if the given [typeName] is the target in a redirected constructor.\n   */\n  RedirectingConstructorKind _getRedirectingConstructorKind(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is ConstructorName) {\n      AstNode grandParent = parent.parent;\n      if (grandParent is ConstructorDeclaration) {\n        if (identical(grandParent.redirectedConstructor, parent)) {\n          if (grandParent.constKeyword != null) {\n            return RedirectingConstructorKind.CONST;\n          }\n          return RedirectingConstructorKind.NORMAL;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the type represented by the given type [annotation].\n   */\n  DartType _getType(TypeAnnotation annotation) {\n    DartType type = annotation.type;\n    if (type == null) {\n      return undefinedType;\n    }\n    return type;\n  }\n\n  /**\n   * Returns the simple identifier of the given (may be qualified) type name.\n   *\n   * @param typeName the (may be qualified) qualified type name\n   * @return the simple identifier of the given (may be qualified) type name.\n   */\n  SimpleIdentifier _getTypeSimpleIdentifier(Identifier typeName) {\n    if (typeName is SimpleIdentifier) {\n      return typeName;\n    } else {\n      PrefixedIdentifier prefixed = typeName;\n      SimpleIdentifier prefix = prefixed.prefix;\n      // The prefixed identifier can be:\n      // 1. new importPrefix.TypeName()\n      // 2. new TypeName.constructorName()\n      // 3. new unresolved.Unresolved()\n      if (prefix.staticElement is PrefixElement) {\n        return prefixed.identifier;\n      } else {\n        return prefix;\n      }\n    }\n  }\n\n  /**\n   * Given the multiple elements to which a single name could potentially be resolved, return the\n   * single interface type that should be used, or `null` if there is no clear choice.\n   *\n   * @param elements the elements to which a single name could potentially be resolved\n   * @return the single interface type that should be used for the type name\n   */\n  InterfaceType _getTypeWhenMultiplyDefined(List<Element> elements) {\n    InterfaceType type = null;\n    int length = elements.length;\n    for (int i = 0; i < length; i++) {\n      Element element = elements[i];\n      if (element is ClassElement) {\n        if (type != null) {\n          return null;\n        }\n        type = element.type;\n      }\n    }\n    return type;\n  }\n\n  /**\n   * If the [node] is the type name in a redirected factory constructor,\n   * infer type arguments using the enclosing class declaration. Return `null`\n   * otherwise.\n   */\n  DartType _inferTypeArgumentsForRedirectedConstructor(\n      TypeName node, DartType type) {\n    AstNode constructorName = node.parent;\n    AstNode enclosingConstructor = constructorName?.parent;\n    TypeSystem ts = typeSystem;\n    if (constructorName is ConstructorName &&\n        enclosingConstructor is ConstructorDeclaration &&\n        enclosingConstructor.redirectedConstructor == constructorName &&\n        type is InterfaceType &&\n        ts is StrongTypeSystemImpl) {\n      ClassDeclaration enclosingClassNode = enclosingConstructor.parent;\n      ClassElement enclosingClassElement = enclosingClassNode.element;\n      if (enclosingClassElement == type.element) {\n        return type;\n      } else {\n        InterfaceType contextType = enclosingClassElement.type;\n        return ts.inferGenericFunctionOrType(\n            type, const <ParameterElement>[], const <DartType>[], contextType);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if the given [typeName] is used as the type in an as expression.\n   */\n  bool _isTypeNameInAsExpression(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is AsExpression) {\n      return identical(parent.type, typeName);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given [typeName] is used as the exception type in a catch\n   * clause.\n   */\n  bool _isTypeNameInCatchClause(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is CatchClause) {\n      return identical(parent.exceptionType, typeName);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given [typeName] is used as the type in an instance creation\n   * expression.\n   */\n  bool _isTypeNameInInstanceCreationExpression(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is ConstructorName &&\n        parent.parent is InstanceCreationExpression) {\n      return parent != null && identical(parent.type, typeName);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given [typeName] is used as the type in an is expression.\n   */\n  bool _isTypeNameInIsExpression(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is IsExpression) {\n      return identical(parent.type, typeName);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given [typeName] used in a type argument list.\n   */\n  bool _isTypeNameInTypeArgumentList(TypeName typeName) =>\n      typeName.parent is TypeArgumentList;\n\n  /**\n   * Records the new Element for a TypeName's Identifier.\n   *\n   * A null may be passed in to indicate that the element can't be resolved.\n   * (During a re-run of a task, it's important to clear any previous value\n   * of the element.)\n   */\n  void _setElement(Identifier typeName, Element element) {\n    if (typeName is SimpleIdentifier) {\n      typeName.staticElement = element;\n    } else if (typeName is PrefixedIdentifier) {\n      typeName.identifier.staticElement = element;\n      SimpleIdentifier prefix = typeName.prefix;\n      prefix.staticElement = nameScope.lookup(prefix, definingLibrary);\n    }\n  }\n\n  /**\n   * Return `true` if the name of the given [typeName] is an built-in identifier.\n   */\n  static bool _isBuiltInIdentifier(TypeName typeName) {\n    Token token = typeName.name.beginToken;\n    return token.type.isKeyword;\n  }\n\n  /**\n   * @return `true` if given [typeName] is used as a type annotation.\n   */\n  static bool _isTypeAnnotation(TypeName typeName) {\n    AstNode parent = typeName.parent;\n    if (parent is VariableDeclarationList) {\n      return identical(parent.type, typeName);\n    } else if (parent is FieldFormalParameter) {\n      return identical(parent.type, typeName);\n    } else if (parent is SimpleFormalParameter) {\n      return identical(parent.type, typeName);\n    }\n    return false;\n  }\n}\n\n/**\n * Instances of the class `TypeOverrideManager` manage the ability to override the type of an\n * element within a given context.\n */\nclass TypeOverrideManager {\n  /**\n   * The current override scope, or `null` if no scope has been entered.\n   */\n  TypeOverrideManager_TypeOverrideScope currentScope;\n\n  /**\n   * Apply a set of overrides that were previously captured.\n   *\n   * @param overrides the overrides to be applied\n   */\n  void applyOverrides(Map<VariableElement, DartType> overrides) {\n    if (currentScope == null) {\n      throw new StateError(\"Cannot apply overrides without a scope\");\n    }\n    currentScope.applyOverrides(overrides);\n  }\n\n  /**\n   * Return a table mapping the elements whose type is overridden in the current scope to the\n   * overriding type.\n   *\n   * @return the overrides in the current scope\n   */\n  Map<VariableElement, DartType> captureLocalOverrides() {\n    if (currentScope == null) {\n      throw new StateError(\"Cannot capture local overrides without a scope\");\n    }\n    return currentScope.captureLocalOverrides();\n  }\n\n  /**\n   * Return a map from the elements for the variables in the given list that have their types\n   * overridden to the overriding type.\n   *\n   * @param variableList the list of variables whose overriding types are to be captured\n   * @return a table mapping elements to their overriding types\n   */\n  Map<VariableElement, DartType> captureOverrides(\n      VariableDeclarationList variableList) {\n    if (currentScope == null) {\n      throw new StateError(\"Cannot capture overrides without a scope\");\n    }\n    return currentScope.captureOverrides(variableList);\n  }\n\n  /**\n   * Enter a new override scope.\n   */\n  void enterScope() {\n    currentScope = new TypeOverrideManager_TypeOverrideScope(currentScope);\n  }\n\n  /**\n   * Exit the current override scope.\n   */\n  void exitScope() {\n    if (currentScope == null) {\n      throw new StateError(\"No scope to exit\");\n    }\n    currentScope = currentScope._outerScope;\n  }\n\n  /**\n   * Return the best type information available for the given element. If the type of the element\n   * has been overridden, then return the overriding type. Otherwise, return the static type.\n   *\n   * @param element the element for which type information is to be returned\n   * @return the best type information available for the given element\n   */\n  DartType getBestType(VariableElement element) {\n    DartType bestType = getType(element);\n    return bestType ?? element.type;\n  }\n\n  /**\n   * Return the overridden type of the given element, or `null` if the type of the element has\n   * not been overridden.\n   *\n   * @param element the element whose type might have been overridden\n   * @return the overridden type of the given element\n   */\n  DartType getType(Element element) {\n    if (currentScope == null) {\n      return null;\n    }\n    return currentScope.getType(element);\n  }\n\n  /**\n   * Update overrides assuming [perBranchOverrides] is the collection of\n   * per-branch overrides for *all* branches flowing into a join point.\n   *\n   * If a variable type in any of branches is not the same as its type before\n   * the branching, then its propagated type is reset to `null`.\n   */\n  void mergeOverrides(List<Map<VariableElement, DartType>> perBranchOverrides) {\n    int length = perBranchOverrides.length;\n    for (int i = 0; i < length; i++) {\n      Map<VariableElement, DartType> branch = perBranchOverrides[i];\n      branch.forEach((VariableElement variable, DartType branchType) {\n        DartType currentType = currentScope.getType(variable);\n        if (currentType != branchType) {\n          currentScope.resetType(variable);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set the overridden type of the given element to the given type\n   *\n   * @param element the element whose type might have been overridden\n   * @param type the overridden type of the given element\n   */\n  void setType(VariableElement element, DartType type) {\n    if (currentScope == null) {\n      throw new StateError(\"Cannot override without a scope\");\n    }\n    currentScope.setType(element, type);\n  }\n}\n\n/**\n * Instances of the class `TypeOverrideScope` represent a scope in which the types of\n * elements can be overridden.\n */\nclass TypeOverrideManager_TypeOverrideScope {\n  /**\n   * The outer scope in which types might be overridden.\n   */\n  final TypeOverrideManager_TypeOverrideScope _outerScope;\n\n  /**\n   * A table mapping elements to the overridden type of that element.\n   */\n  Map<VariableElement, DartType> _overriddenTypes =\n      new HashMap<VariableElement, DartType>();\n\n  /**\n   * Initialize a newly created scope to be an empty child of the given scope.\n   *\n   * @param outerScope the outer scope in which types might be overridden\n   */\n  TypeOverrideManager_TypeOverrideScope(this._outerScope);\n\n  /**\n   * Apply a set of overrides that were previously captured.\n   *\n   * @param overrides the overrides to be applied\n   */\n  void applyOverrides(Map<VariableElement, DartType> overrides) {\n    _overriddenTypes.addAll(overrides);\n  }\n\n  /**\n   * Return a table mapping the elements whose type is overridden in the current scope to the\n   * overriding type.\n   *\n   * @return the overrides in the current scope\n   */\n  Map<VariableElement, DartType> captureLocalOverrides() => _overriddenTypes;\n\n  /**\n   * Return a map from the elements for the variables in the given list that have their types\n   * overridden to the overriding type.\n   *\n   * @param variableList the list of variables whose overriding types are to be captured\n   * @return a table mapping elements to their overriding types\n   */\n  Map<VariableElement, DartType> captureOverrides(\n      VariableDeclarationList variableList) {\n    Map<VariableElement, DartType> overrides =\n        new HashMap<VariableElement, DartType>();\n    if (variableList.isConst || variableList.isFinal) {\n      for (VariableDeclaration variable in variableList.variables) {\n        VariableElement element = variable.element;\n        if (element != null) {\n          DartType type = _overriddenTypes[element];\n          if (type != null) {\n            overrides[element] = type;\n          }\n        }\n      }\n    }\n    return overrides;\n  }\n\n  /**\n   * Return the overridden type of the given element, or `null` if the type of the element\n   * has not been overridden.\n   *\n   * @param element the element whose type might have been overridden\n   * @return the overridden type of the given element\n   */\n  DartType getType(Element element) {\n    Element nonAccessor =\n        element is PropertyAccessorElement ? element.variable : element;\n    DartType type = _overriddenTypes[nonAccessor];\n    if (_overriddenTypes.containsKey(nonAccessor)) {\n      return type;\n    }\n    return type ?? _outerScope?.getType(element);\n  }\n\n  /**\n   * Clears the overridden type of the given [element].\n   */\n  void resetType(VariableElement element) {\n    _overriddenTypes[element] = null;\n  }\n\n  /**\n   * Set the overridden type of the given element to the given type\n   *\n   * @param element the element whose type might have been overridden\n   * @param type the overridden type of the given element\n   */\n  void setType(VariableElement element, DartType type) {\n    _overriddenTypes[element] = type;\n  }\n}\n\n/**\n * This class resolves bounds of type parameters of classes, class and function\n * type aliases.\n */\nclass TypeParameterBoundsResolver {\n  final TypeSystem typeSystem;\n  final LibraryElement library;\n  final Source source;\n  final AnalysisErrorListener errorListener;\n\n  Scope libraryScope = null;\n  TypeNameResolver typeNameResolver = null;\n\n  TypeParameterBoundsResolver(\n      this.typeSystem, this.library, this.source, this.errorListener)\n      : libraryScope = new LibraryScope(library),\n        typeNameResolver = new TypeNameResolver(typeSystem,\n            typeSystem.typeProvider, library, source, errorListener);\n\n  /**\n   * Resolve bounds of type parameters of classes, class and function type\n   * aliases.\n   */\n  void resolveTypeBounds(CompilationUnit unit) {\n    for (CompilationUnitMember unitMember in unit.declarations) {\n      if (unitMember is ClassDeclaration) {\n        _resolveTypeParameters(unitMember.typeParameters,\n            () => new TypeParameterScope(libraryScope, unitMember.element));\n      } else if (unitMember is ClassTypeAlias) {\n        _resolveTypeParameters(unitMember.typeParameters,\n            () => new TypeParameterScope(libraryScope, unitMember.element));\n      } else if (unitMember is FunctionTypeAlias) {\n        _resolveTypeParameters(unitMember.typeParameters,\n            () => new FunctionTypeScope(libraryScope, unitMember.element));\n      }\n    }\n  }\n\n  void _resolveTypeName(TypeAnnotation type) {\n    if (type is TypeName) {\n      type.typeArguments?.arguments?.forEach(_resolveTypeName);\n      typeNameResolver.resolveTypeName(type);\n      // TODO(scheglov) report error when don't apply type bounds for type bounds\n    } else if (type is GenericFunctionType) {\n      // While GenericFunctionTypes with free types are not allowed as bounds,\n      // those free types *should* ideally be recognized as type parameter types\n      // rather than classnames. Create a scope to accomplish that.\n      Scope previousScope = typeNameResolver.nameScope;\n\n      try {\n        Scope typeParametersScope = new TypeParameterScope(\n            typeNameResolver.nameScope, type.type.element);\n        typeNameResolver.nameScope = typeParametersScope;\n\n        void resolveTypeParameter(TypeParameter t) {\n          _resolveTypeName(t.bound);\n        }\n\n        void resolveParameter(FormalParameter p) {\n          if (p is SimpleFormalParameter) {\n            _resolveTypeName(p.type);\n          } else if (p is DefaultFormalParameter) {\n            resolveParameter(p.parameter);\n          } else if (p is FieldFormalParameter) {\n            _resolveTypeName(p.type);\n          } else if (p is FunctionTypedFormalParameter) {\n            _resolveTypeName(p.returnType);\n            p.typeParameters?.typeParameters?.forEach(resolveTypeParameter);\n            p.parameters?.parameters?.forEach(resolveParameter);\n          }\n        }\n\n        _resolveTypeName(type.returnType);\n        type.typeParameters?.typeParameters?.forEach(resolveTypeParameter);\n        type.parameters?.parameters?.forEach(resolveParameter);\n      } finally {\n        typeNameResolver.nameScope = previousScope;\n      }\n    }\n  }\n\n  void _resolveTypeParameters(\n      TypeParameterList typeParameters, Scope createTypeParametersScope()) {\n    if (typeParameters != null) {\n      Scope typeParametersScope = null;\n      for (TypeParameter typeParameter in typeParameters.typeParameters) {\n        TypeAnnotation bound = typeParameter.bound;\n        if (bound != null) {\n          Element typeParameterElement = typeParameter.name.staticElement;\n          if (typeParameterElement is TypeParameterElementImpl) {\n            if (LibraryElementImpl.hasResolutionCapability(\n                library, LibraryResolutionCapability.resolvedTypeNames)) {\n              if (bound is TypeName) {\n                bound.type = typeParameterElement.bound;\n              } else if (bound is GenericFunctionTypeImpl) {\n                bound.type = typeParameterElement.bound;\n              }\n            } else {\n              typeParametersScope ??= createTypeParametersScope();\n              // _resolveTypeParameters is the entry point into each declaration\n              // with a separate scope. We can safely, and should, clobber the\n              // old scope here.\n              typeNameResolver.nameScope = typeParametersScope;\n              _resolveTypeName(bound);\n              typeParameterElement.bound = bound.type;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Instances of the class `TypePromotionManager` manage the ability to promote types of local\n * variables and formal parameters from their declared types based on control flow.\n */\nclass TypePromotionManager {\n  /**\n   * The current promotion scope, or `null` if no scope has been entered.\n   */\n  TypePromotionManager_TypePromoteScope currentScope;\n\n  /**\n   * Returns the elements with promoted types.\n   */\n  Iterable<Element> get promotedElements => currentScope.promotedElements;\n\n  /**\n   * Enter a new promotions scope.\n   */\n  void enterScope() {\n    currentScope = new TypePromotionManager_TypePromoteScope(currentScope);\n  }\n\n  /**\n   * Exit the current promotion scope.\n   */\n  void exitScope() {\n    if (currentScope == null) {\n      throw new StateError(\"No scope to exit\");\n    }\n    currentScope = currentScope._outerScope;\n  }\n\n  /**\n   * Return the static type of the given [variable] - declared or promoted.\n   */\n  DartType getStaticType(VariableElement variable) =>\n      getType(variable) ?? variable.type;\n\n  /**\n   * Return the promoted type of the given [element], or `null` if the type of\n   * the element has not been promoted.\n   */\n  DartType getType(Element element) => currentScope?.getType(element);\n\n  /**\n   * Set the promoted type of the given element to the given type.\n   *\n   * @param element the element whose type might have been promoted\n   * @param type the promoted type of the given element\n   */\n  void setType(Element element, DartType type) {\n    if (currentScope == null) {\n      throw new StateError(\"Cannot promote without a scope\");\n    }\n    currentScope.setType(element, type);\n  }\n}\n\n/**\n * Instances of the class `TypePromoteScope` represent a scope in which the types of\n * elements can be promoted.\n */\nclass TypePromotionManager_TypePromoteScope {\n  /**\n   * The outer scope in which types might be promoter.\n   */\n  final TypePromotionManager_TypePromoteScope _outerScope;\n\n  /**\n   * A table mapping elements to the promoted type of that element.\n   */\n  Map<Element, DartType> _promotedTypes = new HashMap<Element, DartType>();\n\n  /**\n   * Initialize a newly created scope to be an empty child of the given scope.\n   *\n   * @param outerScope the outer scope in which types might be promoted\n   */\n  TypePromotionManager_TypePromoteScope(this._outerScope);\n\n  /**\n   * Returns the elements with promoted types.\n   */\n  Iterable<Element> get promotedElements => _promotedTypes.keys.toSet();\n\n  /**\n   * Return the promoted type of the given element, or `null` if the type of the element has\n   * not been promoted.\n   *\n   * @param element the element whose type might have been promoted\n   * @return the promoted type of the given element\n   */\n  DartType getType(Element element) {\n    DartType type = _promotedTypes[element];\n    if (type == null && element is PropertyAccessorElement) {\n      type = _promotedTypes[element.variable];\n    }\n    if (type != null) {\n      return type;\n    } else if (_outerScope != null) {\n      return _outerScope.getType(element);\n    }\n    return null;\n  }\n\n  /**\n   * Set the promoted type of the given element to the given type.\n   *\n   * @param element the element whose type might have been promoted\n   * @param type the promoted type of the given element\n   */\n  void setType(Element element, DartType type) {\n    _promotedTypes[element] = type;\n  }\n}\n\n/**\n * The interface `TypeProvider` defines the behavior of objects that provide access to types\n * defined by the language.\n */\nabstract class TypeProvider {\n  /**\n   * Return the type representing the built-in type 'bool'.\n   */\n  InterfaceType get boolType;\n\n  /**\n   * Return the type representing the type 'bottom'.\n   */\n  DartType get bottomType;\n\n  /**\n   * Return the type representing the built-in type 'Deprecated'.\n   */\n  InterfaceType get deprecatedType;\n\n  /**\n   * Return the type representing the built-in type 'double'.\n   */\n  InterfaceType get doubleType;\n\n  /**\n   * Return the type representing the built-in type 'dynamic'.\n   */\n  DartType get dynamicType;\n\n  /**\n   * Return the type representing the built-in type 'Function'.\n   */\n  InterfaceType get functionType;\n\n  /**\n   * Return the type representing 'Future<dynamic>'.\n   */\n  InterfaceType get futureDynamicType;\n\n  /**\n   * Return the type representing 'Future<Null>'.\n   */\n  InterfaceType get futureNullType;\n\n  /**\n   * Return the type representing 'FutureOr<Null>'.\n   */\n  InterfaceType get futureOrNullType;\n\n  /**\n   * Return the type representing the built-in type 'FutureOr'.\n   */\n  InterfaceType get futureOrType;\n\n  /**\n   * Return the type representing the built-in type 'Future'.\n   */\n  InterfaceType get futureType;\n\n  /**\n   * Return the type representing the built-in type 'int'.\n   */\n  InterfaceType get intType;\n\n  /**\n   * Return the type representing the type 'Iterable<dynamic>'.\n   */\n  InterfaceType get iterableDynamicType;\n\n  /**\n   * Return the type representing the built-in type 'Iterable'.\n   */\n  InterfaceType get iterableType;\n\n  /**\n   * Return the type representing the built-in type 'List'.\n   */\n  InterfaceType get listType;\n\n  /**\n   * Return the type representing the built-in type 'Map'.\n   */\n  InterfaceType get mapType;\n\n  /**\n   * Return a list containing all of the types that cannot be either extended or\n   * implemented.\n   */\n  List<InterfaceType> get nonSubtypableTypes;\n\n  /**\n   * Return a [DartObjectImpl] representing the `null` object.\n   */\n  DartObjectImpl get nullObject;\n\n  /**\n   * Return the type representing the built-in type 'Null'.\n   */\n  InterfaceType get nullType;\n\n  /**\n   * Return the type representing the built-in type 'num'.\n   */\n  InterfaceType get numType;\n\n  /**\n   * Return the type representing the built-in type 'Object'.\n   */\n  InterfaceType get objectType;\n\n  /**\n   * Return the type representing the built-in type 'StackTrace'.\n   */\n  InterfaceType get stackTraceType;\n\n  /**\n   * Return the type representing 'Stream<dynamic>'.\n   */\n  InterfaceType get streamDynamicType;\n\n  /**\n   * Return the type representing the built-in type 'Stream'.\n   */\n  InterfaceType get streamType;\n\n  /**\n   * Return the type representing the built-in type 'String'.\n   */\n  InterfaceType get stringType;\n\n  /**\n   * Return the type representing the built-in type 'Symbol'.\n   */\n  InterfaceType get symbolType;\n\n  /**\n   * Return the type representing the built-in type 'Type'.\n   */\n  InterfaceType get typeType;\n\n  /**\n   * Return the type representing typenames that can't be resolved.\n   */\n  DartType get undefinedType;\n\n  /**\n   * Return 'true' if [id] is the name of a getter on\n   * the Object type.\n   */\n  bool isObjectGetter(String id);\n\n  /**\n   * Return 'true' if [id] is the name of a method or getter on\n   * the Object type.\n   */\n  bool isObjectMember(String id);\n\n  /**\n   * Return 'true' if [id] is the name of a method on\n   * the Object type.\n   */\n  bool isObjectMethod(String id);\n}\n\n/**\n * Provide common functionality shared by the various TypeProvider\n * implementations.\n */\nabstract class TypeProviderBase implements TypeProvider {\n  @override\n  List<InterfaceType> get nonSubtypableTypes => <InterfaceType>[\n        nullType,\n        numType,\n        intType,\n        doubleType,\n        boolType,\n        stringType\n      ];\n\n  @override\n  bool isObjectGetter(String id) {\n    PropertyAccessorElement element = objectType.element.getGetter(id);\n    return (element != null && !element.isStatic);\n  }\n\n  @override\n  bool isObjectMember(String id) {\n    return isObjectGetter(id) || isObjectMethod(id);\n  }\n\n  @override\n  bool isObjectMethod(String id) {\n    MethodElement element = objectType.element.getMethod(id);\n    return (element != null && !element.isStatic);\n  }\n}\n\n/**\n * Instances of the class `TypeProviderImpl` provide access to types defined by the language\n * by looking for those types in the element model for the core library.\n */\nclass TypeProviderImpl extends TypeProviderBase {\n  /**\n   * The type representing the built-in type 'bool'.\n   */\n  InterfaceType _boolType;\n\n  /**\n   * The type representing the type 'bottom'.\n   */\n  DartType _bottomType;\n\n  /**\n   * The type representing the built-in type 'double'.\n   */\n  InterfaceType _doubleType;\n\n  /**\n   * The type representing the built-in type 'Deprecated'.\n   */\n  InterfaceType _deprecatedType;\n\n  /**\n   * The type representing the built-in type 'dynamic'.\n   */\n  DartType _dynamicType;\n\n  /**\n   * The type representing the built-in type 'Function'.\n   */\n  InterfaceType _functionType;\n\n  /**\n   * The type representing 'Future<dynamic>'.\n   */\n  InterfaceType _futureDynamicType;\n\n  /**\n   * The type representing 'Future<Null>'.\n   */\n  InterfaceType _futureNullType;\n\n  /**\n   * The type representing 'FutureOr<Null>'.\n   */\n  InterfaceType _futureOrNullType;\n\n  /**\n   * The type representing the built-in type 'FutureOr'.\n   */\n  InterfaceType _futureOrType;\n\n  /**\n   * The type representing the built-in type 'Future'.\n   */\n  InterfaceType _futureType;\n\n  /**\n   * The type representing the built-in type 'int'.\n   */\n  InterfaceType _intType;\n\n  /**\n   * The type representing 'Iterable<dynamic>'.\n   */\n  InterfaceType _iterableDynamicType;\n\n  /**\n   * The type representing the built-in type 'Iterable'.\n   */\n  InterfaceType _iterableType;\n\n  /**\n   * The type representing the built-in type 'List'.\n   */\n  InterfaceType _listType;\n\n  /**\n   * The type representing the built-in type 'Map'.\n   */\n  InterfaceType _mapType;\n\n  /**\n   * An shared object representing the value 'null'.\n   */\n  DartObjectImpl _nullObject;\n\n  /**\n   * The type representing the type 'Null'.\n   */\n  InterfaceType _nullType;\n\n  /**\n   * The type representing the built-in type 'num'.\n   */\n  InterfaceType _numType;\n\n  /**\n   * The type representing the built-in type 'Object'.\n   */\n  InterfaceType _objectType;\n\n  /**\n   * The type representing the built-in type 'StackTrace'.\n   */\n  InterfaceType _stackTraceType;\n\n  /**\n   * The type representing 'Stream<dynamic>'.\n   */\n  InterfaceType _streamDynamicType;\n\n  /**\n   * The type representing the built-in type 'Stream'.\n   */\n  InterfaceType _streamType;\n\n  /**\n   * The type representing the built-in type 'String'.\n   */\n  InterfaceType _stringType;\n\n  /**\n   * The type representing the built-in type 'Symbol'.\n   */\n  InterfaceType _symbolType;\n\n  /**\n   * The type representing the built-in type 'Type'.\n   */\n  InterfaceType _typeType;\n\n  /**\n   * The type representing typenames that can't be resolved.\n   */\n  DartType _undefinedType;\n\n  /**\n   * Initialize a newly created type provider to provide the types defined in\n   * the given [coreLibrary] and [asyncLibrary].\n   */\n  TypeProviderImpl(LibraryElement coreLibrary, LibraryElement asyncLibrary) {\n    Namespace coreNamespace =\n        new NamespaceBuilder().createPublicNamespaceForLibrary(coreLibrary);\n    Namespace asyncNamespace =\n        new NamespaceBuilder().createPublicNamespaceForLibrary(asyncLibrary);\n    _initializeFrom(coreNamespace, asyncNamespace);\n  }\n\n  /**\n   * Initialize a newly created type provider to provide the types defined in\n   * the given [Namespace]s.\n   */\n  TypeProviderImpl.forNamespaces(\n      Namespace coreNamespace, Namespace asyncNamespace) {\n    _initializeFrom(coreNamespace, asyncNamespace);\n  }\n\n  @override\n  InterfaceType get boolType => _boolType;\n\n  @override\n  DartType get bottomType => _bottomType;\n\n  @override\n  InterfaceType get deprecatedType => _deprecatedType;\n\n  @override\n  InterfaceType get doubleType => _doubleType;\n\n  @override\n  DartType get dynamicType => _dynamicType;\n\n  @override\n  InterfaceType get functionType => _functionType;\n\n  @override\n  InterfaceType get futureDynamicType => _futureDynamicType;\n\n  @override\n  InterfaceType get futureNullType => _futureNullType;\n\n  @override\n  InterfaceType get futureOrNullType => _futureOrNullType;\n\n  @override\n  InterfaceType get futureOrType => _futureOrType;\n\n  @override\n  InterfaceType get futureType => _futureType;\n\n  @override\n  InterfaceType get intType => _intType;\n\n  @override\n  InterfaceType get iterableDynamicType => _iterableDynamicType;\n\n  @override\n  InterfaceType get iterableType => _iterableType;\n\n  @override\n  InterfaceType get listType => _listType;\n\n  @override\n  InterfaceType get mapType => _mapType;\n\n  @override\n  DartObjectImpl get nullObject {\n    if (_nullObject == null) {\n      _nullObject = new DartObjectImpl(nullType, NullState.NULL_STATE);\n    }\n    return _nullObject;\n  }\n\n  @override\n  InterfaceType get nullType => _nullType;\n\n  @override\n  InterfaceType get numType => _numType;\n\n  @override\n  InterfaceType get objectType => _objectType;\n\n  @override\n  InterfaceType get stackTraceType => _stackTraceType;\n\n  @override\n  InterfaceType get streamDynamicType => _streamDynamicType;\n\n  @override\n  InterfaceType get streamType => _streamType;\n\n  @override\n  InterfaceType get stringType => _stringType;\n\n  @override\n  InterfaceType get symbolType => _symbolType;\n\n  @override\n  InterfaceType get typeType => _typeType;\n\n  @override\n  DartType get undefinedType => _undefinedType;\n\n  /**\n   * Return the type with the given name from the given namespace, or `null` if there is no\n   * class with the given name.\n   *\n   * @param namespace the namespace in which to search for the given name\n   * @param typeName the name of the type being searched for\n   * @return the type that was found\n   */\n  InterfaceType _getType(Namespace namespace, String typeName) {\n    Element element = namespace.get(typeName);\n    if (element == null) {\n      AnalysisEngine.instance.logger\n          .logInformation(\"No definition of type $typeName\");\n      return null;\n    }\n    return (element as ClassElement).type;\n  }\n\n  /**\n   * Initialize the types provided by this type provider from the given\n   * [Namespace]s.\n   */\n  void _initializeFrom(Namespace coreNamespace, Namespace asyncNamespace) {\n    _boolType = _getType(coreNamespace, \"bool\");\n    _bottomType = BottomTypeImpl.instance;\n    _deprecatedType = _getType(coreNamespace, \"Deprecated\");\n    _doubleType = _getType(coreNamespace, \"double\");\n    _dynamicType = DynamicTypeImpl.instance;\n    _functionType = _getType(coreNamespace, \"Function\");\n    _futureOrType = _getType(asyncNamespace, \"FutureOr\");\n    _futureType = _getType(asyncNamespace, \"Future\");\n    _intType = _getType(coreNamespace, \"int\");\n    _iterableType = _getType(coreNamespace, \"Iterable\");\n    _listType = _getType(coreNamespace, \"List\");\n    _mapType = _getType(coreNamespace, \"Map\");\n    _nullType = _getType(coreNamespace, \"Null\");\n    _numType = _getType(coreNamespace, \"num\");\n    _objectType = _getType(coreNamespace, \"Object\");\n    _stackTraceType = _getType(coreNamespace, \"StackTrace\");\n    _streamType = _getType(asyncNamespace, \"Stream\");\n    _stringType = _getType(coreNamespace, \"String\");\n    _symbolType = _getType(coreNamespace, \"Symbol\");\n    _typeType = _getType(coreNamespace, \"Type\");\n    _undefinedType = UndefinedTypeImpl.instance;\n    _futureDynamicType = _futureType.instantiate(<DartType>[_dynamicType]);\n    _futureNullType = _futureType.instantiate(<DartType>[_nullType]);\n    _iterableDynamicType = _iterableType.instantiate(<DartType>[_dynamicType]);\n    _streamDynamicType = _streamType.instantiate(<DartType>[_dynamicType]);\n    // FutureOr<T> is still fairly new, so if we're analyzing an SDK that\n    // doesn't have it yet, create an element for it.\n    _futureOrType ??= createPlaceholderFutureOr(_futureType, _objectType);\n    _futureOrNullType = _futureOrType.instantiate(<DartType>[_nullType]);\n  }\n\n  /**\n   * Create an [InterfaceType] that can be used for `FutureOr<T>` if the SDK\n   * being analyzed does not contain its own `FutureOr<T>`.  This ensures that\n   * we can analyze older SDKs.\n   */\n  static InterfaceType createPlaceholderFutureOr(\n      InterfaceType futureType, InterfaceType objectType) {\n    var compilationUnit =\n        futureType.element.getAncestor((e) => e is CompilationUnitElement);\n    var element = ElementFactory.classElement('FutureOr', objectType, ['T']);\n    element.enclosingElement = compilationUnit;\n    return element.type;\n  }\n}\n\n/**\n * Modes in which [TypeResolverVisitor] works.\n */\nenum TypeResolverMode {\n  /**\n   * Resolve all names types of all nodes.\n   */\n  everything,\n\n  /**\n   * Resolve only type names outside of function bodies, variable initializers,\n   * and parameter default values.\n   */\n  api,\n\n  /**\n   * Resolve only type names that would be skipped during [api].\n   *\n   * Resolution must start from a unit member or a class member. For example\n   * it is not allowed to resolve types in a separate statement, or a function\n   * body.\n   */\n  local\n}\n\n/**\n * Instances of the class `TypeResolverVisitor` are used to resolve the types associated with\n * the elements in the element model. This includes the types of superclasses, mixins, interfaces,\n * fields, methods, parameters, and local variables. As a side-effect, this also finishes building\n * the type hierarchy.\n */\nclass TypeResolverVisitor extends ScopedVisitor {\n  /**\n   * The type representing the type 'dynamic'.\n   */\n  DartType _dynamicType;\n\n  /**\n   * The type representing typenames that can't be resolved.\n   */\n  DartType _undefinedType;\n\n  /**\n   * The flag specifying if currently visited class references 'super' expression.\n   */\n  bool _hasReferenceToSuper = false;\n\n  /**\n   * True if we're analyzing in strong mode.\n   */\n  bool _strongMode;\n\n  /**\n   * Type type system in use for this resolver pass.\n   */\n  TypeSystem _typeSystem;\n\n  /**\n   * The helper to resolve types.\n   */\n  TypeNameResolver _typeNameResolver;\n\n  final TypeResolverMode mode;\n\n  /**\n   * Is `true` when we are visiting all nodes in [TypeResolverMode.local] mode.\n   */\n  bool _localModeVisitAll = false;\n\n  /**\n   * Is `true` if we are in [TypeResolverMode.local] mode, and the initial\n   * [nameScope] was computed.\n   */\n  bool _localModeScopeReady = false;\n\n  /**\n   * Initialize a newly created visitor to resolve the nodes in an AST node.\n   *\n   * [definingLibrary] is the element for the library containing the node being\n   * visited.\n   * [source] is the source representing the compilation unit containing the\n   * node being visited.\n   * [typeProvider] is the object used to access the types from the core\n   * library.\n   * [errorListener] is the error listener that will be informed of any errors\n   * that are found during resolution.\n   * [nameScope] is the scope used to resolve identifiers in the node that will\n   * first be visited.  If `null` or unspecified, a new [LibraryScope] will be\n   * created based on [definingLibrary] and [typeProvider].\n   */\n  TypeResolverVisitor(LibraryElement definingLibrary, Source source,\n      TypeProvider typeProvider, AnalysisErrorListener errorListener,\n      {Scope nameScope, this.mode: TypeResolverMode.everything})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope) {\n    _dynamicType = typeProvider.dynamicType;\n    _undefinedType = typeProvider.undefinedType;\n    _strongMode = definingLibrary.context.analysisOptions.strongMode;\n    _typeSystem = TypeSystem.create(definingLibrary.context);\n    _typeNameResolver = new TypeNameResolver(\n        _typeSystem, typeProvider, definingLibrary, source, errorListener);\n  }\n\n  @override\n  Object visitAnnotation(Annotation node) {\n    //\n    // Visit annotations, if the annotation is @proxy, on a class, and \"proxy\"\n    // resolves to the proxy annotation in dart.core, then resolve the\n    // ElementAnnotation.\n    //\n    // Element resolution is done in the ElementResolver, and this work will be\n    // done in the general case for all annotations in the ElementResolver.\n    // The reason we resolve this particular element early is so that\n    // ClassElement.isProxy() returns the correct information during all\n    // phases of the ElementResolver.\n    //\n    super.visitAnnotation(node);\n    Identifier identifier = node.name;\n    if (identifier.name.endsWith(ElementAnnotationImpl.PROXY_VARIABLE_NAME) &&\n        node.parent is ClassDeclaration) {\n      Element element = nameScope.lookup(identifier, definingLibrary);\n      if (element != null &&\n          element.library.isDartCore &&\n          element is PropertyAccessorElement) {\n        // This is the @proxy from dart.core\n        ElementAnnotationImpl elementAnnotation = node.elementAnnotation;\n        elementAnnotation.element = element;\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitCatchClause(CatchClause node) {\n    super.visitCatchClause(node);\n    SimpleIdentifier exception = node.exceptionParameter;\n    if (exception != null) {\n      // If an 'on' clause is provided the type of the exception parameter is\n      // the type in the 'on' clause. Otherwise, the type of the exception\n      // parameter is 'Object'.\n      TypeAnnotation exceptionTypeName = node.exceptionType;\n      DartType exceptionType;\n      if (exceptionTypeName == null) {\n        exceptionType = typeProvider.dynamicType;\n      } else {\n        exceptionType = _typeNameResolver._getType(exceptionTypeName);\n      }\n      _recordType(exception, exceptionType);\n      Element element = exception.staticElement;\n      if (element is VariableElementImpl) {\n        element.declaredType = exceptionType;\n      } else {\n        // TODO(brianwilkerson) Report the internal error\n      }\n    }\n    SimpleIdentifier stackTrace = node.stackTraceParameter;\n    if (stackTrace != null) {\n      _recordType(stackTrace, typeProvider.stackTraceType);\n      Element element = stackTrace.staticElement;\n      if (element is VariableElementImpl) {\n        element.declaredType = typeProvider.stackTraceType;\n      } else {\n        // TODO(brianwilkerson) Report the internal error\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitClassDeclaration(ClassDeclaration node) {\n    _hasReferenceToSuper = false;\n    super.visitClassDeclaration(node);\n    ClassElementImpl classElement = _getClassElement(node.name);\n    if (classElement != null) {\n      // Clear this flag, as we just invalidated any inferred member types.\n      classElement.hasBeenInferred = false;\n      classElement.hasReferenceToSuper = _hasReferenceToSuper;\n    }\n    return null;\n  }\n\n  @override\n  void visitClassDeclarationInScope(ClassDeclaration node) {\n    super.visitClassDeclarationInScope(node);\n    ExtendsClause extendsClause = node.extendsClause;\n    WithClause withClause = node.withClause;\n    ImplementsClause implementsClause = node.implementsClause;\n    ClassElementImpl classElement = _getClassElement(node.name);\n    InterfaceType superclassType = null;\n    if (extendsClause != null) {\n      ErrorCode errorCode = (withClause == null\n          ? CompileTimeErrorCode.EXTENDS_NON_CLASS\n          : CompileTimeErrorCode.MIXIN_WITH_NON_CLASS_SUPERCLASS);\n      superclassType = _resolveType(extendsClause.superclass, errorCode,\n          CompileTimeErrorCode.EXTENDS_ENUM, errorCode);\n    }\n    if (classElement != null) {\n      if (superclassType == null) {\n        InterfaceType objectType = typeProvider.objectType;\n        if (!identical(classElement.type, objectType)) {\n          superclassType = objectType;\n        }\n      }\n      classElement.supertype = superclassType;\n    }\n    _resolve(classElement, withClause, implementsClause);\n    return null;\n  }\n\n  @override\n  void visitClassMembersInScope(ClassDeclaration node) {\n    node.documentationComment?.accept(this);\n    node.metadata.accept(this);\n    //\n    // Process field declarations before constructors and methods so that the\n    // types of field formal parameters can be correctly resolved.\n    //\n    List<ClassMember> nonFields = new List<ClassMember>();\n    NodeList<ClassMember> members = node.members;\n    int length = members.length;\n    for (int i = 0; i < length; i++) {\n      ClassMember member = members[i];\n      if (member is ConstructorDeclaration) {\n        nonFields.add(member);\n      } else {\n        member.accept(this);\n      }\n    }\n    int count = nonFields.length;\n    for (int i = 0; i < count; i++) {\n      nonFields[i].accept(this);\n    }\n  }\n\n  @override\n  Object visitClassTypeAlias(ClassTypeAlias node) {\n    super.visitClassTypeAlias(node);\n    ErrorCode errorCode = CompileTimeErrorCode.MIXIN_WITH_NON_CLASS_SUPERCLASS;\n    InterfaceType superclassType = _resolveType(node.superclass, errorCode,\n        CompileTimeErrorCode.EXTENDS_ENUM, errorCode);\n    if (superclassType == null) {\n      superclassType = typeProvider.objectType;\n    }\n    ClassElementImpl classElement = _getClassElement(node.name);\n    if (classElement != null) {\n      classElement.supertype = superclassType;\n    }\n    _resolve(classElement, node.withClause, node.implementsClause);\n    return null;\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    super.visitConstructorDeclaration(node);\n    if (node.element == null) {\n      ClassDeclaration classNode =\n          node.getAncestor((node) => node is ClassDeclaration);\n      StringBuffer buffer = new StringBuffer();\n      buffer.write(\"The element for the constructor \");\n      buffer.write(node.name == null ? \"<unnamed>\" : node.name.name);\n      buffer.write(\" in \");\n      if (classNode == null) {\n        buffer.write(\"<unknown class>\");\n      } else {\n        buffer.write(classNode.name.name);\n      }\n      buffer.write(\" in \");\n      buffer.write(source.fullName);\n      buffer.write(\" was not set while trying to resolve types.\");\n      AnalysisEngine.instance.logger.logError(buffer.toString(),\n          new CaughtException(new AnalysisException(), null));\n    }\n    return null;\n  }\n\n  @override\n  Object visitDeclaredIdentifier(DeclaredIdentifier node) {\n    super.visitDeclaredIdentifier(node);\n    DartType declaredType;\n    TypeAnnotation typeName = node.type;\n    if (typeName == null) {\n      declaredType = _dynamicType;\n    } else {\n      declaredType = _typeNameResolver._getType(typeName);\n    }\n    LocalVariableElementImpl element = node.element as LocalVariableElementImpl;\n    element.declaredType = declaredType;\n    return null;\n  }\n\n  @override\n  Object visitFieldFormalParameter(FieldFormalParameter node) {\n    super.visitFieldFormalParameter(node);\n    Element element = node.identifier.staticElement;\n    if (element is ParameterElementImpl) {\n      FormalParameterList parameterList = node.parameters;\n      if (parameterList == null) {\n        DartType type;\n        TypeAnnotation typeName = node.type;\n        if (typeName == null) {\n          element.hasImplicitType = true;\n          if (element is FieldFormalParameterElement) {\n            FieldElement fieldElement =\n                (element as FieldFormalParameterElement).field;\n            type = fieldElement?.type;\n          }\n        } else {\n          type = _typeNameResolver._getType(typeName);\n        }\n        element.declaredType = type ?? _dynamicType;\n      } else {\n        _setFunctionTypedParameterType(element, node.type, node.parameters);\n      }\n    } else {\n      // TODO(brianwilkerson) Report this internal error\n    }\n    return null;\n  }\n\n  @override\n  Object visitFunctionDeclaration(FunctionDeclaration node) {\n    super.visitFunctionDeclaration(node);\n    ExecutableElementImpl element = node.element as ExecutableElementImpl;\n    if (element == null) {\n      StringBuffer buffer = new StringBuffer();\n      buffer.write(\"The element for the top-level function \");\n      buffer.write(node.name);\n      buffer.write(\" in \");\n      buffer.write(source.fullName);\n      buffer.write(\" was not set while trying to resolve types.\");\n      AnalysisEngine.instance.logger.logError(buffer.toString(),\n          new CaughtException(new AnalysisException(), null));\n    }\n    element.declaredReturnType = _computeReturnType(node.returnType);\n    element.type = new FunctionTypeImpl(element);\n    _inferSetterReturnType(element);\n    return null;\n  }\n\n  @override\n  Object visitFunctionTypeAlias(FunctionTypeAlias node) {\n    var element = node.element as GenericTypeAliasElementImpl;\n    super.visitFunctionTypeAlias(node);\n    element.function.returnType = _computeReturnType(node.returnType);\n    return null;\n  }\n\n  @override\n  Object visitFunctionTypedFormalParameter(FunctionTypedFormalParameter node) {\n    super.visitFunctionTypedFormalParameter(node);\n    Element element = node.identifier.staticElement;\n    if (element is ParameterElementImpl) {\n      _setFunctionTypedParameterType(element, node.returnType, node.parameters);\n    } else {\n      // TODO(brianwilkerson) Report this internal error\n    }\n    return null;\n  }\n\n  @override\n  Object visitGenericFunctionType(GenericFunctionType node) {\n    GenericFunctionTypeElementImpl element = node.type?.element;\n    if (element != null) {\n      super.visitGenericFunctionType(node);\n      element.returnType =\n          _computeReturnType(node.returnType) ?? DynamicTypeImpl.instance;\n    }\n    return null;\n  }\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    super.visitMethodDeclaration(node);\n    ExecutableElementImpl element = node.element as ExecutableElementImpl;\n    if (element == null) {\n      ClassDeclaration classNode =\n          node.getAncestor((node) => node is ClassDeclaration);\n      StringBuffer buffer = new StringBuffer();\n      buffer.write(\"The element for the method \");\n      buffer.write(node.name.name);\n      buffer.write(\" in \");\n      if (classNode == null) {\n        buffer.write(\"<unknown class>\");\n      } else {\n        buffer.write(classNode.name.name);\n      }\n      buffer.write(\" in \");\n      buffer.write(source.fullName);\n      buffer.write(\" was not set while trying to resolve types.\");\n      AnalysisEngine.instance.logger.logError(buffer.toString(),\n          new CaughtException(new AnalysisException(), null));\n    }\n\n    // When the library is resynthesized, types of all of its elements are\n    // already set - statically or inferred. We don't want to overwrite them.\n    if (LibraryElementImpl.hasResolutionCapability(\n        definingLibrary, LibraryResolutionCapability.resolvedTypeNames)) {\n      return null;\n    }\n\n    element.declaredReturnType = _computeReturnType(node.returnType);\n    element.type = new FunctionTypeImpl(element);\n    _inferSetterReturnType(element);\n    _inferOperatorReturnType(element);\n    if (element is PropertyAccessorElement) {\n      PropertyAccessorElement accessor = element as PropertyAccessorElement;\n      PropertyInducingElementImpl variable =\n          accessor.variable as PropertyInducingElementImpl;\n      if (accessor.isGetter) {\n        variable.declaredType = element.returnType;\n      } else if (variable.type == null) {\n        List<ParameterElement> parameters = element.parameters;\n        DartType type = parameters != null && parameters.length > 0\n            ? parameters[0].type\n            : _dynamicType;\n        variable.declaredType = type;\n      }\n    }\n\n    return null;\n  }\n\n  @override\n  Object visitNode(AstNode node) {\n    // In API mode we need to skip:\n    //   - function bodies;\n    //   - default values of parameters;\n    //   - initializers of top-level variables.\n    if (mode == TypeResolverMode.api) {\n      if (node is FunctionBody) {\n        return null;\n      }\n      if (node is DefaultFormalParameter) {\n        node.parameter.accept(this);\n        return null;\n      }\n      if (node is VariableDeclaration) {\n        return null;\n      }\n    }\n\n    // In local mode we need to resolve only:\n    //   - function bodies;\n    //   - default values of parameters;\n    //   - initializers of top-level variables.\n    // So, we carefully visit only nodes that are, or contain, these nodes.\n    // The client may choose to start visiting any node, but we still want to\n    // resolve only type names that are local.\n    if (mode == TypeResolverMode.local) {\n      // We are in the state of visiting all nodes.\n      if (_localModeVisitAll) {\n        return super.visitNode(node);\n      }\n\n      // Ensure that the name scope is ready.\n      if (!_localModeScopeReady) {\n        void fillNameScope(AstNode node) {\n          if (node is FunctionBody ||\n              node is FormalParameterList ||\n              node is VariableDeclaration) {\n            throw new StateError(\n                'Local type resolution must start from a class or unit member.');\n          }\n          // Create enclosing name scopes.\n          AstNode parent = node.parent;\n          if (parent != null) {\n            fillNameScope(parent);\n          }\n          // Create the name scope for the node.\n          if (node is ClassDeclaration) {\n            ClassElement classElement = node.element;\n            nameScope = new TypeParameterScope(nameScope, classElement);\n            nameScope = new ClassScope(nameScope, classElement);\n          }\n        }\n\n        fillNameScope(node);\n        _localModeScopeReady = true;\n      }\n\n      /**\n       * Visit the given [node] and all its children.\n       */\n      void visitAllNodes(AstNode node) {\n        if (node != null) {\n          bool wasVisitAllInLocalMode = _localModeVisitAll;\n          try {\n            _localModeVisitAll = true;\n            node.accept(this);\n          } finally {\n            _localModeVisitAll = wasVisitAllInLocalMode;\n          }\n        }\n      }\n\n      // Visit only nodes that may contain type names to resolve.\n      if (node is CompilationUnit) {\n        node.declarations.forEach(visitNode);\n      } else if (node is ClassDeclaration) {\n        node.members.forEach(visitNode);\n      } else if (node is DefaultFormalParameter) {\n        visitAllNodes(node.defaultValue);\n      } else if (node is FieldDeclaration) {\n        visitNode(node.fields);\n      } else if (node is FunctionBody) {\n        visitAllNodes(node);\n      } else if (node is FunctionDeclaration) {\n        visitNode(node.functionExpression.parameters);\n        visitAllNodes(node.functionExpression.body);\n      } else if (node is FormalParameterList) {\n        node.parameters.accept(this);\n      } else if (node is MethodDeclaration) {\n        visitNode(node.parameters);\n        visitAllNodes(node.body);\n      } else if (node is TopLevelVariableDeclaration) {\n        visitNode(node.variables);\n      } else if (node is VariableDeclaration) {\n        visitAllNodes(node.initializer);\n      } else if (node is VariableDeclarationList) {\n        node.variables.forEach(visitNode);\n      }\n      return null;\n    }\n\n    // The mode in which we visit all nodes.\n    return super.visitNode(node);\n  }\n\n  @override\n  Object visitSimpleFormalParameter(SimpleFormalParameter node) {\n    super.visitSimpleFormalParameter(node);\n    DartType declaredType;\n    TypeAnnotation typeName = node.type;\n    if (typeName == null) {\n      declaredType = _dynamicType;\n    } else {\n      declaredType = _typeNameResolver._getType(typeName);\n    }\n    Element element = node.element;\n    if (element is ParameterElementImpl) {\n      element.declaredType = declaredType;\n    } else {\n      // TODO(brianwilkerson) Report the internal error.\n    }\n    return null;\n  }\n\n  @override\n  Object visitSuperExpression(SuperExpression node) {\n    _hasReferenceToSuper = true;\n    return super.visitSuperExpression(node);\n  }\n\n  @override\n  Object visitTypeName(TypeName node) {\n    super.visitTypeName(node);\n    _typeNameResolver.nameScope = this.nameScope;\n    _typeNameResolver.resolveTypeName(node);\n    return null;\n  }\n\n  @override\n  Object visitTypeParameter(TypeParameter node) {\n    super.visitTypeParameter(node);\n    AstNode parent2 = node.parent?.parent;\n    if (parent2 is ClassDeclaration ||\n        parent2 is ClassTypeAlias ||\n        parent2 is FunctionTypeAlias) {\n      // Bounds of parameters of classes and function type aliases are\n      // already resolved.\n    } else {\n      TypeAnnotation bound = node.bound;\n      if (bound != null) {\n        TypeParameterElementImpl typeParameter =\n            node.name.staticElement as TypeParameterElementImpl;\n        if (typeParameter != null) {\n          typeParameter.bound = bound.type;\n        }\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitVariableDeclaration(VariableDeclaration node) {\n    super.visitVariableDeclaration(node);\n    var variableList = node.parent as VariableDeclarationList;\n    // When the library is resynthesized, the types of field elements are\n    // already set - statically or inferred. We don't want to overwrite them.\n    if (variableList.parent is FieldDeclaration &&\n        LibraryElementImpl.hasResolutionCapability(\n            definingLibrary, LibraryResolutionCapability.resolvedTypeNames)) {\n      return null;\n    }\n    // Resolve the type.\n    DartType declaredType;\n    TypeAnnotation typeName = variableList.type;\n    if (typeName == null) {\n      declaredType = _dynamicType;\n    } else {\n      declaredType = _typeNameResolver._getType(typeName);\n    }\n    Element element = node.name.staticElement;\n    if (element is VariableElementImpl) {\n      element.declaredType = declaredType;\n    }\n    return null;\n  }\n\n  /**\n   * Given the [returnType] of a function, compute the return type of the\n   * function.\n   */\n  DartType _computeReturnType(TypeAnnotation returnType) {\n    if (returnType == null) {\n      return _dynamicType;\n    } else {\n      return _typeNameResolver._getType(returnType);\n    }\n  }\n\n  /**\n   * Return the class element that represents the class whose name was provided.\n   *\n   * @param identifier the name from the declaration of a class\n   * @return the class element that represents the class\n   */\n  ClassElementImpl _getClassElement(SimpleIdentifier identifier) {\n    // TODO(brianwilkerson) Seems like we should be using\n    // ClassDeclaration.getElement().\n    if (identifier == null) {\n      // TODO(brianwilkerson) Report this\n      // Internal error: We should never build a class declaration without a\n      // name.\n      return null;\n    }\n    Element element = identifier.staticElement;\n    if (element is ClassElementImpl) {\n      return element;\n    }\n    // TODO(brianwilkerson) Report this\n    // Internal error: Failed to create an element for a class declaration.\n    return null;\n  }\n\n  /**\n   * In strong mode we infer \"void\" as the return type of operator []= (as void\n   * is the only legal return type for []=). This allows us to give better\n   * errors later if an invalid type is returned.\n   */\n  void _inferOperatorReturnType(ExecutableElementImpl element) {\n    if (_strongMode &&\n        element.isOperator &&\n        element.name == '[]=' &&\n        element.hasImplicitReturnType) {\n      element.declaredReturnType = VoidTypeImpl.instance;\n    }\n  }\n\n  /**\n   * In strong mode we infer \"void\" as the setter return type (as void is the\n   * only legal return type for a setter). This allows us to give better\n   * errors later if an invalid type is returned.\n   */\n  void _inferSetterReturnType(ExecutableElementImpl element) {\n    if (_strongMode &&\n        element is PropertyAccessorElementImpl &&\n        element.isSetter &&\n        element.hasImplicitReturnType) {\n      element.declaredReturnType = VoidTypeImpl.instance;\n    }\n  }\n\n  /**\n   * Record that the static type of the given node is the given type.\n   *\n   * @param expression the node whose type is to be recorded\n   * @param type the static type of the node\n   */\n  Object _recordType(Expression expression, DartType type) {\n    if (type == null) {\n      expression.staticType = _dynamicType;\n    } else {\n      expression.staticType = type;\n    }\n    return null;\n  }\n\n  /**\n   * Resolve the types in the given [withClause] and [implementsClause] and\n   * associate those types with the given [classElement].\n   */\n  void _resolve(ClassElementImpl classElement, WithClause withClause,\n      ImplementsClause implementsClause) {\n    if (withClause != null) {\n      List<InterfaceType> mixinTypes = _resolveTypes(\n          withClause.mixinTypes,\n          CompileTimeErrorCode.MIXIN_OF_NON_CLASS,\n          CompileTimeErrorCode.MIXIN_OF_ENUM,\n          CompileTimeErrorCode.MIXIN_OF_NON_CLASS);\n      if (classElement != null) {\n        classElement.mixins = mixinTypes;\n      }\n    }\n    if (implementsClause != null) {\n      NodeList<TypeName> interfaces = implementsClause.interfaces;\n      List<InterfaceType> interfaceTypes = _resolveTypes(\n          interfaces,\n          CompileTimeErrorCode.IMPLEMENTS_NON_CLASS,\n          CompileTimeErrorCode.IMPLEMENTS_ENUM,\n          CompileTimeErrorCode.IMPLEMENTS_DYNAMIC);\n      if (classElement != null) {\n        classElement.interfaces = interfaceTypes;\n      }\n      // TODO(brianwilkerson) Move the following checks to ErrorVerifier.\n      int count = interfaces.length;\n      List<bool> detectedRepeatOnIndex = new List<bool>.filled(count, false);\n      for (int i = 0; i < detectedRepeatOnIndex.length; i++) {\n        detectedRepeatOnIndex[i] = false;\n      }\n      for (int i = 0; i < count; i++) {\n        TypeName typeName = interfaces[i];\n        if (!detectedRepeatOnIndex[i]) {\n          Element element = typeName.name.staticElement;\n          for (int j = i + 1; j < count; j++) {\n            TypeName typeName2 = interfaces[j];\n            Identifier identifier2 = typeName2.name;\n            String name2 = identifier2.name;\n            Element element2 = identifier2.staticElement;\n            if (element != null && element == element2) {\n              detectedRepeatOnIndex[j] = true;\n              errorReporter.reportErrorForNode(\n                  CompileTimeErrorCode.IMPLEMENTS_REPEATED, typeName2, [name2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Return the type specified by the given name.\n   *\n   * @param typeName the type name specifying the type to be returned\n   * @param nonTypeError the error to produce if the type name is defined to be something other than\n   *          a type\n   * @param enumTypeError the error to produce if the type name is defined to be an enum\n   * @param dynamicTypeError the error to produce if the type name is \"dynamic\"\n   * @return the type specified by the type name\n   */\n  InterfaceType _resolveType(TypeName typeName, ErrorCode nonTypeError,\n      ErrorCode enumTypeError, ErrorCode dynamicTypeError) {\n    DartType type = typeName.type;\n    if (type is InterfaceType) {\n      ClassElement element = type.element;\n      if (element != null && element.isEnum) {\n        errorReporter.reportErrorForNode(enumTypeError, typeName);\n        return null;\n      }\n      return type;\n    }\n    // If the type is not an InterfaceType, then visitTypeName() sets the type\n    // to be a DynamicTypeImpl\n    Identifier name = typeName.name;\n    // TODO(mfairhurst) differentiate between dynamic via clean path, and error\n    // types, and then check `type.isDynamic`. However, if we do that now, then\n    // [nonTypeError] will never be reported because non types are resolved to\n    // dynamic.\n    if (name.name == Keyword.DYNAMIC.lexeme) {\n      errorReporter.reportErrorForNode(dynamicTypeError, name, [name.name]);\n    } else if (!nameScope.shouldIgnoreUndefined(name)) {\n      errorReporter.reportErrorForNode(nonTypeError, name, [name.name]);\n    }\n    return null;\n  }\n\n  /**\n   * Resolve the types in the given list of type names.\n   *\n   * @param typeNames the type names to be resolved\n   * @param nonTypeError the error to produce if the type name is defined to be something other than\n   *          a type\n   * @param enumTypeError the error to produce if the type name is defined to be an enum\n   * @param dynamicTypeError the error to produce if the type name is \"dynamic\"\n   * @return an array containing all of the types that were resolved.\n   */\n  List<InterfaceType> _resolveTypes(\n      NodeList<TypeName> typeNames,\n      ErrorCode nonTypeError,\n      ErrorCode enumTypeError,\n      ErrorCode dynamicTypeError) {\n    List<InterfaceType> types = new List<InterfaceType>();\n    for (TypeName typeName in typeNames) {\n      InterfaceType type =\n          _resolveType(typeName, nonTypeError, enumTypeError, dynamicTypeError);\n      if (type != null) {\n        types.add(type);\n      }\n    }\n    return types;\n  }\n\n  /**\n   * Given a function typed [parameter] with [FunctionType] based on a\n   * [GenericFunctionTypeElementImpl], compute and set the return type for the\n   * function element.\n   */\n  void _setFunctionTypedParameterType(ParameterElementImpl parameter,\n      TypeAnnotation returnType, FormalParameterList parameterList) {\n    DartType type = parameter.type;\n    GenericFunctionTypeElementImpl typeElement = type.element;\n    typeElement.returnType = _computeReturnType(returnType);\n  }\n}\n\n/**\n * Instances of the class [UnusedLocalElementsVerifier] traverse an AST\n * looking for cases of [HintCode.UNUSED_ELEMENT], [HintCode.UNUSED_FIELD],\n * [HintCode.UNUSED_LOCAL_VARIABLE], etc.\n */\nclass UnusedLocalElementsVerifier extends RecursiveAstVisitor {\n  /**\n   * The error listener to which errors will be reported.\n   */\n  final AnalysisErrorListener _errorListener;\n\n  /**\n   * The elements know to be used.\n   */\n  final UsedLocalElements _usedElements;\n\n  /**\n   * Create a new instance of the [UnusedLocalElementsVerifier].\n   */\n  UnusedLocalElementsVerifier(this._errorListener, this._usedElements);\n\n  visitSimpleIdentifier(SimpleIdentifier node) {\n    if (node.inDeclarationContext()) {\n      var element = node.staticElement;\n      if (element is ClassElement) {\n        _visitClassElement(element);\n      } else if (element is FieldElement) {\n        _visitFieldElement(element);\n      } else if (element is FunctionElement) {\n        _visitFunctionElement(element);\n      } else if (element is FunctionTypeAliasElement) {\n        _visitFunctionTypeAliasElement(element);\n      } else if (element is LocalVariableElement) {\n        _visitLocalVariableElement(element);\n      } else if (element is MethodElement) {\n        _visitMethodElement(element);\n      } else if (element is PropertyAccessorElement) {\n        _visitPropertyAccessorElement(element);\n      } else if (element is TopLevelVariableElement) {\n        _visitTopLevelVariableElement(element);\n      }\n    }\n  }\n\n  bool _isNamedUnderscore(LocalVariableElement element) {\n    String name = element.name;\n    if (name != null) {\n      for (int index = name.length - 1; index >= 0; --index) {\n        if (name.codeUnitAt(index) != 0x5F) {\n          // 0x5F => '_'\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  bool _isReadMember(Element element) {\n    if (element.isPublic) {\n      return true;\n    }\n    if (element.isSynthetic) {\n      return true;\n    }\n    return _usedElements.readMembers.contains(element.displayName);\n  }\n\n  bool _isUsedElement(Element element) {\n    if (element.isSynthetic) {\n      return true;\n    }\n    if (element is LocalVariableElement ||\n        element is FunctionElement && !element.isStatic) {\n      // local variable or function\n    } else {\n      if (element.isPublic) {\n        return true;\n      }\n    }\n    return _usedElements.elements.contains(element);\n  }\n\n  bool _isUsedMember(Element element) {\n    if (element.isPublic) {\n      return true;\n    }\n    if (element.isSynthetic) {\n      return true;\n    }\n    if (_usedElements.members.contains(element.displayName)) {\n      return true;\n    }\n    return _usedElements.elements.contains(element);\n  }\n\n  void _reportErrorForElement(\n      ErrorCode errorCode, Element element, List<Object> arguments) {\n    if (element != null) {\n      _errorListener.onError(new AnalysisError(element.source,\n          element.nameOffset, element.nameLength, errorCode, arguments));\n    }\n  }\n\n  _visitClassElement(ClassElement element) {\n    if (!_isUsedElement(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n\n  _visitFieldElement(FieldElement element) {\n    if (!_isReadMember(element)) {\n      _reportErrorForElement(\n          HintCode.UNUSED_FIELD, element, [element.displayName]);\n    }\n  }\n\n  _visitFunctionElement(FunctionElement element) {\n    if (!_isUsedElement(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n\n  _visitFunctionTypeAliasElement(FunctionTypeAliasElement element) {\n    if (!_isUsedElement(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n\n  _visitLocalVariableElement(LocalVariableElement element) {\n    if (!_isUsedElement(element) && !_isNamedUnderscore(element)) {\n      HintCode errorCode;\n      if (_usedElements.isCatchException(element)) {\n        errorCode = HintCode.UNUSED_CATCH_CLAUSE;\n      } else if (_usedElements.isCatchStackTrace(element)) {\n        errorCode = HintCode.UNUSED_CATCH_STACK;\n      } else {\n        errorCode = HintCode.UNUSED_LOCAL_VARIABLE;\n      }\n      _reportErrorForElement(errorCode, element, [element.displayName]);\n    }\n  }\n\n  _visitMethodElement(MethodElement element) {\n    if (!_isUsedMember(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n\n  _visitPropertyAccessorElement(PropertyAccessorElement element) {\n    if (!_isUsedMember(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n\n  _visitTopLevelVariableElement(TopLevelVariableElement element) {\n    if (!_isUsedElement(element)) {\n      _reportErrorForElement(HintCode.UNUSED_ELEMENT, element,\n          [element.kind.displayName, element.displayName]);\n    }\n  }\n}\n\n/**\n * A container with information about used imports prefixes and used imported\n * elements.\n */\nclass UsedImportedElements {\n  /**\n   * The map of referenced [PrefixElement]s and the [Element]s that they prefix.\n   */\n  final Map<PrefixElement, List<Element>> prefixMap =\n      new HashMap<PrefixElement, List<Element>>();\n\n  /**\n   * The set of referenced top-level [Element]s.\n   */\n  final Set<Element> elements = new HashSet<Element>();\n}\n\n/**\n * A container with sets of used [Element]s.\n * All these elements are defined in a single compilation unit or a library.\n */\nclass UsedLocalElements {\n  /**\n   * Resolved, locally defined elements that are used or potentially can be\n   * used.\n   */\n  final HashSet<Element> elements = new HashSet<Element>();\n\n  /**\n   * [LocalVariableElement]s that represent exceptions in [CatchClause]s.\n   */\n  final HashSet<LocalVariableElement> catchExceptionElements =\n      new HashSet<LocalVariableElement>();\n\n  /**\n   * [LocalVariableElement]s that represent stack traces in [CatchClause]s.\n   */\n  final HashSet<LocalVariableElement> catchStackTraceElements =\n      new HashSet<LocalVariableElement>();\n\n  /**\n   * Names of resolved or unresolved class members that are referenced in the\n   * library.\n   */\n  final HashSet<String> members = new HashSet<String>();\n\n  /**\n   * Names of resolved or unresolved class members that are read in the\n   * library.\n   */\n  final HashSet<String> readMembers = new HashSet<String>();\n\n  UsedLocalElements();\n\n  factory UsedLocalElements.merge(List<UsedLocalElements> parts) {\n    UsedLocalElements result = new UsedLocalElements();\n    int length = parts.length;\n    for (int i = 0; i < length; i++) {\n      UsedLocalElements part = parts[i];\n      result.elements.addAll(part.elements);\n      result.catchExceptionElements.addAll(part.catchExceptionElements);\n      result.catchStackTraceElements.addAll(part.catchStackTraceElements);\n      result.members.addAll(part.members);\n      result.readMembers.addAll(part.readMembers);\n    }\n    return result;\n  }\n\n  void addCatchException(LocalVariableElement element) {\n    if (element != null) {\n      catchExceptionElements.add(element);\n    }\n  }\n\n  void addCatchStackTrace(LocalVariableElement element) {\n    if (element != null) {\n      catchStackTraceElements.add(element);\n    }\n  }\n\n  void addElement(Element element) {\n    if (element != null) {\n      elements.add(element);\n    }\n  }\n\n  bool isCatchException(LocalVariableElement element) {\n    return catchExceptionElements.contains(element);\n  }\n\n  bool isCatchStackTrace(LocalVariableElement element) {\n    return catchStackTraceElements.contains(element);\n  }\n}\n\n/**\n * Instances of the class `VariableResolverVisitor` are used to resolve\n * [SimpleIdentifier]s to local variables and formal parameters.\n */\nclass VariableResolverVisitor extends ScopedVisitor {\n  /**\n   * The method or function that we are currently visiting, or `null` if we are not inside a\n   * method or function.\n   */\n  ExecutableElement _enclosingFunction;\n\n  /**\n   * Information about local variables in the enclosing function or method.\n   */\n  LocalVariableInfo _localVariableInfo;\n\n  /**\n   * Initialize a newly created visitor to resolve the nodes in an AST node.\n   *\n   * [definingLibrary] is the element for the library containing the node being\n   * visited.\n   * [source] is the source representing the compilation unit containing the\n   * node being visited\n   * [typeProvider] is the object used to access the types from the core\n   * library.\n   * [errorListener] is the error listener that will be informed of any errors\n   * that are found during resolution.\n   * [nameScope] is the scope used to resolve identifiers in the node that will\n   * first be visited.  If `null` or unspecified, a new [LibraryScope] will be\n   * created based on [definingLibrary] and [typeProvider].\n   */\n  VariableResolverVisitor(LibraryElement definingLibrary, Source source,\n      TypeProvider typeProvider, AnalysisErrorListener errorListener,\n      {Scope nameScope})\n      : super(definingLibrary, source, typeProvider, errorListener,\n            nameScope: nameScope);\n\n  @override\n  Object visitBlockFunctionBody(BlockFunctionBody node) {\n    assert(_localVariableInfo != null);\n    return super.visitBlockFunctionBody(node);\n  }\n\n  @override\n  Object visitConstructorDeclaration(ConstructorDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    LocalVariableInfo outerLocalVariableInfo = _localVariableInfo;\n    try {\n      _localVariableInfo ??= new LocalVariableInfo();\n      (node.body as FunctionBodyImpl).localVariableInfo = _localVariableInfo;\n      _enclosingFunction = node.element;\n      return super.visitConstructorDeclaration(node);\n    } finally {\n      _localVariableInfo = outerLocalVariableInfo;\n      _enclosingFunction = outerFunction;\n    }\n  }\n\n  @override\n  Object visitExportDirective(ExportDirective node) => null;\n\n  @override\n  Object visitExpressionFunctionBody(ExpressionFunctionBody node) {\n    assert(_localVariableInfo != null);\n    return super.visitExpressionFunctionBody(node);\n  }\n\n  @override\n  Object visitFunctionDeclaration(FunctionDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    LocalVariableInfo outerLocalVariableInfo = _localVariableInfo;\n    try {\n      _localVariableInfo ??= new LocalVariableInfo();\n      (node.functionExpression.body as FunctionBodyImpl).localVariableInfo =\n          _localVariableInfo;\n      _enclosingFunction = node.element;\n      return super.visitFunctionDeclaration(node);\n    } finally {\n      _localVariableInfo = outerLocalVariableInfo;\n      _enclosingFunction = outerFunction;\n    }\n  }\n\n  @override\n  Object visitFunctionExpression(FunctionExpression node) {\n    if (node.parent is! FunctionDeclaration) {\n      ExecutableElement outerFunction = _enclosingFunction;\n      LocalVariableInfo outerLocalVariableInfo = _localVariableInfo;\n      try {\n        _localVariableInfo ??= new LocalVariableInfo();\n        (node.body as FunctionBodyImpl).localVariableInfo = _localVariableInfo;\n        _enclosingFunction = node.element;\n        return super.visitFunctionExpression(node);\n      } finally {\n        _localVariableInfo = outerLocalVariableInfo;\n        _enclosingFunction = outerFunction;\n      }\n    } else {\n      return super.visitFunctionExpression(node);\n    }\n  }\n\n  @override\n  Object visitImportDirective(ImportDirective node) => null;\n\n  @override\n  Object visitMethodDeclaration(MethodDeclaration node) {\n    ExecutableElement outerFunction = _enclosingFunction;\n    LocalVariableInfo outerLocalVariableInfo = _localVariableInfo;\n    try {\n      _localVariableInfo ??= new LocalVariableInfo();\n      (node.body as FunctionBodyImpl).localVariableInfo = _localVariableInfo;\n      _enclosingFunction = node.element;\n      return super.visitMethodDeclaration(node);\n    } finally {\n      _localVariableInfo = outerLocalVariableInfo;\n      _enclosingFunction = outerFunction;\n    }\n  }\n\n  @override\n  Object visitSimpleIdentifier(SimpleIdentifier node) {\n    // Ignore if already resolved - declaration or type.\n    if (node.inDeclarationContext()) {\n      return null;\n    }\n    // Ignore if it cannot be a reference to a local variable.\n    AstNode parent = node.parent;\n    if (parent is FieldFormalParameter) {\n      return null;\n    } else if (parent is ConstructorDeclaration && parent.returnType == node) {\n      return null;\n    } else if (parent is ConstructorFieldInitializer &&\n        parent.fieldName == node) {\n      return null;\n    }\n    // Ignore if qualified.\n    if (parent is PrefixedIdentifier && identical(parent.identifier, node)) {\n      return null;\n    }\n    if (parent is PropertyAccess && identical(parent.propertyName, node)) {\n      return null;\n    }\n    if (parent is MethodInvocation &&\n        identical(parent.methodName, node) &&\n        parent.realTarget != null) {\n      return null;\n    }\n    if (parent is ConstructorName) {\n      return null;\n    }\n    if (parent is Label) {\n      return null;\n    }\n    // Prepare VariableElement.\n    Element element = nameScope.lookup(node, definingLibrary);\n    if (element is! VariableElement) {\n      return null;\n    }\n    // Must be local or parameter.\n    ElementKind kind = element.kind;\n    if (kind == ElementKind.LOCAL_VARIABLE || kind == ElementKind.PARAMETER) {\n      node.staticElement = element;\n      if (node.inSetterContext()) {\n        _localVariableInfo.potentiallyMutatedInScope.add(element);\n        if (element.enclosingElement != _enclosingFunction) {\n          _localVariableInfo.potentiallyMutatedInClosure.add(element);\n        }\n      }\n    }\n    return null;\n  }\n\n  @override\n  Object visitTypeName(TypeName node) {\n    return null;\n  }\n}\n\nclass _ConstantVerifier_validateInitializerExpression extends ConstantVisitor {\n  final ConstantVerifier verifier;\n\n  List<ParameterElement> parameterElements;\n\n  TypeSystem _typeSystem;\n\n  _ConstantVerifier_validateInitializerExpression(\n      TypeProvider typeProvider,\n      ErrorReporter errorReporter,\n      this.verifier,\n      this.parameterElements,\n      DeclaredVariables declaredVariables,\n      {TypeSystem typeSystem})\n      : _typeSystem = typeSystem ?? new TypeSystemImpl(typeProvider),\n        super(\n            new ConstantEvaluationEngine(typeProvider, declaredVariables,\n                typeSystem: typeSystem),\n            errorReporter);\n\n  @override\n  DartObjectImpl visitSimpleIdentifier(SimpleIdentifier node) {\n    Element element = node.staticElement;\n    int length = parameterElements.length;\n    for (int i = 0; i < length; i++) {\n      ParameterElement parameterElement = parameterElements[i];\n      if (identical(parameterElement, element) && parameterElement != null) {\n        DartType type = parameterElement.type;\n        if (type != null) {\n          if (type.isDynamic) {\n            return new DartObjectImpl(\n                verifier._typeProvider.objectType, DynamicState.DYNAMIC_STATE);\n          } else if (_typeSystem.isSubtypeOf(type, verifier._boolType)) {\n            return new DartObjectImpl(\n                verifier._typeProvider.boolType, BoolState.UNKNOWN_VALUE);\n          } else if (_typeSystem.isSubtypeOf(\n              type, verifier._typeProvider.doubleType)) {\n            return new DartObjectImpl(\n                verifier._typeProvider.doubleType, DoubleState.UNKNOWN_VALUE);\n          } else if (_typeSystem.isSubtypeOf(type, verifier._intType)) {\n            return new DartObjectImpl(\n                verifier._typeProvider.intType, IntState.UNKNOWN_VALUE);\n          } else if (_typeSystem.isSubtypeOf(type, verifier._numType)) {\n            return new DartObjectImpl(\n                verifier._typeProvider.numType, NumState.UNKNOWN_VALUE);\n          } else if (_typeSystem.isSubtypeOf(type, verifier._stringType)) {\n            return new DartObjectImpl(\n                verifier._typeProvider.stringType, StringState.UNKNOWN_VALUE);\n          }\n          //\n          // We don't test for other types of objects (such as List, Map,\n          // Function or Type) because there are no operations allowed on such\n          // types other than '==' and '!=', which means that we don't need to\n          // know the type when there is no specific data about the state of\n          // such objects.\n          //\n        }\n        return new DartObjectImpl(\n            type is InterfaceType ? type : verifier._typeProvider.objectType,\n            GenericState.UNKNOWN_VALUE);\n      }\n    }\n    return super.visitSimpleIdentifier(node);\n  }\n}\n\n/**\n * An object used to track the usage of labels within a single label scope.\n */\nclass _LabelTracker {\n  /**\n   * The tracker for the outer label scope.\n   */\n  final _LabelTracker outerTracker;\n\n  /**\n   * The labels whose usage is being tracked.\n   */\n  final List<Label> labels;\n\n  /**\n   * A list of flags corresponding to the list of [labels] indicating whether\n   * the corresponding label has been used.\n   */\n  List<bool> used;\n\n  /**\n   * A map from the names of labels to the index of the label in [labels].\n   */\n  final Map<String, int> labelMap = <String, int>{};\n\n  /**\n   * Initialize a newly created label tracker.\n   */\n  _LabelTracker(this.outerTracker, this.labels) {\n    used = new List.filled(labels.length, false);\n    for (int i = 0; i < labels.length; i++) {\n      labelMap[labels[i].label.name] = i;\n    }\n  }\n\n  /**\n   * Record that the label with the given [labelName] has been used.\n   */\n  void recordUsage(String labelName) {\n    if (labelName != null) {\n      int index = labelMap[labelName];\n      if (index != null) {\n        used[index] = true;\n      } else if (outerTracker != null) {\n        outerTracker.recordUsage(labelName);\n      }\n    }\n  }\n\n  /**\n   * Return the unused labels.\n   */\n  Iterable<Label> unusedLabels() sync* {\n    for (int i = 0; i < labels.length; i++) {\n      if (!used[i]) {\n        yield labels[i];\n      }\n    }\n  }\n}\n\nclass _ResolverVisitor_isVariableAccessedInClosure\n    extends RecursiveAstVisitor<Object> {\n  final Element variable;\n\n  bool result = false;\n\n  bool _inClosure = false;\n\n  _ResolverVisitor_isVariableAccessedInClosure(this.variable);\n\n  @override\n  Object visitFunctionExpression(FunctionExpression node) {\n    bool inClosure = this._inClosure;\n    try {\n      this._inClosure = true;\n      return super.visitFunctionExpression(node);\n    } finally {\n      this._inClosure = inClosure;\n    }\n  }\n\n  @override\n  Object visitSimpleIdentifier(SimpleIdentifier node) {\n    if (result) {\n      return null;\n    }\n    if (_inClosure && identical(node.staticElement, variable)) {\n      result = true;\n    }\n    return null;\n  }\n}\n\nclass _ResolverVisitor_isVariablePotentiallyMutatedIn\n    extends RecursiveAstVisitor<Object> {\n  final Element variable;\n\n  bool result = false;\n\n  _ResolverVisitor_isVariablePotentiallyMutatedIn(this.variable);\n\n  @override\n  Object visitSimpleIdentifier(SimpleIdentifier node) {\n    if (result) {\n      return null;\n    }\n    if (identical(node.staticElement, variable)) {\n      if (node.inSetterContext()) {\n        result = true;\n      }\n    }\n    return null;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/src/generated/resolver.dart	(date 1533041846000)
+++ lib/src/generated/resolver.dart	(date 1533825325000)
@@ -10112,6 +10112,9 @@
 
   @override
   Object visitGenericFunctionType(GenericFunctionType node) {
+    if (node.type?.element is DynamicElementImpl) {
+      print('!!! BUILD WILL FAIL DUE TO THIS ERROR !!!');
+    }
     GenericFunctionTypeElementImpl element = node.type?.element;
     if (element != null) {
       super.visitGenericFunctionType(node);
Index: lib/src/task/driver.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:analyzer/exception/exception.dart';\nimport 'package:analyzer/src/context/cache.dart';\nimport 'package:analyzer/src/generated/engine.dart';\nimport 'package:analyzer/src/generated/resolver.dart';\nimport 'package:analyzer/src/generated/utilities_general.dart';\nimport 'package:analyzer/src/task/api/model.dart';\nimport 'package:analyzer/src/task/inputs.dart';\nimport 'package:analyzer/src/task/manager.dart';\n\nfinal PerformanceTag analysisDriverProcessOutputs =\n    _taskDriverTag.createChild('processOutputs');\n\nfinal PerformanceTag workOrderMoveNextPerformanceTag =\n    _taskDriverTag.createChild('workOrderMoveNext');\n\nfinal PerformanceTag _taskDriverTag =\n    PerformanceStatistics.analyzer.createChild('taskDriver');\n\n/**\n * An object that is used to cause analysis to be performed until all of the\n * required analysis information has been computed.\n */\nclass AnalysisDriver {\n  /**\n   * The task manager used to figure out how to compute analysis results.\n   */\n  final TaskManager taskManager;\n\n  /**\n   * The list of [WorkManager] used to figure out which analysis results to\n   * compute.\n   */\n  final List<WorkManager> workManagers;\n\n  /**\n   * The context in which analysis is to be performed.\n   */\n  final InternalAnalysisContext context;\n\n  /**\n   * The map of [ResultChangedEvent] controllers.\n   */\n  final Map<ResultDescriptor, StreamController<ResultChangedEvent>>\n      resultComputedControllers =\n      <ResultDescriptor, StreamController<ResultChangedEvent>>{};\n\n  /**\n   * The work order that was previously computed but that has not yet been\n   * completed.\n   */\n  WorkOrder currentWorkOrder;\n\n  /**\n   * Indicates whether any tasks are currently being performed (or building\n   * their inputs).  In debug builds, we use this to ensure that tasks don't\n   * try to make use of the task manager in reentrant fashion.\n   */\n  bool isTaskRunning = false;\n\n  /**\n   * The controller that is notified when a task is started.\n   */\n  StreamController<AnalysisTask> _onTaskStartedController;\n\n  /**\n   * The controller that is notified when a task is complete.\n   */\n  StreamController<AnalysisTask> _onTaskCompletedController;\n\n  /**\n   * Initialize a newly created driver to use the tasks know to the given\n   * [taskManager] to perform analysis in the given [context].\n   */\n  AnalysisDriver(this.taskManager, this.workManagers, this.context) {\n    _onTaskStartedController = new StreamController.broadcast();\n    _onTaskCompletedController = new StreamController.broadcast();\n  }\n\n  /**\n   * The stream that is notified when a task is complete.\n   */\n  Stream<AnalysisTask> get onTaskCompleted => _onTaskCompletedController.stream;\n\n  /**\n   * The stream that is notified when a task is started.\n   */\n  Stream<AnalysisTask> get onTaskStarted => _onTaskStartedController.stream;\n\n  /**\n   * Perform work until the given [result] has been computed for the given\n   * [target]. Return the last [AnalysisTask] that was performed.\n   */\n  AnalysisTask computeResult(AnalysisTarget target, ResultDescriptor result) {\n    assert(!isTaskRunning);\n    try {\n      isTaskRunning = true;\n      AnalysisTask task;\n      while (true) {\n        try {\n          WorkOrder workOrder = createWorkOrderForResult(target, result);\n          if (workOrder != null) {\n            while (workOrder.moveNext()) {\n              task = performWorkItem(workOrder.current);\n            }\n          }\n          break;\n        } on ModificationTimeMismatchError {\n          // Cache inconsistency was detected and fixed by invalidating\n          // corresponding results in cache. Computation must be restarted.\n        }\n      }\n      return task;\n    } finally {\n      isTaskRunning = false;\n    }\n  }\n\n  /**\n   * Return the work order describing the work that should be getting worked on,\n   * or `null` if there is currently no work to be done.\n   */\n  WorkOrder createNextWorkOrder() {\n    while (true) {\n      // Find the WorkManager with the highest priority.\n      WorkOrderPriority highestPriority = null;\n      WorkManager highestManager = null;\n      for (WorkManager manager in workManagers) {\n        WorkOrderPriority priority = manager.getNextResultPriority();\n        if (highestPriority == null || highestPriority.index > priority.index) {\n          highestPriority = priority;\n          highestManager = manager;\n        }\n      }\n      // Nothing to do.\n      if (highestPriority == WorkOrderPriority.NONE) {\n        return null;\n      }\n      // Create a new WorkOrder.\n      TargetedResult request = highestManager.getNextResult();\n//      print('request: $request');\n      if (request != null) {\n        WorkOrder workOrder =\n            createWorkOrderForResult(request.target, request.result);\n        if (workOrder != null) {\n          return workOrder;\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a work order that will produce the given [result] for the given\n   * [target]. Return the work order that was created, or `null` if the result\n   * has either already been computed or cannot be computed.\n   */\n  WorkOrder createWorkOrderForResult(\n      AnalysisTarget target, ResultDescriptor result) {\n    CacheEntry entry = context.getCacheEntry(target);\n    CacheState state = entry.getState(result);\n    if (state == CacheState.VALID ||\n        state == CacheState.ERROR ||\n        state == CacheState.IN_PROCESS) {\n      return null;\n    }\n    if (context.aboutToComputeResult(entry, result)) {\n      return null;\n    }\n    TaskDescriptor taskDescriptor = taskManager.findTask(target, result);\n    if (taskDescriptor == null) {\n      return null;\n    }\n    try {\n      WorkItem workItem =\n          new WorkItem(context, target, taskDescriptor, result, 0, null);\n      return new WorkOrder(taskManager, workItem);\n    } catch (exception, stackTrace) {\n      throw new AnalysisException(\n          'Could not create work order (target = $target; taskDescriptor = $taskDescriptor; result = $result)',\n          new CaughtException(exception, stackTrace));\n    }\n  }\n\n  /**\n   * Create a work order that will produce the required analysis results for\n   * the given [target]. If [isPriority] is true, then the target is a priority\n   * target. Return the work order that was created, or `null` if there is no\n   * further work that needs to be done for the given target.\n   */\n  WorkOrder createWorkOrderForTarget(AnalysisTarget target, bool isPriority) {\n    for (ResultDescriptor result in taskManager.generalResults) {\n      WorkOrder workOrder = createWorkOrderForResult(target, result);\n      if (workOrder != null) {\n        return workOrder;\n      }\n    }\n    if (isPriority) {\n      for (ResultDescriptor result in taskManager.priorityResults) {\n        WorkOrder workOrder = createWorkOrderForResult(target, result);\n        if (workOrder != null) {\n          return workOrder;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the stream that is notified when a new value for the given\n   * [descriptor] is computed.\n   */\n  Stream<ResultChangedEvent> onResultComputed(ResultDescriptor descriptor) {\n    return resultComputedControllers.putIfAbsent(descriptor, () {\n      return new StreamController<ResultChangedEvent>.broadcast(sync: true);\n    }).stream;\n  }\n\n  /**\n   * Perform the next analysis task, and return `true` if there is more work to\n   * be done in order to compute all of the required analysis information.\n   */\n  bool performAnalysisTask() {\n    //\n    // TODO(brianwilkerson) This implementation does not allow us to prioritize\n    // work across contexts. What we need is a way for an external client to ask\n    // to have all priority files analyzed for each context, then ask for normal\n    // files to be analyzed. There are a couple of ways to do this.\n    //\n    // First, we could add a \"bool priorityOnly\" parameter to this method and\n    // return null here when it is true.\n    //\n    // Second, we could add a concept of a priority order and (externally) run\n    // through the priorities from highest to lowest. That would be a nice\n    // generalization of the previous idea, but it isn't clear that we need the\n    // generality.\n    //\n    // Third, we could move performAnalysisTask and createNextWorkOrder to an\n    // object that knows about all sources in all contexts, so that instead of\n    // the client choosing a context and telling it do to some work, the client\n    // simply says \"do some work\", and the engine chooses the best thing to do\n    // next regardless of what context it's in.\n    //\n    assert(!isTaskRunning);\n    try {\n      isTaskRunning = true;\n      if (currentWorkOrder == null) {\n        currentWorkOrder = createNextWorkOrder();\n      } else if (currentWorkOrder.moveNext()) {\n        try {\n          performWorkItem(currentWorkOrder.current);\n        } on ModificationTimeMismatchError {\n          reset();\n          return true;\n        }\n      } else {\n        currentWorkOrder = createNextWorkOrder();\n      }\n      return currentWorkOrder != null;\n    } finally {\n      isTaskRunning = false;\n    }\n  }\n\n  /**\n   * Perform the given work item.\n   * Return the performed [AnalysisTask].\n   */\n  AnalysisTask performWorkItem(WorkItem item) {\n    if (item.exception != null) {\n      // Mark all of the results that the task would have computed as being in\n      // ERROR with the exception recorded on the work item.\n      CacheEntry targetEntry = context.getCacheEntry(item.target);\n      targetEntry.setErrorState(item.exception, item.descriptor.results);\n      return null;\n    }\n    // Otherwise, perform the task.\n    AnalysisTask task = item.buildTask();\n    _onTaskStartedController.add(task);\n    task.perform();\n    analysisDriverProcessOutputs.makeCurrentWhile(() {\n      AnalysisTarget target = task.target;\n      CacheEntry entry = context.getCacheEntry(target);\n      if (task.caughtException == null) {\n        List<TargetedResult> dependedOn =\n            context.analysisOptions.trackCacheDependencies\n                ? item.inputTargetedResults.toList()\n                : const <TargetedResult>[];\n        Map<ResultDescriptor, dynamic> outputs = task.outputs;\n        List<ResultDescriptor> results = task.descriptor.results;\n        int resultLength = results.length;\n        for (int i = 0; i < resultLength; i++) {\n          ResultDescriptor result = results[i];\n          // TODO(brianwilkerson) We could check here that a value was produced\n          // and throw an exception if not (unless we want to allow null values).\n          entry.setValue(result, outputs[result], dependedOn);\n        }\n        outputs.forEach((ResultDescriptor descriptor, value) {\n          StreamController<ResultChangedEvent> controller =\n              resultComputedControllers[descriptor];\n          if (controller != null) {\n            ResultChangedEvent event = new ResultChangedEvent(\n                context, target, descriptor, value, true);\n            controller.add(event);\n          }\n        });\n        for (WorkManager manager in workManagers) {\n          manager.resultsComputed(target, outputs);\n        }\n      } else {\n        entry.setErrorState(task.caughtException, item.descriptor.results);\n      }\n    });\n    _onTaskCompletedController.add(task);\n    return task;\n  }\n\n  /**\n   * Reset the state of the driver in response to a change in the state of one\n   * or more analysis targets. This will cause any analysis that was currently\n   * in process to be stopped and for analysis to resume based on the new state.\n   */\n  void reset() {\n    currentWorkOrder = null;\n  }\n}\n\n/**\n * Generic dependency walker suitable for use in the analysis task driver.\n * This class implements a variant of the path-based strong component algorithm\n * (described here: http://www.cs.colorado.edu/~hal/Papers/DFS/ipl.ps.gz), with\n * the following differences:\n *\n * - The algorithm is non-recursive so that it can be used in a coroutine\n *   fashion (each call to [getNextStronglyConnectedComponent] computes a\n *   single strongly connected component and then waits to be called again)\n *\n * - Instead of keeping a temporary array which maps nodes to their locations\n *   in the [path] array, we simply search the array when necessary.  This\n *   allows us to begin finding strongly connected components without having to\n *   know the size of the whole graph.\n *\n * - This algorithm does not compute all strongly connected components; only\n *   those reachable from the starting point which are as yet unevaluated.\n *\n * The algorithm, in essence, is to traverse the dependency graph in\n * depth-first fashion from a starting node.  If the path from the starting\n * node ever encounters the same node twice, then a cycle has been found, and\n * all the nodes comprising the cycle are (conceptually) contracted into a\n * single node.  The algorithm yields possibly-collapsed nodes in proper\n * topological sort order (all the dependencies of a node are yielded before,\n * or in the same contracted component as, the node itself).\n */\nabstract class CycleAwareDependencyWalker<Node> {\n  /**\n   * The path through the dependency graph that is currently being considered,\n   * with un-collapsed nodes.\n   */\n  final List<Node> _path;\n\n  /**\n   * For each node in [_path], a list of the unevaluated nodes which it is\n   * already known to depend on.\n   */\n  final List<List<Node>> _provisionalDependencies;\n\n  /**\n   * Indices into [_path] of the nodes which begin a new strongly connected\n   * component, in order.  The first index in [_contractedPath] is always 0.\n   *\n   * For all i < contractedPath.length - 1, at least one node in the strongly\n   * connected component represented by [contractedPath[i]] depends directly\n   * on at least one node in the strongly connected component represented by\n   * [contractedPath[i+1]].\n   */\n  final List<int> _contractedPath;\n\n  /**\n   * Index into [_path] of the nodes which we are currently in the process of\n   * querying for their dependencies.\n   *\n   * [currentIndices.last] always refers to a member of the last strongly\n   * connected component indicated by [_contractedPath].\n   */\n  final List<int> _currentIndices;\n\n  /**\n   * Begin walking dependencies starting at [startingNode].\n   */\n  CycleAwareDependencyWalker(Node startingNode)\n      : _path = <Node>[startingNode],\n        _provisionalDependencies = <List<Node>>[<Node>[]],\n        _contractedPath = <int>[0],\n        _currentIndices = <int>[0];\n\n  /**\n   * Determine the next unevaluated input for [node], skipping any inputs in\n   * [skipInputs], and return it.  If [node] has no further inputs, return\n   * `null`.\n   */\n  Node getNextInput(Node node, List<Node> skipInputs);\n\n  /**\n   * Determine the next strongly connected component in the graph, and return\n   * it.  The client is expected to evaluate this component before calling\n   * [getNextStronglyConnectedComponent] again.\n   */\n  StronglyConnectedComponent<Node> getNextStronglyConnectedComponent() {\n    while (_currentIndices.isNotEmpty) {\n      Node nextUnevaluatedInput = getNextInput(_path[_currentIndices.last],\n          _provisionalDependencies[_currentIndices.last]);\n      // If the assertion below fails, it indicates that [getNextInput] did not\n      // skip an input that we asked it to skip.\n      assert(!_provisionalDependencies[_currentIndices.last]\n          .contains(nextUnevaluatedInput));\n      if (nextUnevaluatedInput != null) {\n        // TODO(paulberry): the call to _path.indexOf makes the algorithm\n        // O(n^2) in the depth of the dependency graph.  If this becomes a\n        // problem, consider maintaining a map from node to index.\n        int previousIndex = _path.indexOf(nextUnevaluatedInput);\n        if (previousIndex != -1) {\n          // Update contractedPath to indicate that all nodes in the path\n          // between previousIndex and currentIndex are part of the same\n          // strongly connected component.\n          while (_contractedPath.last > previousIndex) {\n            _contractedPath.removeLast();\n          }\n          // Store nextUnevaluatedInput as a provisional dependency so that we\n          // can move on to computing other dependencies.\n          _provisionalDependencies[_currentIndices.last]\n              .add(nextUnevaluatedInput);\n          // And loop to move on to the node's next input.\n          continue;\n        } else {\n          // This is a brand new input and there's no reason (yet) to believe\n          // that it is in the same strongly connected component as any other\n          // node, so push it onto the end of the path.\n          int newIndex = _path.length;\n          _path.add(nextUnevaluatedInput);\n          _provisionalDependencies.add(<Node>[]);\n          _contractedPath.add(newIndex);\n          _currentIndices.add(newIndex);\n          // And loop to move on to the new node's inputs.\n          continue;\n        }\n      } else {\n        // The node has no more inputs.  Figure out if there are any more nodes\n        // in the current strongly connected component that need to have their\n        // indices examined.\n        _currentIndices.removeLast();\n        if (_currentIndices.isEmpty ||\n            _currentIndices.last < _contractedPath.last) {\n          // No more nodes in the current strongly connected component need to\n          // have their indices examined.  We can now yield this component to\n          // the caller.\n          List<Node> nodes = _path.sublist(_contractedPath.last);\n          bool containsCycle = nodes.length > 1;\n          if (!containsCycle) {\n            if (_provisionalDependencies.last.isNotEmpty) {\n              containsCycle = true;\n            }\n          }\n          _path.length = _contractedPath.last;\n          _provisionalDependencies.length = _contractedPath.last;\n          _contractedPath.removeLast();\n          return new StronglyConnectedComponent<Node>(nodes, containsCycle);\n        } else {\n          // At least one node in the current strongly connected component\n          // still needs to have its inputs examined.  So loop and allow the\n          // inputs to be examined.\n          continue;\n        }\n      }\n    }\n    // No further strongly connected components found.\n    return null;\n  }\n}\n\n/**\n * A place to define the behaviors that need to be added to\n * [InternalAnalysisContext].\n */\nabstract class ExtendedAnalysisContext implements InternalAnalysisContext {\n  List<AnalysisTarget> get explicitTargets;\n  List<AnalysisTarget> get priorityTargets;\n  void set typeProvider(TypeProvider typeProvider);\n  CacheEntry getCacheEntry(AnalysisTarget target);\n}\n\n/**\n * An exception indicating that an attempt was made to perform a task on a\n * target while gathering the inputs to perform the same task for the same\n * target.\n */\nclass InfiniteTaskLoopException extends AnalysisException {\n  /**\n   * A concrete cyclic path of [TargetedResults] within the [dependencyCycle],\n   * `null` if no such path exists.  All nodes in the path are in the\n   * dependencyCycle, but the path is not guaranteed to cover the\n   * entire cycle.\n   */\n  final List<TargetedResult> cyclicPath;\n\n  /**\n   * If a dependency cycle was found while computing the inputs for the task,\n   * the set of [WorkItem]s contained in the cycle (if there are overlapping\n   * cycles, this is the set of all [WorkItem]s in the entire strongly\n   * connected component).  Otherwise, `null`.\n   */\n  final List<WorkItem> dependencyCycle;\n\n  /**\n   * Initialize a newly created exception to represent a failed attempt to\n   * perform the given [task] due to the given [dependencyCycle].\n   */\n  InfiniteTaskLoopException(AnalysisTask task, List<WorkItem> dependencyCycle,\n      [List<TargetedResult> cyclicPath])\n      : this.dependencyCycle = dependencyCycle,\n        this.cyclicPath = cyclicPath,\n        super(_composeMessage(task, dependencyCycle, cyclicPath));\n\n  /**\n   * Compose an error message based on the data we have available.\n   */\n  static String _composeMessage(AnalysisTask task,\n      List<WorkItem> dependencyCycle, List<TargetedResult> cyclicPath) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.write('Infinite loop while performing task ');\n    buffer.write(task.descriptor.name);\n    buffer.write(' for ');\n    buffer.writeln(task.target);\n    buffer.writeln('  Dependency Cycle:');\n    for (WorkItem item in dependencyCycle) {\n      buffer.write('    ');\n      buffer.writeln(item);\n    }\n    if (cyclicPath != null) {\n      buffer.writeln('  Cyclic Path:');\n      for (TargetedResult result in cyclicPath) {\n        buffer.write('    ');\n        buffer.writeln(result);\n      }\n    }\n    return buffer.toString();\n  }\n}\n\n/**\n * Object used by [CycleAwareDependencyWalker] to report a single strongly\n * connected component of nodes.\n */\nclass StronglyConnectedComponent<Node> {\n  /**\n   * The nodes contained in the strongly connected component.\n   */\n  final List<Node> nodes;\n\n  /**\n   * Indicates whether the strongly component contains any cycles.  Note that\n   * if [nodes] has multiple elements, this will always be `true`.  However, if\n   * [nodes] has exactly one element, this may be either `true` or `false`\n   * depending on whether the node has a dependency on itself.\n   */\n  final bool containsCycle;\n\n  StronglyConnectedComponent(this.nodes, this.containsCycle);\n}\n\n/**\n * A description of a single analysis task that can be performed to advance\n * analysis.\n */\nclass WorkItem {\n  /**\n   * The context in which the task will be performed.\n   */\n  final InternalAnalysisContext context;\n\n  /**\n   * The target for which a task is to be performed.\n   */\n  final AnalysisTarget target;\n\n  /**\n   * A description of the task to be performed.\n   */\n  final TaskDescriptor descriptor;\n\n  /**\n   * The [ResultDescriptor] which was led to this work item being spawned.\n   */\n  final ResultDescriptor spawningResult;\n\n  /**\n   * The level of this item in its [WorkOrder].\n   */\n  final int level;\n\n  /**\n   * The work order that this item is part of, may be `null`.\n   */\n  WorkOrder workOrder;\n\n  /**\n   * An iterator used to iterate over the descriptors of the inputs to the task,\n   * or `null` if all of the inputs have been collected and the task can be\n   * created.\n   */\n  TopLevelTaskInputBuilder builder;\n\n  /**\n   * The [TargetedResult]s outputs of this task depends on.\n   */\n  final HashSet<TargetedResult> inputTargetedResults =\n      new HashSet<TargetedResult>();\n\n  /**\n   * The inputs to the task that have been computed.\n   */\n  Map<String, dynamic> inputs = const <String, dynamic>{};\n\n  /**\n   * The exception that was found while trying to populate the inputs. If this\n   * field is non-`null`, then the task cannot be performed and all of the\n   * results that this task would have computed need to be marked as being in\n   * ERROR with this exception.\n   */\n  CaughtException exception = null;\n\n  /**\n   * If a dependency cycle was found while computing the inputs for the task,\n   * the set of [WorkItem]s contained in the cycle (if there are overlapping\n   * cycles, this is the set of all [WorkItem]s in the entire strongly\n   * connected component).  Otherwise, `null`.\n   */\n  List<WorkItem> dependencyCycle;\n\n  /**\n   * Initialize a newly created work item to compute the inputs for the task\n   * described by the given descriptor.\n   */\n  WorkItem(this.context, this.target, this.descriptor, this.spawningResult,\n      this.level, this.workOrder) {\n    AnalysisTarget actualTarget =\n        identical(target, AnalysisContextTarget.request)\n            ? new AnalysisContextTarget(context)\n            : target;\n//    print('${'\\t' * level}$spawningResult of $actualTarget');\n    Map<String, TaskInput> inputDescriptors =\n        descriptor.createTaskInputs(actualTarget);\n    builder = new TopLevelTaskInputBuilder(inputDescriptors);\n    if (!builder.moveNext()) {\n      builder = null;\n    }\n  }\n\n  @override\n  int get hashCode =>\n      JenkinsSmiHash.hash2(descriptor.hashCode, target.hashCode);\n\n  @override\n  bool operator ==(other) {\n    if (other is WorkItem) {\n      return this.descriptor == other.descriptor && this.target == other.target;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Build the task represented by this work item.\n   */\n  AnalysisTask buildTask() {\n    if (builder != null) {\n      throw new StateError(\"some inputs have not been computed\");\n    }\n    AnalysisTask task = descriptor.createTask(context, target, inputs);\n    task.dependencyCycle = dependencyCycle;\n    return task;\n  }\n\n  /**\n   * Gather all of the inputs needed to perform the task.\n   *\n   * If at least one of the inputs have not yet been computed, return a work\n   * item that can be used to generate that input to indicate that the caller\n   * should perform the returned item's task before returning to gathering\n   * inputs for this item's task.\n   *\n   * If all of the inputs have been gathered, return `null` to indicate that the\n   * client should build and perform the task. A value of `null` will also be\n   * returned if some of the inputs cannot be computed and the task cannot be\n   * performed. Callers can differentiate between these cases by checking the\n   * [exception] field. If the field is `null`, then the task can be performed;\n   * if the field is non-`null` then the task cannot be performed and all of the\n   * tasks' results should be marked as being in ERROR.\n   */\n  WorkItem gatherInputs(TaskManager taskManager, List<WorkItem> skipInputs) {\n    while (builder != null) {\n      AnalysisTarget inputTarget = builder.currentTarget;\n      ResultDescriptor inputResult = builder.currentResult;\n\n      // TODO(scheglov) record information to debug\n      // https://github.com/dart-lang/sdk/issues/24939\n      if (inputTarget == null || inputResult == null) {\n        try {\n          String message =\n              'Invalid input descriptor ($inputTarget, $inputResult) for $this';\n          if (workOrder != null) {\n            message += '\\nPath:\\n' + workOrder.workItems.join('|\\n');\n          }\n          throw new AnalysisException(message);\n        } catch (exception, stackTrace) {\n          this.exception = new CaughtException(exception, stackTrace);\n          AnalysisEngine.instance.logger\n              .logError('Task failed: $this', this.exception);\n        }\n        return null;\n      }\n\n      inputTargetedResults.add(new TargetedResult(inputTarget, inputResult));\n      CacheEntry inputEntry = context.getCacheEntry(inputTarget);\n      CacheState inputState = inputEntry.getState(inputResult);\n      if (inputState == CacheState.ERROR) {\n        exception = inputEntry.exception;\n        return null;\n      } else if (inputState == CacheState.IN_PROCESS) {\n        //\n        // TODO(brianwilkerson) Implement this case.\n        //\n        // One possibility would be to return a WorkItem that would perform a\n        // no-op task in order to cause us to come back to this work item on the\n        // next iteration. It would be more efficient, in general, to push this\n        // input onto a waiting list and proceed to the next input so that work\n        // could proceed, but given that the only result that can currently be\n        // IN_PROCESS is CONTENT, I don't know that it's worth the extra effort\n        // to implement the general solution at this point.\n        //\n        throw new UnimplementedError();\n      } else if (inputState != CacheState.VALID) {\n        if (context.aboutToComputeResult(inputEntry, inputResult)) {\n          inputState = CacheState.VALID;\n          builder.currentValue = inputEntry.getValue(inputResult);\n        } else {\n          try {\n            TaskDescriptor descriptor =\n                taskManager.findTask(inputTarget, inputResult);\n            if (descriptor == null) {\n              throw new AnalysisException(\n                  'Cannot find task to build $inputResult for $inputTarget');\n            }\n            if (skipInputs.any((WorkItem item) =>\n                item.target == inputTarget && item.descriptor == descriptor)) {\n              // This input is being skipped due to a circular dependency.  Tell\n              // the builder that it's not available so we can move on to other\n              // inputs.\n              builder.currentValueNotAvailable();\n            } else {\n              return new WorkItem(context, inputTarget, descriptor, inputResult,\n                  level + 1, workOrder);\n            }\n          } on AnalysisException catch (exception, stackTrace) {\n            this.exception = new CaughtException(exception, stackTrace);\n            return null;\n          } catch (exception, stackTrace) {\n            this.exception = new CaughtException(exception, stackTrace);\n            throw new AnalysisException(\n                'Cannot create work order to build $inputResult for $inputTarget',\n                this.exception);\n          }\n        }\n      } else {\n        builder.currentValue = inputEntry.getValue(inputResult);\n        if (builder.flushOnAccess) {\n          inputEntry.setState(inputResult, CacheState.FLUSHED);\n        }\n      }\n      if (!builder.moveNext()) {\n        inputs = builder.inputValue;\n        builder = null;\n      }\n    }\n    return null;\n  }\n\n  @override\n  String toString() => 'Run $descriptor on $target';\n}\n\n/**\n * A description of the work to be done to compute a desired analysis result.\n * The class implements a lazy depth-first traversal of the work item's input.\n */\nclass WorkOrder implements Iterator<WorkItem> {\n  /**\n   * The dependency walker which is being used to determine what work to do\n   * next.\n   */\n  final _WorkOrderDependencyWalker _dependencyWalker;\n\n  /**\n   * The strongly connected component most recently returned by\n   * [_dependencyWalker], minus any [WorkItem]s that the iterator has already\n   * moved past.\n   *\n   * Null if the [_dependencyWalker] hasn't been used yet.\n   */\n  List<WorkItem> currentItems;\n\n  /**\n   * Initialize a newly created work order to compute the result described by\n   * the given work item.\n   */\n  WorkOrder(TaskManager taskManager, WorkItem item)\n      : _dependencyWalker = new _WorkOrderDependencyWalker(taskManager, item) {\n    item.workOrder = this;\n  }\n\n  @override\n  WorkItem get current {\n    if (currentItems == null) {\n      return null;\n    } else {\n      return currentItems.last;\n    }\n  }\n\n  List<WorkItem> get workItems => _dependencyWalker._path;\n\n  @override\n  bool moveNext() {\n    return workOrderMoveNextPerformanceTag.makeCurrentWhile(() {\n      if (currentItems != null && currentItems.length > 1) {\n        // Yield more items.\n        currentItems.removeLast();\n        return true;\n      } else {\n        // Get a new strongly connected component.\n        StronglyConnectedComponent<WorkItem> nextStronglyConnectedComponent =\n            _dependencyWalker.getNextStronglyConnectedComponent();\n        if (nextStronglyConnectedComponent == null) {\n          currentItems = null;\n          return false;\n        }\n        currentItems = nextStronglyConnectedComponent.nodes;\n        if (nextStronglyConnectedComponent.containsCycle) {\n          // A cycle has been found.\n          for (WorkItem item in currentItems) {\n            item.dependencyCycle = currentItems.toList();\n          }\n        } else {\n          assert(currentItems.length == 1);\n        }\n        return true;\n      }\n    });\n  }\n}\n\n/**\n * Specialization of [CycleAwareDependencyWalker] for use by [WorkOrder].\n */\nclass _WorkOrderDependencyWalker extends CycleAwareDependencyWalker<WorkItem> {\n  /**\n   * The task manager used to build work items.\n   */\n  final TaskManager taskManager;\n\n  _WorkOrderDependencyWalker(this.taskManager, WorkItem startingNode)\n      : super(startingNode);\n\n  @override\n  WorkItem getNextInput(WorkItem node, List<WorkItem> skipInputs) {\n    return node.gatherInputs(taskManager, skipInputs);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/src/task/driver.dart	(date 1533041846000)
+++ lib/src/task/driver.dart	(date 1533825325000)
@@ -11,6 +11,7 @@
 import 'package:analyzer/src/generated/resolver.dart';
 import 'package:analyzer/src/generated/utilities_general.dart';
 import 'package:analyzer/src/task/api/model.dart';
+import 'package:analyzer/src/task/dart.dart';
 import 'package:analyzer/src/task/inputs.dart';
 import 'package:analyzer/src/task/manager.dart';
 
@@ -725,6 +726,9 @@
       }
 
       inputTargetedResults.add(new TargetedResult(inputTarget, inputResult));
+      if (inputTarget.librarySource?.source?.shortName == 'date_picker.template.dart' && inputResult == RESOLVED_UNIT1) {
+        print('!!! Gather Input requires RESOLVED_UNIT1 for $target');
+      }
       CacheEntry inputEntry = context.getCacheEntry(inputTarget);
       CacheState inputState = inputEntry.getState(inputResult);
       if (inputState == CacheState.ERROR) {
